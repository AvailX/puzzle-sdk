diff --git a/dist/index.js b/dist/index.js
index 136cf40ce4383ba2cc462f41413ae5aaf73f728b..d5dd89d56c646b6405969cd024021f54ae157fef 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,2 +1,222 @@
-import{memo as h,useEffect as l,useState as p}from"react";import{WalletConnectModalSign as m}from"@walletconnect/modal-sign-html";import w from"mitt";const g=w();let d;function O(n){d=new m(n)}async function s(){return new Promise(n=>{if(d)n(d);else{const e=setInterval(()=>{d&&(clearInterval(e),n(d))},200)}})}function E(n){return l(()=>{O(n)},[]),null}const A=h(E);function v(){const[n,e]=p(void 0),[t,o]=p(void 0),[r,a]=p(!1);return{data:n,error:t,loading:r,setData:e,setError:o,setLoading:a}}function R(n){const{data:e,error:t,loading:o,setData:r,setError:a,setLoading:c}=v();async function u(f){try{c(!0),a(void 0);const i=await(await s()).connect(f??n);return r(i),g.emit("session_change"),i}catch(i){throw a(i),i}finally{c(!1)}}return{data:e,error:t,loading:o,connect:u}}function $(n){const{error:e,loading:t,setError:o,setLoading:r}=v();async function a(c){try{r(!0),o(void 0),await(await s()).disconnect(c??n),g.emit("session_change")}catch(u){throw o(u),u}finally{r(!1)}}return{error:e,loading:t,disconnect:a}}function b(n){l(()=>(s().then(e=>{e.onSessionDelete(n)}),()=>{s().then(e=>{e.offSessionDelete(n)})}),[n])}function k(n){l(()=>(s().then(e=>{e.onSessionEvent(n)}),()=>{s().then(e=>{e.offSessionEvent(n)})}),[n])}function C(n){l(()=>(s().then(e=>{e.onSessionExpire(n)}),()=>{s().then(e=>{e.offSessionExpire(n)})}),[n])}function D(n){l(()=>(s().then(e=>{e.onSessionUpdate(n)}),()=>{s().then(e=>{e.offSessionUpdate(n)})}),[n])}function z(n){const{data:e,error:t,loading:o,setData:r,setError:a,setLoading:c}=v();async function u(f){try{c(!0),a(void 0);const i=await(await s()).request(f??n);return r(i),i}catch(i){throw a(i),i}finally{c(!1)}}return{data:e,error:t,loading:o,request:u}}var j=Object.defineProperty,P=Object.defineProperties,M=Object.getOwnPropertyDescriptors,S=Object.getOwnPropertySymbols,W=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable,y=(n,e,t)=>e in n?j(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,L=(n,e)=>{for(var t in e||(e={}))W.call(e,t)&&y(n,t,e[t]);if(S)for(var t of S(e))x.call(e,t)&&y(n,t,e[t]);return n},_=(n,e)=>P(n,M(e));function B(){const[n,e]=p(void 0);return b(t=>{t.topic===n?.topic&&e(void 0)}),D(t=>{if(n&&t.topic===n?.topic){const{namespaces:o}=t.params,r=_(L({},n),{namespaces:o});e(r)}}),C(t=>{n&&t.topic===n?.topic&&e(void 0)}),l(()=>{async function t(){const o=await(await s()).getSession();e(o)}return t(),g.on("session_change",t),()=>{g.off("session_change",t)}},[]),n}function F(){const[n,e]=p(void 0);return l(()=>{async function t(){const o=await(await s()).getSessions();e(o)}t()},[]),n}export{A as WalletConnectModalSign,R as useConnect,$ as useDisconnect,b as useOnSessionDelete,k as useOnSessionEvent,C as useOnSessionExpire,D as useOnSessionUpdate,z as useRequest,B as useSession,F as useSessions};
-//# sourceMappingURL=index.js.map
+import {
+  memo as h,
+  useEffect as l,
+  useState as p
+} from "react";
+import {
+  WalletConnectModalSign as m
+} from "@walletconnect/modal-sign-html";
+import w from "mitt";
+const g = w();
+let d;
+
+function O(n) {
+  d = new m(n)
+}
+async function s() {
+  return new Promise(n => {
+      if (d) n(d);
+      else {
+          const e = setInterval(() => {
+              d && (clearInterval(e), n(d))
+          }, 200)
+      }
+  })
+}
+
+function E(n) {
+  return l(() => {
+      O(n)
+  }, []), null
+}
+const A = h(E);
+
+function v() {
+  const [n, e] = p(void 0), [t, o] = p(void 0), [r, a] = p(!1);
+  return {
+      data: n,
+      error: t,
+      loading: r,
+      setData: e,
+      setError: o,
+      setLoading: a
+  }
+}
+
+function R(n) {
+  const {
+      data: e,
+      error: t,
+      loading: o,
+      setData: r,
+      setError: a,
+      setLoading: c
+  } = v();
+  async function u(f) {
+      try {
+          c(!0), a(void 0);
+          const i = await (await s()).connect(f ?? n);
+          return r(i), g.emit("session_change"), i
+      } catch (i) {
+          throw a(i), i
+      } finally {
+          c(!1)
+      }
+  }
+  return {
+      data: e,
+      error: t,
+      loading: o,
+      connect: u
+  }
+}
+
+function $(n) {
+  const {
+      error: e,
+      loading: t,
+      setError: o,
+      setLoading: r
+  } = v();
+  async function a(c) {
+      try {
+          r(!0), o(void 0), await (await s()).disconnect(c ?? n), g.emit("session_change")
+      } catch (u) {
+          throw o(u), u
+      } finally {
+          r(!1)
+      }
+  }
+  return {
+      error: e,
+      loading: t,
+      disconnect: a
+  }
+}
+
+function b(n) {
+  l(() => (s().then(e => {
+      e.onSessionDelete(n)
+  }), () => {
+      s().then(e => {
+          // e.offSessionDelete(n)
+      })
+  }), [n])
+}
+
+function k(n) {
+  l(() => (s().then(e => {
+      e.onSessionEvent(n)
+  }), () => {
+      s().then(e => {
+          // e.offSessionEvent(n)
+      })
+  }), [n])
+}
+
+function C(n) {
+  l(() => (s().then(e => {
+      e.onSessionExpire(n)
+  }), () => {
+      s().then(e => {
+          // e.offSessionExpire(n)
+      })
+  }), [n])
+}
+
+function D(n) {
+  l(() => (s().then(e => {
+      e.onSessionUpdate(n)
+  }), () => {
+      s().then(e => {
+          // e.offSessionUpdate(n)
+      })
+  }), [n])
+}
+
+function z(n) {
+  const {
+      data: e,
+      error: t,
+      loading: o,
+      setData: r,
+      setError: a,
+      setLoading: c
+  } = v();
+  async function u(f) {
+      try {
+          c(!0), a(void 0);
+          const i = await (await s()).request(f ?? n);
+          return r(i), i
+      } catch (i) {
+          throw a(i), i
+      } finally {
+          c(!1)
+      }
+  }
+  return {
+      data: e,
+      error: t,
+      loading: o,
+      request: u
+  }
+}
+var j = Object.defineProperty,
+  P = Object.defineProperties,
+  M = Object.getOwnPropertyDescriptors,
+  S = Object.getOwnPropertySymbols,
+  W = Object.prototype.hasOwnProperty,
+  x = Object.prototype.propertyIsEnumerable,
+  y = (n, e, t) => e in n ? j(n, e, {
+      enumerable: !0,
+      configurable: !0,
+      writable: !0,
+      value: t
+  }) : n[e] = t,
+  L = (n, e) => {
+      for (var t in e || (e = {})) W.call(e, t) && y(n, t, e[t]);
+      if (S)
+          for (var t of S(e)) x.call(e, t) && y(n, t, e[t]);
+      return n
+  },
+  _ = (n, e) => P(n, M(e));
+
+function B() {
+  const [n, e] = p(void 0);
+  return b(t => {
+      t.topic === n?.topic && e(void 0)
+  }), D(t => {
+      if (n && t.topic === n?.topic) {
+          const {
+              namespaces: o
+          } = t.params, r = _(L({}, n), {
+              namespaces: o
+          });
+          e(r)
+      }
+  }), C(t => {
+      n && t.topic === n?.topic && e(void 0)
+  }), l(() => {
+      async function t() {
+          const o = await (await s()).getSession();
+          e(o)
+      }
+      return t(), g.on("session_change", t), () => {
+          // g.off("session_change", t)
+      }
+  }, []), n
+}
+
+function F() {
+  const [n, e] = p(void 0);
+  return l(() => {
+      async function t() {
+          const o = await (await s()).getSessions();
+          e(o)
+      }
+      t()
+  }, []), n
+}
+export {
+  A as WalletConnectModalSign, R as useConnect, $ as useDisconnect, b as useOnSessionDelete, k as useOnSessionEvent, C as useOnSessionExpire, D as useOnSessionUpdate, z as useRequest, B as useSession, F as useSessions
+};//# sourceMappingURL=index.js.map