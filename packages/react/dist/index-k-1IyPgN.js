var Up = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
};
var Zt = (t, e, r) => (Up(t, e, "read from private field"), r ? r.call(t) : e.get(t)), ln = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, Jr = (t, e, r, n) => (Up(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
import * as Br from "react";
import Zi, { useEffect as pr, useState as Ea, useRef as X_ } from "react";
const e1 = Symbol(), $p = Object.getPrototypeOf, id = /* @__PURE__ */ new WeakMap(), t1 = (t) => t && (id.has(t) ? id.get(t) : $p(t) === Object.prototype || $p(t) === Array.prototype), r1 = (t) => t1(t) && t[e1] || null, Fp = (t, e = !0) => {
  id.set(t, e);
};
var pu = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const ph = (t) => typeof t == "object" && t !== null, Pi = /* @__PURE__ */ new WeakMap(), jc = /* @__PURE__ */ new WeakSet(), n1 = (t = Object.is, e = (u, h) => new Proxy(u, h), r = (u) => ph(u) && !jc.has(u) && (Array.isArray(u) || !(Symbol.iterator in u)) && !(u instanceof WeakMap) && !(u instanceof WeakSet) && !(u instanceof Error) && !(u instanceof Number) && !(u instanceof Date) && !(u instanceof String) && !(u instanceof RegExp) && !(u instanceof ArrayBuffer), n = (u) => {
  switch (u.status) {
    case "fulfilled":
      return u.value;
    case "rejected":
      throw u.reason;
    default:
      throw u;
  }
}, i = /* @__PURE__ */ new WeakMap(), s = (u, h, f = n) => {
  const g = i.get(u);
  if ((g == null ? void 0 : g[0]) === h)
    return g[1];
  const m = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u));
  return Fp(m, !0), i.set(u, [h, m]), Reflect.ownKeys(u).forEach((w) => {
    if (Object.getOwnPropertyDescriptor(m, w))
      return;
    const S = Reflect.get(u, w), x = {
      value: S,
      enumerable: !0,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: !0
    };
    if (jc.has(S))
      Fp(S, !1);
    else if (S instanceof Promise)
      delete x.value, x.get = () => f(S);
    else if (Pi.has(S)) {
      const [M, _] = Pi.get(
        S
      );
      x.value = s(
        M,
        _(),
        f
      );
    }
    Object.defineProperty(m, w, x);
  }), Object.preventExtensions(m);
}, a = /* @__PURE__ */ new WeakMap(), o = [1, 1], l = (u) => {
  if (!ph(u))
    throw new Error("object required");
  const h = a.get(u);
  if (h)
    return h;
  let f = o[0];
  const g = /* @__PURE__ */ new Set(), m = (D, R = ++o[0]) => {
    f !== R && (f = R, g.forEach((k) => k(D, R)));
  };
  let w = o[1];
  const S = (D = ++o[1]) => (w !== D && !g.size && (w = D, M.forEach(([R]) => {
    const k = R[1](D);
    k > f && (f = k);
  })), f), x = (D) => (R, k) => {
    const B = [...R];
    B[1] = [D, ...B[1]], m(B, k);
  }, M = /* @__PURE__ */ new Map(), _ = (D, R) => {
    if ((pu ? "production" : void 0) !== "production" && M.has(D))
      throw new Error("prop listener already exists");
    if (g.size) {
      const k = R[3](x(D));
      M.set(D, [R, k]);
    } else
      M.set(D, [R]);
  }, I = (D) => {
    var R;
    const k = M.get(D);
    k && (M.delete(D), (R = k[1]) == null || R.call(k));
  }, b = (D) => (g.add(D), g.size === 1 && M.forEach(([k, B], W) => {
    if ((pu ? "production" : void 0) !== "production" && B)
      throw new Error("remove already exists");
    const C = k[3](x(W));
    M.set(W, [k, C]);
  }), () => {
    g.delete(D), g.size === 0 && M.forEach(([k, B], W) => {
      B && (B(), M.set(W, [k]));
    });
  }), E = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u)), c = e(E, {
    deleteProperty(D, R) {
      const k = Reflect.get(D, R);
      I(R);
      const B = Reflect.deleteProperty(D, R);
      return B && m(["delete", [R], k]), B;
    },
    set(D, R, k, B) {
      const W = Reflect.has(D, R), C = Reflect.get(D, R, B);
      if (W && (t(C, k) || a.has(k) && t(C, a.get(k))))
        return !0;
      I(R), ph(k) && (k = r1(k) || k);
      let N = k;
      if (k instanceof Promise)
        k.then((G) => {
          k.status = "fulfilled", k.value = G, m(["resolve", [R], G]);
        }).catch((G) => {
          k.status = "rejected", k.reason = G, m(["reject", [R], G]);
        });
      else {
        !Pi.has(k) && r(k) && (N = l(k));
        const G = !jc.has(N) && Pi.get(N);
        G && _(R, G);
      }
      return Reflect.set(D, R, N, B), m(["set", [R], k, C]), !0;
    }
  });
  a.set(u, c);
  const p = [
    E,
    S,
    s,
    b
  ];
  return Pi.set(c, p), Reflect.ownKeys(u).forEach((D) => {
    const R = Object.getOwnPropertyDescriptor(
      u,
      D
    );
    "value" in R && (c[D] = u[D], delete R.value, delete R.writable), Object.defineProperty(E, D, R);
  }), c;
}) => [
  // public functions
  l,
  // shared state
  Pi,
  jc,
  // internal things
  t,
  e,
  r,
  n,
  i,
  s,
  a,
  o
], [i1] = n1();
function Yi(t = {}) {
  return i1(t);
}
function Ps(t, e, r) {
  const n = Pi.get(t);
  (pu ? "production" : void 0) !== "production" && !n && console.warn("Please use proxy object");
  let i;
  const s = [], a = n[3];
  let o = !1;
  const u = a((h) => {
    if (s.push(h), r) {
      e(s.splice(0));
      return;
    }
    i || (i = Promise.resolve().then(() => {
      i = void 0, o && e(s.splice(0));
    }));
  });
  return o = !0, () => {
    o = !1, u();
  };
}
function s1(t, e) {
  const r = Pi.get(t);
  (pu ? "production" : void 0) !== "production" && !r && console.warn("Please use proxy object");
  const [n, i, s] = r;
  return s(n, i(), e);
}
const rr = Yi({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 }), n0 = { state: rr, subscribe(t) {
  return Ps(rr, () => t(rr));
}, push(t, e) {
  t !== rr.view && (rr.view = t, e && (rr.data = e), rr.history.push(t));
}, reset(t) {
  rr.view = t, rr.history = [t];
}, replace(t) {
  rr.history.length > 1 && (rr.history[rr.history.length - 1] = t, rr.view = t);
}, goBack() {
  if (rr.history.length > 1) {
    rr.history.pop();
    const [t] = rr.history.slice(-1);
    rr.view = t;
  }
}, setData(t) {
  rr.data = t;
} }, Cr = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", WCM_VERSION: "WCM_VERSION", RECOMMENDED_WALLET_AMOUNT: 9, isMobile() {
  return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
}, isAndroid() {
  return Cr.isMobile() && navigator.userAgent.toLowerCase().includes("android");
}, isIos() {
  const t = navigator.userAgent.toLowerCase();
  return Cr.isMobile() && (t.includes("iphone") || t.includes("ipad"));
}, isHttpUrl(t) {
  return t.startsWith("http://") || t.startsWith("https://");
}, isArray(t) {
  return Array.isArray(t) && t.length > 0;
}, formatNativeUrl(t, e, r) {
  if (Cr.isHttpUrl(t))
    return this.formatUniversalUrl(t, e, r);
  let n = t;
  n.includes("://") || (n = t.replaceAll("/", "").replaceAll(":", ""), n = `${n}://`), n.endsWith("/") || (n = `${n}/`), this.setWalletConnectDeepLink(n, r);
  const i = encodeURIComponent(e);
  return `${n}wc?uri=${i}`;
}, formatUniversalUrl(t, e, r) {
  if (!Cr.isHttpUrl(t))
    return this.formatNativeUrl(t, e, r);
  let n = t;
  n.endsWith("/") || (n = `${n}/`), this.setWalletConnectDeepLink(n, r);
  const i = encodeURIComponent(e);
  return `${n}wc?uri=${i}`;
}, async wait(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}, openHref(t, e) {
  window.open(t, e, "noreferrer noopener");
}, setWalletConnectDeepLink(t, e) {
  try {
    localStorage.setItem(Cr.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t, name: e }));
  } catch {
    console.info("Unable to set WalletConnect deep link");
  }
}, setWalletConnectAndroidDeepLink(t) {
  try {
    const [e] = t.split("?");
    localStorage.setItem(Cr.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e, name: "Android" }));
  } catch {
    console.info("Unable to set WalletConnect android deep link");
  }
}, removeWalletConnectDeepLink() {
  try {
    localStorage.removeItem(Cr.WALLETCONNECT_DEEPLINK_CHOICE);
  } catch {
    console.info("Unable to remove WalletConnect deep link");
  }
}, setModalVersionInStorage() {
  try {
    typeof localStorage < "u" && localStorage.setItem(Cr.WCM_VERSION, "2.6.2");
  } catch {
    console.info("Unable to set Web3Modal version in storage");
  }
}, getWalletRouterData() {
  var t;
  const e = (t = n0.state.data) == null ? void 0 : t.Wallet;
  if (!e)
    throw new Error('Missing "Wallet" view data');
  return e;
} }, o1 = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https")), br = Yi({ enabled: o1, userSessionId: "", events: [], connectedWalletId: void 0 }), a1 = { state: br, subscribe(t) {
  return Ps(br.events, () => t(s1(br.events[br.events.length - 1])));
}, initialize() {
  br.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (br.userSessionId = crypto.randomUUID());
}, setConnectedWalletId(t) {
  br.connectedWalletId = t;
}, click(t) {
  if (br.enabled) {
    const e = { type: "CLICK", name: t.name, userSessionId: br.userSessionId, timestamp: Date.now(), data: t };
    br.events.push(e);
  }
}, track(t) {
  if (br.enabled) {
    const e = { type: "TRACK", name: t.name, userSessionId: br.userSessionId, timestamp: Date.now(), data: t };
    br.events.push(e);
  }
}, view(t) {
  if (br.enabled) {
    const e = { type: "VIEW", name: t.name, userSessionId: br.userSessionId, timestamp: Date.now(), data: t };
    br.events.push(e);
  }
} }, zn = Yi({ chains: void 0, walletConnectUri: void 0, isAuth: !1, isCustomDesktop: !1, isCustomMobile: !1, isDataLoaded: !1, isUiLoaded: !1 }), Tn = { state: zn, subscribe(t) {
  return Ps(zn, () => t(zn));
}, setChains(t) {
  zn.chains = t;
}, setWalletConnectUri(t) {
  zn.walletConnectUri = t;
}, setIsCustomDesktop(t) {
  zn.isCustomDesktop = t;
}, setIsCustomMobile(t) {
  zn.isCustomMobile = t;
}, setIsDataLoaded(t) {
  zn.isDataLoaded = t;
}, setIsUiLoaded(t) {
  zn.isUiLoaded = t;
}, setIsAuth(t) {
  zn.isAuth = t;
} }, kc = Yi({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chains: void 0, enableAuthMode: !1, enableExplorer: !0, explorerExcludedWalletIds: void 0, explorerRecommendedWalletIds: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 }), _o = { state: kc, subscribe(t) {
  return Ps(kc, () => t(kc));
}, setConfig(t) {
  var e, r;
  a1.initialize(), Tn.setChains(t.chains), Tn.setIsAuth(!!t.enableAuthMode), Tn.setIsCustomMobile(!!((e = t.mobileWallets) != null && e.length)), Tn.setIsCustomDesktop(!!((r = t.desktopWallets) != null && r.length)), Cr.setModalVersionInStorage(), Object.assign(kc, t);
} };
var c1 = Object.defineProperty, qp = Object.getOwnPropertySymbols, u1 = Object.prototype.hasOwnProperty, l1 = Object.prototype.propertyIsEnumerable, zp = (t, e, r) => e in t ? c1(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, h1 = (t, e) => {
  for (var r in e || (e = {}))
    u1.call(e, r) && zp(t, r, e[r]);
  if (qp)
    for (var r of qp(e))
      l1.call(e, r) && zp(t, r, e[r]);
  return t;
};
const sd = "https://explorer-api.walletconnect.com", od = "wcm", ad = "js-2.6.2";
async function Uc(t, e) {
  const r = h1({ sdkType: od, sdkVersion: ad }, e), n = new URL(t, sd);
  return n.searchParams.append("projectId", _o.state.projectId), Object.entries(r).forEach(([i, s]) => {
    s && n.searchParams.append(i, String(s));
  }), (await fetch(n)).json();
}
const ts = { async getDesktopListings(t) {
  return Uc("/w3m/v1/getDesktopListings", t);
}, async getMobileListings(t) {
  return Uc("/w3m/v1/getMobileListings", t);
}, async getInjectedListings(t) {
  return Uc("/w3m/v1/getInjectedListings", t);
}, async getAllListings(t) {
  return Uc("/w3m/v1/getAllListings", t);
}, getWalletImageUrl(t) {
  return `${sd}/w3m/v1/getWalletImage/${t}?projectId=${_o.state.projectId}&sdkType=${od}&sdkVersion=${ad}`;
}, getAssetImageUrl(t) {
  return `${sd}/w3m/v1/getAssetImage/${t}?projectId=${_o.state.projectId}&sdkType=${od}&sdkVersion=${ad}`;
} };
var d1 = Object.defineProperty, Vp = Object.getOwnPropertySymbols, f1 = Object.prototype.hasOwnProperty, p1 = Object.prototype.propertyIsEnumerable, Kp = (t, e, r) => e in t ? d1(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, g1 = (t, e) => {
  for (var r in e || (e = {}))
    f1.call(e, r) && Kp(t, r, e[r]);
  if (Vp)
    for (var r of Vp(e))
      p1.call(e, r) && Kp(t, r, e[r]);
  return t;
};
const Bp = Cr.isMobile(), Vn = Yi({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, recomendedWallets: [] }), GU = { state: Vn, async getRecomendedWallets() {
  const { explorerRecommendedWalletIds: t, explorerExcludedWalletIds: e } = _o.state;
  if (t === "NONE" || e === "ALL" && !t)
    return Vn.recomendedWallets;
  if (Cr.isArray(t)) {
    const r = { recommendedIds: t.join(",") }, { listings: n } = await ts.getAllListings(r), i = Object.values(n);
    i.sort((s, a) => {
      const o = t.indexOf(s.id), l = t.indexOf(a.id);
      return o - l;
    }), Vn.recomendedWallets = i;
  } else {
    const { chains: r, isAuth: n } = Tn.state, i = r == null ? void 0 : r.join(","), s = Cr.isArray(e), a = { page: 1, sdks: n ? "auth_v1" : void 0, entries: Cr.RECOMMENDED_WALLET_AMOUNT, chains: i, version: 2, excludedIds: s ? e.join(",") : void 0 }, { listings: o } = Bp ? await ts.getMobileListings(a) : await ts.getDesktopListings(a);
    Vn.recomendedWallets = Object.values(o);
  }
  return Vn.recomendedWallets;
}, async getWallets(t) {
  const e = g1({}, t), { explorerRecommendedWalletIds: r, explorerExcludedWalletIds: n } = _o.state, { recomendedWallets: i } = Vn;
  if (n === "ALL")
    return Vn.wallets;
  i.length ? e.excludedIds = i.map((f) => f.id).join(",") : Cr.isArray(r) && (e.excludedIds = r.join(",")), Cr.isArray(n) && (e.excludedIds = [e.excludedIds, n].filter(Boolean).join(",")), Tn.state.isAuth && (e.sdks = "auth_v1");
  const { page: s, search: a } = t, { listings: o, total: l } = Bp ? await ts.getMobileListings(e) : await ts.getDesktopListings(e), u = Object.values(o), h = a ? "search" : "wallets";
  return Vn[h] = { listings: [...Vn[h].listings, ...u], total: l, page: s ?? 1 }, { listings: u, total: l };
}, getWalletImageUrl(t) {
  return ts.getWalletImageUrl(t);
}, getAssetImageUrl(t) {
  return ts.getAssetImageUrl(t);
}, resetSearch() {
  Vn.search = { listings: [], total: 0, page: 1 };
} }, qs = Yi({ open: !1 }), gh = { state: qs, subscribe(t) {
  return Ps(qs, () => t(qs));
}, async open(t) {
  return new Promise((e) => {
    const { isUiLoaded: r, isDataLoaded: n } = Tn.state;
    if (Cr.removeWalletConnectDeepLink(), Tn.setWalletConnectUri(t == null ? void 0 : t.uri), Tn.setChains(t == null ? void 0 : t.chains), n0.reset("ConnectWallet"), r && n)
      qs.open = !0, e();
    else {
      const i = setInterval(() => {
        const s = Tn.state;
        s.isUiLoaded && s.isDataLoaded && (clearInterval(i), qs.open = !0, e());
      }, 200);
    }
  });
}, close() {
  qs.open = !1;
} };
var y1 = Object.defineProperty, Hp = Object.getOwnPropertySymbols, m1 = Object.prototype.hasOwnProperty, v1 = Object.prototype.propertyIsEnumerable, Wp = (t, e, r) => e in t ? y1(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, b1 = (t, e) => {
  for (var r in e || (e = {}))
    m1.call(e, r) && Wp(t, r, e[r]);
  if (Hp)
    for (var r of Hp(e))
      v1.call(e, r) && Wp(t, r, e[r]);
  return t;
};
function w1() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
const Jo = Yi({ themeMode: w1() ? "dark" : "light" }), Gp = { state: Jo, subscribe(t) {
  return Ps(Jo, () => t(Jo));
}, setThemeConfig(t) {
  const { themeMode: e, themeVariables: r } = t;
  e && (Jo.themeMode = e), r && (Jo.themeVariables = b1({}, r));
} }, rs = Yi({ open: !1, message: "", variant: "success" }), ZU = { state: rs, subscribe(t) {
  return Ps(rs, () => t(rs));
}, openToast(t, e) {
  rs.open = !0, rs.message = t, rs.variant = e;
}, closeToast() {
  rs.open = !1;
} };
let _1 = class {
  constructor(e) {
    this.openModal = gh.open, this.closeModal = gh.close, this.subscribeModal = gh.subscribe, this.setTheme = Gp.setThemeConfig, Gp.setThemeConfig(e), _o.setConfig(e), this.initUi();
  }
  async initUi() {
    if (typeof window < "u") {
      await import("./index-sRpgMouz.js");
      const e = document.createElement("wcm-modal");
      document.body.insertAdjacentElement("beforeend", e), Tn.setIsUiLoaded(!0);
    }
  }
};
var Qn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function dc(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function il(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var Uf = { exports: {} }, oo = typeof Reflect == "object" ? Reflect : null, Zp = oo && typeof oo.apply == "function" ? oo.apply : function(e, r, n) {
  return Function.prototype.apply.call(e, r, n);
}, ru;
oo && typeof oo.ownKeys == "function" ? ru = oo.ownKeys : Object.getOwnPropertySymbols ? ru = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : ru = function(e) {
  return Object.getOwnPropertyNames(e);
};
function E1(t) {
  console && console.warn && console.warn(t);
}
var i0 = Number.isNaN || function(e) {
  return e !== e;
};
function Dt() {
  Dt.init.call(this);
}
Uf.exports = Dt;
Uf.exports.once = x1;
Dt.EventEmitter = Dt;
Dt.prototype._events = void 0;
Dt.prototype._eventsCount = 0;
Dt.prototype._maxListeners = void 0;
var Yp = 10;
function sl(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(Dt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Yp;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || i0(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    Yp = t;
  }
});
Dt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Dt.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || i0(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function s0(t) {
  return t._maxListeners === void 0 ? Dt.defaultMaxListeners : t._maxListeners;
}
Dt.prototype.getMaxListeners = function() {
  return s0(this);
};
Dt.prototype.emit = function(e) {
  for (var r = [], n = 1; n < arguments.length; n++)
    r.push(arguments[n]);
  var i = e === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var a;
    if (r.length > 0 && (a = r[0]), a instanceof Error)
      throw a;
    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw o.context = a, o;
  }
  var l = s[e];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    Zp(l, this, r);
  else
    for (var u = l.length, h = l0(l, u), n = 0; n < u; ++n)
      Zp(h[n], this, r);
  return !0;
};
function o0(t, e, r, n) {
  var i, s, a;
  if (sl(r), s = t._events, s === void 0 ? (s = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), s = t._events), a = s[e]), a === void 0)
    a = s[e] = r, ++t._eventsCount;
  else if (typeof a == "function" ? a = s[e] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), i = s0(t), i > 0 && a.length > i && !a.warned) {
    a.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = t, o.type = e, o.count = a.length, E1(o);
  }
  return t;
}
Dt.prototype.addListener = function(e, r) {
  return o0(this, e, r, !1);
};
Dt.prototype.on = Dt.prototype.addListener;
Dt.prototype.prependListener = function(e, r) {
  return o0(this, e, r, !0);
};
function S1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function a0(t, e, r) {
  var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = S1.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
Dt.prototype.once = function(e, r) {
  return sl(r), this.on(e, a0(this, e, r)), this;
};
Dt.prototype.prependOnceListener = function(e, r) {
  return sl(r), this.prependListener(e, a0(this, e, r)), this;
};
Dt.prototype.removeListener = function(e, r) {
  var n, i, s, a, o;
  if (sl(r), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, a = n.length - 1; a >= 0; a--)
      if (n[a] === r || n[a].listener === r) {
        o = n[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : O1(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, o || r);
  }
  return this;
};
Dt.prototype.off = Dt.prototype.removeListener;
Dt.prototype.removeAllListeners = function(e) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), a;
    for (i = 0; i < s.length; ++i)
      a = s[i], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[e], typeof r == "function")
    this.removeListener(e, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(e, r[i]);
  return this;
};
function c0(t, e, r) {
  var n = t._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? I1(i) : l0(i, i.length);
}
Dt.prototype.listeners = function(e) {
  return c0(this, e, !0);
};
Dt.prototype.rawListeners = function(e) {
  return c0(this, e, !1);
};
Dt.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : u0.call(t, e);
};
Dt.prototype.listenerCount = u0;
function u0(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Dt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ru(this._events) : [];
};
function l0(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n)
    r[n] = t[n];
  return r;
}
function O1(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function I1(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function x1(t, e) {
  return new Promise(function(r, n) {
    function i(a) {
      t.removeListener(e, s), n(a);
    }
    function s() {
      typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments));
    }
    h0(t, e, s, { once: !0 }), e !== "error" && C1(t, i, { once: !0 });
  });
}
function C1(t, e, r) {
  typeof t.on == "function" && h0(t, "error", e, r);
}
function h0(t, e, r, n) {
  if (typeof t.on == "function")
    n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(s) {
      n.once && t.removeEventListener(e, i), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var wn = Uf.exports;
const fc = /* @__PURE__ */ dc(wn), D1 = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, T1 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, P1 = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function R1(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    N1(t);
    return;
  }
  return e;
}
function N1(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function $c(t, e = {}) {
  if (typeof t != "string")
    return t;
  const r = t.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t[0] === '"' && t.at(-1) === '"' && !t.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const n = r.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!P1.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (D1.test(t) || T1.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, R1);
    }
    return JSON.parse(t);
  } catch (n) {
    if (e.strict)
      throw n;
    return t;
  }
}
function A1(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function ir(t, ...e) {
  try {
    return A1(t(...e));
  } catch (r) {
    return Promise.reject(r);
  }
}
function L1(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function M1(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function nu(t) {
  if (L1(t))
    return String(t);
  if (M1(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return nu(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function d0() {
  if (typeof Buffer === void 0)
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const cd = "base64:";
function j1(t) {
  if (typeof t == "string")
    return t;
  d0();
  const e = Buffer.from(t).toString("base64");
  return cd + e;
}
function k1(t) {
  return typeof t != "string" || !t.startsWith(cd) ? t : (d0(), Buffer.from(t.slice(cd.length), "base64"));
}
function Xr(t) {
  return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function U1(...t) {
  return Xr(t.join(":"));
}
function Fc(t) {
  return t = Xr(t), t ? t + ":" : "";
}
const $1 = "memory", F1 = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: $1,
    options: {},
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, r) {
      t.set(e, r);
    },
    setItemRaw(e, r) {
      t.set(e, r);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return Array.from(t.keys());
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function q1(t = {}) {
  const e = {
    mounts: { "": t.driver || F1() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (u) => {
    for (const h of e.mountpoints)
      if (u.startsWith(h))
        return {
          base: h,
          relativeKey: u.slice(h.length),
          driver: e.mounts[h]
        };
    return {
      base: "",
      relativeKey: u,
      driver: e.mounts[""]
    };
  }, n = (u, h) => e.mountpoints.filter(
    (f) => f.startsWith(u) || h && u.startsWith(f)
  ).map((f) => ({
    relativeBase: u.length > f.length ? u.slice(f.length) : void 0,
    mountpoint: f,
    driver: e.mounts[f]
  })), i = (u, h) => {
    if (e.watching) {
      h = Xr(h);
      for (const f of e.watchListeners)
        f(u, h);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const u in e.mounts)
        e.unwatch[u] = await Qp(
          e.mounts[u],
          i,
          u
        );
    }
  }, a = async () => {
    if (e.watching) {
      for (const u in e.unwatch)
        await e.unwatch[u]();
      e.unwatch = {}, e.watching = !1;
    }
  }, o = (u, h, f) => {
    const g = /* @__PURE__ */ new Map(), m = (w) => {
      let S = g.get(w.base);
      return S || (S = {
        driver: w.driver,
        base: w.base,
        items: []
      }, g.set(w.base, S)), S;
    };
    for (const w of u) {
      const S = typeof w == "string", x = Xr(S ? w : w.key), M = S ? void 0 : w.value, _ = S || !w.options ? h : { ...h, ...w.options }, I = r(x);
      m(I).items.push({
        key: x,
        value: M,
        relativeKey: I.relativeKey,
        options: _
      });
    }
    return Promise.all([...g.values()].map((w) => f(w))).then(
      (w) => w.flat()
    );
  }, l = {
    // Item
    hasItem(u, h = {}) {
      u = Xr(u);
      const { relativeKey: f, driver: g } = r(u);
      return ir(g.hasItem, f, h);
    },
    getItem(u, h = {}) {
      u = Xr(u);
      const { relativeKey: f, driver: g } = r(u);
      return ir(g.getItem, f, h).then(
        (m) => $c(m)
      );
    },
    getItems(u, h) {
      return o(u, h, (f) => f.driver.getItems ? ir(
        f.driver.getItems,
        f.items.map((g) => ({
          key: g.relativeKey,
          options: g.options
        })),
        h
      ).then(
        (g) => g.map((m) => ({
          key: U1(f.base, m.key),
          value: $c(m.value)
        }))
      ) : Promise.all(
        f.items.map((g) => ir(
          f.driver.getItem,
          g.relativeKey,
          g.options
        ).then((m) => ({
          key: g.key,
          value: $c(m)
        })))
      ));
    },
    getItemRaw(u, h = {}) {
      u = Xr(u);
      const { relativeKey: f, driver: g } = r(u);
      return g.getItemRaw ? ir(g.getItemRaw, f, h) : ir(g.getItem, f, h).then(
        (m) => k1(m)
      );
    },
    async setItem(u, h, f = {}) {
      if (h === void 0)
        return l.removeItem(u);
      u = Xr(u);
      const { relativeKey: g, driver: m } = r(u);
      m.setItem && (await ir(m.setItem, g, nu(h), f), m.watch || i("update", u));
    },
    async setItems(u, h) {
      await o(u, h, async (f) => {
        f.driver.setItems && await ir(
          f.driver.setItems,
          f.items.map((g) => ({
            key: g.relativeKey,
            value: nu(g.value),
            options: g.options
          })),
          h
        ), f.driver.setItem && await Promise.all(
          f.items.map((g) => ir(
            f.driver.setItem,
            g.relativeKey,
            nu(g.value),
            g.options
          ))
        );
      });
    },
    async setItemRaw(u, h, f = {}) {
      if (h === void 0)
        return l.removeItem(u, f);
      u = Xr(u);
      const { relativeKey: g, driver: m } = r(u);
      if (m.setItemRaw)
        await ir(m.setItemRaw, g, h, f);
      else if (m.setItem)
        await ir(m.setItem, g, j1(h), f);
      else
        return;
      m.watch || i("update", u);
    },
    async removeItem(u, h = {}) {
      typeof h == "boolean" && (h = { removeMeta: h }), u = Xr(u);
      const { relativeKey: f, driver: g } = r(u);
      g.removeItem && (await ir(g.removeItem, f, h), (h.removeMeta || h.removeMata) && await ir(g.removeItem, f + "$", h), g.watch || i("remove", u));
    },
    // Meta
    async getMeta(u, h = {}) {
      typeof h == "boolean" && (h = { nativeOnly: h }), u = Xr(u);
      const { relativeKey: f, driver: g } = r(u), m = /* @__PURE__ */ Object.create(null);
      if (g.getMeta && Object.assign(m, await ir(g.getMeta, f, h)), !h.nativeOnly) {
        const w = await ir(
          g.getItem,
          f + "$",
          h
        ).then((S) => $c(S));
        w && typeof w == "object" && (typeof w.atime == "string" && (w.atime = new Date(w.atime)), typeof w.mtime == "string" && (w.mtime = new Date(w.mtime)), Object.assign(m, w));
      }
      return m;
    },
    setMeta(u, h, f = {}) {
      return this.setItem(u + "$", h, f);
    },
    removeMeta(u, h = {}) {
      return this.removeItem(u + "$", h);
    },
    // Keys
    async getKeys(u, h = {}) {
      u = Fc(u);
      const f = n(u, !0);
      let g = [];
      const m = [];
      for (const w of f) {
        const x = (await ir(
          w.driver.getKeys,
          w.relativeBase,
          h
        )).map((M) => w.mountpoint + Xr(M)).filter((M) => !g.some((_) => M.startsWith(_)));
        m.push(...x), g = [
          w.mountpoint,
          ...g.filter((M) => !M.startsWith(w.mountpoint))
        ];
      }
      return u ? m.filter((w) => w.startsWith(u) && !w.endsWith("$")) : m.filter((w) => !w.endsWith("$"));
    },
    // Utils
    async clear(u, h = {}) {
      u = Fc(u), await Promise.all(
        n(u, !1).map(async (f) => {
          if (f.driver.clear)
            return ir(f.driver.clear, f.relativeBase, h);
          if (f.driver.removeItem) {
            const g = await f.driver.getKeys(f.relativeBase || "", h);
            return Promise.all(
              g.map((m) => f.driver.removeItem(m, h))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((u) => Jp(u))
      );
    },
    async watch(u) {
      return await s(), e.watchListeners.push(u), async () => {
        e.watchListeners = e.watchListeners.filter(
          (h) => h !== u
        ), e.watchListeners.length === 0 && await a();
      };
    },
    async unwatch() {
      e.watchListeners = [], await a();
    },
    // Mount
    mount(u, h) {
      if (u = Fc(u), u && e.mounts[u])
        throw new Error(`already mounted at ${u}`);
      return u && (e.mountpoints.push(u), e.mountpoints.sort((f, g) => g.length - f.length)), e.mounts[u] = h, e.watching && Promise.resolve(Qp(h, i, u)).then((f) => {
        e.unwatch[u] = f;
      }).catch(console.error), l;
    },
    async unmount(u, h = !0) {
      u = Fc(u), !(!u || !e.mounts[u]) && (e.watching && u in e.unwatch && (e.unwatch[u](), delete e.unwatch[u]), h && await Jp(e.mounts[u]), e.mountpoints = e.mountpoints.filter((f) => f !== u), delete e.mounts[u]);
    },
    getMount(u = "") {
      u = Xr(u) + ":";
      const h = r(u);
      return {
        driver: h.driver,
        base: h.base
      };
    },
    getMounts(u = "", h = {}) {
      return u = Xr(u), n(u, h.parents).map((g) => ({
        driver: g.driver,
        base: g.mountpoint
      }));
    }
  };
  return l;
}
function Qp(t, e, r) {
  return t.watch ? t.watch((n, i) => e(n, r + i)) : () => {
  };
}
async function Jp(t) {
  typeof t.dispose == "function" && await ir(t.dispose);
}
function Rs(t) {
  return new Promise((e, r) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error);
  });
}
function f0(t, e) {
  const r = indexedDB.open(t);
  r.onupgradeneeded = () => r.result.createObjectStore(e);
  const n = Rs(r);
  return (i, s) => n.then((a) => s(a.transaction(e, i).objectStore(e)));
}
let yh;
function pc() {
  return yh || (yh = f0("keyval-store", "keyval")), yh;
}
function Xp(t, e = pc()) {
  return e("readonly", (r) => Rs(r.get(t)));
}
function z1(t, e, r = pc()) {
  return r("readwrite", (n) => (n.put(e, t), Rs(n.transaction)));
}
function V1(t, e = pc()) {
  return e("readwrite", (r) => (r.delete(t), Rs(r.transaction)));
}
function K1(t = pc()) {
  return t("readwrite", (e) => (e.clear(), Rs(e.transaction)));
}
function B1(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, Rs(t.transaction);
}
function H1(t = pc()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return Rs(e.getAllKeys());
    const r = [];
    return B1(e, (n) => r.push(n.key)).then(() => r);
  });
}
const W1 = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), G1 = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function ol(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return G1(t);
  } catch {
    return t;
  }
}
function gc(t) {
  return typeof t == "string" ? t : W1(t) || "";
}
const Z1 = "idb-keyval";
var Y1 = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", r = (i) => e + i;
  let n;
  return t.dbName && t.storeName && (n = f0(t.dbName, t.storeName)), { name: Z1, options: t, async hasItem(i) {
    return !(typeof await Xp(r(i), n) > "u");
  }, async getItem(i) {
    return await Xp(r(i), n) ?? null;
  }, setItem(i, s) {
    return z1(r(i), s, n);
  }, removeItem(i) {
    return V1(r(i), n);
  }, getKeys() {
    return H1(n);
  }, clear() {
    return K1(n);
  } };
};
const Q1 = "WALLET_CONNECT_V2_INDEXED_DB", J1 = "keyvaluestorage";
let X1 = class {
  constructor() {
    this.indexedDb = q1({ driver: Y1({ dbName: Q1, storeName: J1 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const r = await this.indexedDb.getItem(e);
    if (r !== null)
      return r;
  }
  async setItem(e, r) {
    await this.indexedDb.setItem(e, gc(r));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var mh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, iu = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, t.prototype.setItem = function(r, n) {
    this[r] = String(n);
  }, t.prototype.removeItem = function(r) {
    delete this[r];
  }, t.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(n) {
      r[n] = void 0, delete r[n];
    });
  }, t.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof mh < "u" && mh.localStorage ? iu.exports = mh.localStorage : typeof window < "u" && window.localStorage ? iu.exports = window.localStorage : iu.exports = new e();
})();
function eE(t) {
  var e;
  return [t[0], ol((e = t[1]) != null ? e : "")];
}
class tE {
  constructor() {
    this.localStorage = iu.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(eE);
  }
  async getItem(e) {
    const r = this.localStorage.getItem(e);
    if (r !== null)
      return ol(r);
  }
  async setItem(e, r) {
    this.localStorage.setItem(e, gc(r));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
}
const rE = "wc_storage_version", eg = 1, nE = async (t, e, r) => {
  const n = rE, i = await e.getItem(n);
  if (i && i >= eg) {
    r(e);
    return;
  }
  const s = await t.getKeys();
  if (!s.length) {
    r(e);
    return;
  }
  const a = [];
  for (; s.length; ) {
    const o = s.shift();
    if (!o)
      continue;
    const l = o.toLowerCase();
    if (l.includes("wc@") || l.includes("walletconnect") || l.includes("wc_") || l.includes("wallet_connect")) {
      const u = await t.getItem(o);
      await e.setItem(o, u), a.push(o);
    }
  }
  await e.setItem(n, eg), r(e), iE(t, a);
}, iE = async (t, e) => {
  e.length && e.forEach(async (r) => {
    await t.removeItem(r);
  });
};
let sE = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (r) => {
      this.storage = r, this.initialized = !0;
    };
    const e = new tE();
    this.storage = e;
    try {
      const r = new X1();
      nE(e, r, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, r) {
    return await this.initialize(), this.storage.setItem(e, r);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const r = setInterval(() => {
        this.initialized && (clearInterval(r), e());
      }, 20);
    });
  }
};
var To = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ud = function(t, e) {
  return ud = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n)
      n.hasOwnProperty(i) && (r[i] = n[i]);
  }, ud(t, e);
};
function oE(t, e) {
  ud(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var ld = function() {
  return ld = Object.assign || function(e) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, ld.apply(this, arguments);
};
function aE(t, e) {
  var r = {};
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function cE(t, e, r, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, r, n);
  else
    for (var o = t.length - 1; o >= 0; o--)
      (a = t[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, r, s) : a(e, r)) || s);
  return i > 3 && s && Object.defineProperty(e, r, s), s;
}
function uE(t, e) {
  return function(r, n) {
    e(r, n, t);
  };
}
function lE(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function hE(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(a) {
      a(s);
    });
  }
  return new (r || (r = Promise))(function(s, a) {
    function o(h) {
      try {
        u(n.next(h));
      } catch (f) {
        a(f);
      }
    }
    function l(h) {
      try {
        u(n.throw(h));
      } catch (f) {
        a(f);
      }
    }
    function u(h) {
      h.done ? s(h.value) : i(h.value).then(o, l);
    }
    u((n = n.apply(t, e || [])).next());
  });
}
function dE(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(u) {
    return function(h) {
      return l([u, h]);
    };
  }
  function l(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done)
          return s;
        switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: !1 };
          case 5:
            r.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < s[1]) {
              r.label = s[1], s = u;
              break;
            }
            if (s && r.label < s[2]) {
              r.label = s[2], r.ops.push(u);
              break;
            }
            s[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (h) {
        u = [6, h], i = 0;
      } finally {
        n = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function fE(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}
function pE(t, e) {
  for (var r in t)
    r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function hd(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function p0(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}
function gE() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(p0(arguments[e]));
  return t;
}
function yE() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++)
    t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var s = arguments[e], a = 0, o = s.length; a < o; a++, i++)
      n[i] = s[a];
  return n;
}
function xa(t) {
  return this instanceof xa ? (this.v = t, this) : new xa(t);
}
function mE(t, e, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), i, s = [];
  return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function a(g) {
    n[g] && (i[g] = function(m) {
      return new Promise(function(w, S) {
        s.push([g, m, w, S]) > 1 || o(g, m);
      });
    });
  }
  function o(g, m) {
    try {
      l(n[g](m));
    } catch (w) {
      f(s[0][3], w);
    }
  }
  function l(g) {
    g.value instanceof xa ? Promise.resolve(g.value.v).then(u, h) : f(s[0][2], g);
  }
  function u(g) {
    o("next", g);
  }
  function h(g) {
    o("throw", g);
  }
  function f(g, m) {
    g(m), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function vE(t) {
  var e, r;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = t[i] ? function(a) {
      return (r = !r) ? { value: xa(t[i](a)), done: i === "return" } : s ? s(a) : a;
    } : s;
  }
}
function bE(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof hd == "function" ? hd(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(s) {
    r[s] = t[s] && function(a) {
      return new Promise(function(o, l) {
        a = t[s](a), i(o, l, a.done, a.value);
      });
    };
  }
  function i(s, a, o, l) {
    Promise.resolve(l).then(function(u) {
      s({ value: u, done: o });
    }, a);
  }
}
function wE(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function _E(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function EE(t) {
  return t && t.__esModule ? t : { default: t };
}
function SE(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function OE(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const IE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return ld;
  },
  __asyncDelegator: vE,
  __asyncGenerator: mE,
  __asyncValues: bE,
  __await: xa,
  __awaiter: hE,
  __classPrivateFieldGet: SE,
  __classPrivateFieldSet: OE,
  __createBinding: fE,
  __decorate: cE,
  __exportStar: pE,
  __extends: oE,
  __generator: dE,
  __importDefault: EE,
  __importStar: _E,
  __makeTemplateObject: wE,
  __metadata: lE,
  __param: uE,
  __read: p0,
  __rest: aE,
  __spread: gE,
  __spreadArrays: yE,
  __values: hd
}, Symbol.toStringTag, { value: "Module" })), ni = /* @__PURE__ */ il(IE);
var Xo = {}, Ne = {}, vh = {}, ea = {}, tg;
function xE() {
  if (tg)
    return ea;
  tg = 1, Object.defineProperty(ea, "__esModule", { value: !0 }), ea.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return ea.delay = t, ea;
}
var ns = {}, bh = {}, is = {}, rg;
function CE() {
  return rg || (rg = 1, Object.defineProperty(is, "__esModule", { value: !0 }), is.ONE_THOUSAND = is.ONE_HUNDRED = void 0, is.ONE_HUNDRED = 100, is.ONE_THOUSAND = 1e3), is;
}
var wh = {}, ng;
function DE() {
  return ng || (ng = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(wh)), wh;
}
var ig;
function g0() {
  return ig || (ig = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = ni;
    e.__exportStar(CE(), t), e.__exportStar(DE(), t);
  }(bh)), bh;
}
var sg;
function TE() {
  if (sg)
    return ns;
  sg = 1, Object.defineProperty(ns, "__esModule", { value: !0 }), ns.fromMiliseconds = ns.toMiliseconds = void 0;
  const t = g0();
  function e(n) {
    return n * t.ONE_THOUSAND;
  }
  ns.toMiliseconds = e;
  function r(n) {
    return Math.floor(n / t.ONE_THOUSAND);
  }
  return ns.fromMiliseconds = r, ns;
}
var og;
function PE() {
  return og || (og = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = ni;
    e.__exportStar(xE(), t), e.__exportStar(TE(), t);
  }(vh)), vh;
}
var zs = {}, ag;
function RE() {
  if (ag)
    return zs;
  ag = 1, Object.defineProperty(zs, "__esModule", { value: !0 }), zs.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const n = this.get(r);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const i = Date.now() - n.started;
      this.timestamps.set(r, { started: n.started, elapsed: i });
    }
    get(r) {
      const n = this.timestamps.get(r);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return n;
    }
    elapsed(r) {
      const n = this.get(r);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return zs.Watch = t, zs.default = t, zs;
}
var _h = {}, ta = {}, cg;
function NE() {
  if (cg)
    return ta;
  cg = 1, Object.defineProperty(ta, "__esModule", { value: !0 }), ta.IWatch = void 0;
  class t {
  }
  return ta.IWatch = t, ta;
}
var ug;
function AE() {
  return ug || (ug = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), ni.__exportStar(NE(), t);
  }(_h)), _h;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = ni;
  e.__exportStar(PE(), t), e.__exportStar(RE(), t), e.__exportStar(AE(), t), e.__exportStar(g0(), t);
})(Ne);
var Eh = {}, ra = {};
let Ns = class {
};
const LE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: Ns
}, Symbol.toStringTag, { value: "Module" })), ME = /* @__PURE__ */ il(LE);
var lg;
function jE() {
  if (lg)
    return ra;
  lg = 1, Object.defineProperty(ra, "__esModule", { value: !0 }), ra.IHeartBeat = void 0;
  const t = ME;
  class e extends t.IEvents {
    constructor(n) {
      super();
    }
  }
  return ra.IHeartBeat = e, ra;
}
var hg;
function y0() {
  return hg || (hg = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), ni.__exportStar(jE(), t);
  }(Eh)), Eh;
}
var Sh = {}, ss = {}, dg;
function kE() {
  if (dg)
    return ss;
  dg = 1, Object.defineProperty(ss, "__esModule", { value: !0 }), ss.HEARTBEAT_EVENTS = ss.HEARTBEAT_INTERVAL = void 0;
  const t = Ne;
  return ss.HEARTBEAT_INTERVAL = t.FIVE_SECONDS, ss.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, ss;
}
var fg;
function m0() {
  return fg || (fg = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), ni.__exportStar(kE(), t);
  }(Sh)), Sh;
}
var pg;
function UE() {
  if (pg)
    return Xo;
  pg = 1, Object.defineProperty(Xo, "__esModule", { value: !0 }), Xo.HeartBeat = void 0;
  const t = ni, e = wn, r = Ne, n = y0(), i = m0();
  class s extends n.IHeartBeat {
    constructor(o) {
      super(o), this.events = new e.EventEmitter(), this.interval = i.HEARTBEAT_INTERVAL, this.interval = (o == null ? void 0 : o.interval) || i.HEARTBEAT_INTERVAL;
    }
    static init(o) {
      return t.__awaiter(this, void 0, void 0, function* () {
        const l = new s(o);
        return yield l.init(), l;
      });
    }
    init() {
      return t.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(o, l) {
      this.events.on(o, l);
    }
    once(o, l) {
      this.events.once(o, l);
    }
    off(o, l) {
      this.events.off(o, l);
    }
    removeListener(o, l) {
      this.events.removeListener(o, l);
    }
    initialize() {
      return t.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), r.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(i.HEARTBEAT_EVENTS.pulse);
    }
  }
  return Xo.HeartBeat = s, Xo;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = ni;
  e.__exportStar(UE(), t), e.__exportStar(y0(), t), e.__exportStar(m0(), t);
})(To);
var bt = {}, Oh, gg;
function $E() {
  if (gg)
    return Oh;
  gg = 1;
  function t(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
  Oh = e;
  function e(r, n, i) {
    var s = i && i.stringify || t, a = 1;
    if (typeof r == "object" && r !== null) {
      var o = n.length + a;
      if (o === 1)
        return r;
      var l = new Array(o);
      l[0] = s(r);
      for (var u = 1; u < o; u++)
        l[u] = s(n[u]);
      return l.join(" ");
    }
    if (typeof r != "string")
      return r;
    var h = n.length;
    if (h === 0)
      return r;
    for (var f = "", g = 1 - a, m = -1, w = r && r.length || 0, S = 0; S < w; ) {
      if (r.charCodeAt(S) === 37 && S + 1 < w) {
        switch (m = m > -1 ? m : 0, r.charCodeAt(S + 1)) {
          case 100:
          case 102:
            if (g >= h || n[g] == null)
              break;
            m < S && (f += r.slice(m, S)), f += Number(n[g]), m = S + 2, S++;
            break;
          case 105:
            if (g >= h || n[g] == null)
              break;
            m < S && (f += r.slice(m, S)), f += Math.floor(Number(n[g])), m = S + 2, S++;
            break;
          case 79:
          case 111:
          case 106:
            if (g >= h || n[g] === void 0)
              break;
            m < S && (f += r.slice(m, S));
            var x = typeof n[g];
            if (x === "string") {
              f += "'" + n[g] + "'", m = S + 2, S++;
              break;
            }
            if (x === "function") {
              f += n[g].name || "<anonymous>", m = S + 2, S++;
              break;
            }
            f += s(n[g]), m = S + 2, S++;
            break;
          case 115:
            if (g >= h)
              break;
            m < S && (f += r.slice(m, S)), f += String(n[g]), m = S + 2, S++;
            break;
          case 37:
            m < S && (f += r.slice(m, S)), f += "%", m = S + 2, S++, g--;
            break;
        }
        ++g;
      }
      ++S;
    }
    return m === -1 ? r : (m < w && (f += r.slice(m)), f);
  }
  return Oh;
}
var Ih, yg;
function FE() {
  if (yg)
    return Ih;
  yg = 1;
  const t = $E();
  Ih = i;
  const e = E().console || {}, r = {
    mapHttpRequest: w,
    mapHttpResponse: w,
    wrapRequestSerializer: S,
    wrapResponseSerializer: S,
    wrapErrorSerializer: S,
    req: w,
    res: w,
    err: g
  };
  function n(y, c) {
    return Array.isArray(y) ? y.filter(function(D) {
      return D !== "!stdSerializers.err";
    }) : y === !0 ? Object.keys(c) : !1;
  }
  function i(y) {
    y = y || {}, y.browser = y.browser || {};
    const c = y.browser.transmit;
    if (c && typeof c.send != "function")
      throw Error("pino: transmit option must have a send function");
    const p = y.browser.write || e;
    y.browser.write && (y.browser.asObject = !0);
    const D = y.serializers || {}, R = n(y.browser.serialize, D);
    let k = y.browser.serialize;
    Array.isArray(y.browser.serialize) && y.browser.serialize.indexOf("!stdSerializers.err") > -1 && (k = !1);
    const B = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof p == "function" && (p.error = p.fatal = p.warn = p.info = p.debug = p.trace = p), y.enabled === !1 && (y.level = "silent");
    const W = y.level || "info", C = Object.create(p);
    C.log || (C.log = x), Object.defineProperty(C, "levelVal", {
      get: G
    }), Object.defineProperty(C, "level", {
      get: z,
      set: $
    });
    const N = {
      transmit: c,
      serialize: R,
      asObject: y.browser.asObject,
      levels: B,
      timestamp: m(y)
    };
    C.levels = i.levels, C.level = W, C.setMaxListeners = C.getMaxListeners = C.emit = C.addListener = C.on = C.prependListener = C.once = C.prependOnceListener = C.removeListener = C.removeAllListeners = C.listeners = C.listenerCount = C.eventNames = C.write = C.flush = x, C.serializers = D, C._serialize = R, C._stdErrSerialize = k, C.child = q, c && (C._logEvent = f());
    function G() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function z() {
      return this._level;
    }
    function $(U) {
      if (U !== "silent" && !this.levels.values[U])
        throw Error("unknown level " + U);
      this._level = U, s(N, C, "error", "log"), s(N, C, "fatal", "error"), s(N, C, "warn", "error"), s(N, C, "info", "log"), s(N, C, "debug", "log"), s(N, C, "trace", "log");
    }
    function q(U, V) {
      if (!U)
        throw new Error("missing bindings for child Pino");
      V = V || {}, R && U.serializers && (V.serializers = U.serializers);
      const re = V.serializers;
      if (R && re) {
        var K = Object.assign({}, D, re), X = y.browser.serialize === !0 ? Object.keys(K) : R;
        delete U.serializers, l([U], X, K, this._stdErrSerialize);
      }
      function Y(ee) {
        this._childLevel = (ee._childLevel | 0) + 1, this.error = u(ee, U, "error"), this.fatal = u(ee, U, "fatal"), this.warn = u(ee, U, "warn"), this.info = u(ee, U, "info"), this.debug = u(ee, U, "debug"), this.trace = u(ee, U, "trace"), K && (this.serializers = K, this._serialize = X), c && (this._logEvent = f(
          [].concat(ee._logEvent.bindings, U)
        ));
      }
      return Y.prototype = this, new Y(this);
    }
    return C;
  }
  i.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, i.stdSerializers = r, i.stdTimeFunctions = Object.assign({}, { nullTime: M, epochTime: _, unixTime: I, isoTime: b });
  function s(y, c, p, D) {
    const R = Object.getPrototypeOf(c);
    c[p] = c.levelVal > c.levels.values[p] ? x : R[p] ? R[p] : e[p] || e[D] || x, a(y, c, p);
  }
  function a(y, c, p) {
    !y.transmit && c[p] === x || (c[p] = /* @__PURE__ */ function(D) {
      return function() {
        const k = y.timestamp(), B = new Array(arguments.length), W = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
        for (var C = 0; C < B.length; C++)
          B[C] = arguments[C];
        if (y.serialize && !y.asObject && l(B, this._serialize, this.serializers, this._stdErrSerialize), y.asObject ? D.call(W, o(this, p, B, k)) : D.apply(W, B), y.transmit) {
          const N = y.transmit.level || c.level, G = i.levels.values[N], z = i.levels.values[p];
          if (z < G)
            return;
          h(this, {
            ts: k,
            methodLevel: p,
            methodValue: z,
            transmitLevel: N,
            transmitValue: i.levels.values[y.transmit.level || c.level],
            send: y.transmit.send,
            val: c.levelVal
          }, B);
        }
      };
    }(c[p]));
  }
  function o(y, c, p, D) {
    y._serialize && l(p, y._serialize, y.serializers, y._stdErrSerialize);
    const R = p.slice();
    let k = R[0];
    const B = {};
    D && (B.time = D), B.level = i.levels.values[c];
    let W = (y._childLevel | 0) + 1;
    if (W < 1 && (W = 1), k !== null && typeof k == "object") {
      for (; W-- && typeof R[0] == "object"; )
        Object.assign(B, R.shift());
      k = R.length ? t(R.shift(), R) : void 0;
    } else
      typeof k == "string" && (k = t(R.shift(), R));
    return k !== void 0 && (B.msg = k), B;
  }
  function l(y, c, p, D) {
    for (const R in y)
      if (D && y[R] instanceof Error)
        y[R] = i.stdSerializers.err(y[R]);
      else if (typeof y[R] == "object" && !Array.isArray(y[R]))
        for (const k in y[R])
          c && c.indexOf(k) > -1 && k in p && (y[R][k] = p[k](y[R][k]));
  }
  function u(y, c, p) {
    return function() {
      const D = new Array(1 + arguments.length);
      D[0] = c;
      for (var R = 1; R < D.length; R++)
        D[R] = arguments[R - 1];
      return y[p].apply(this, D);
    };
  }
  function h(y, c, p) {
    const D = c.send, R = c.ts, k = c.methodLevel, B = c.methodValue, W = c.val, C = y._logEvent.bindings;
    l(
      p,
      y._serialize || Object.keys(y.serializers),
      y.serializers,
      y._stdErrSerialize === void 0 ? !0 : y._stdErrSerialize
    ), y._logEvent.ts = R, y._logEvent.messages = p.filter(function(N) {
      return C.indexOf(N) === -1;
    }), y._logEvent.level.label = k, y._logEvent.level.value = B, D(k, y._logEvent, W), y._logEvent = f(C);
  }
  function f(y) {
    return {
      ts: 0,
      messages: [],
      bindings: y || [],
      level: { label: "", value: 0 }
    };
  }
  function g(y) {
    const c = {
      type: y.constructor.name,
      msg: y.message,
      stack: y.stack
    };
    for (const p in y)
      c[p] === void 0 && (c[p] = y[p]);
    return c;
  }
  function m(y) {
    return typeof y.timestamp == "function" ? y.timestamp : y.timestamp === !1 ? M : _;
  }
  function w() {
    return {};
  }
  function S(y) {
    return y;
  }
  function x() {
  }
  function M() {
    return !1;
  }
  function _() {
    return Date.now();
  }
  function I() {
    return Math.round(Date.now() / 1e3);
  }
  function b() {
    return new Date(Date.now()).toISOString();
  }
  function E() {
    function y(c) {
      return typeof c < "u" && c;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return y(self) || y(window) || y(this) || {};
    }
  }
  return Ih;
}
var os = {}, mg;
function v0() {
  return mg || (mg = 1, Object.defineProperty(os, "__esModule", { value: !0 }), os.PINO_CUSTOM_CONTEXT_KEY = os.PINO_LOGGER_DEFAULTS = void 0, os.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, os.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), os;
}
var jr = {}, vg;
function qE() {
  if (vg)
    return jr;
  vg = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.generateChildLogger = jr.formatChildLoggerContext = jr.getLoggerContext = jr.setBrowserLoggerContext = jr.getBrowserLoggerContext = jr.getDefaultLoggerOptions = void 0;
  const t = v0();
  function e(o) {
    return Object.assign(Object.assign({}, o), { level: (o == null ? void 0 : o.level) || t.PINO_LOGGER_DEFAULTS.level });
  }
  jr.getDefaultLoggerOptions = e;
  function r(o, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    return o[l] || "";
  }
  jr.getBrowserLoggerContext = r;
  function n(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    return o[u] = l, o;
  }
  jr.setBrowserLoggerContext = n;
  function i(o, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    let u = "";
    return typeof o.bindings > "u" ? u = r(o, l) : u = o.bindings().context || "", u;
  }
  jr.getLoggerContext = i;
  function s(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    const h = i(o, u);
    return h.trim() ? `${h}/${l}` : l;
  }
  jr.formatChildLoggerContext = s;
  function a(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    const h = s(o, l, u), f = o.child({ context: h });
    return n(f, h, u);
  }
  return jr.generateChildLogger = a, jr;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.pino = void 0;
  const e = ni, r = e.__importDefault(FE());
  Object.defineProperty(t, "pino", { enumerable: !0, get: function() {
    return r.default;
  } }), e.__exportStar(v0(), t), e.__exportStar(qE(), t);
})(bt);
let zE = class extends Ns {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, t9 = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r;
  }
}, VE = class extends Ns {
  constructor(e, r) {
    super(), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, KE = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
}, BE = class extends Ns {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, HE = class extends Ns {
  constructor(e) {
    super();
  }
}, WE = class {
  constructor(e, r, n, i) {
    this.core = e, this.logger = r, this.name = n;
  }
}, c9 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
};
class GE extends Ns {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}
let l9 = class {
  constructor(e, r) {
    this.core = e, this.logger = r;
  }
};
class ZE extends Ns {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}
let d9 = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
}, YE = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}, QE = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
};
class y9 extends fc {
  constructor() {
    super();
  }
}
let JE = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, v9 = class extends wn.EventEmitter {
  constructor() {
    super();
  }
}, XE = class {
  constructor(e) {
    this.client = e;
  }
};
var $f = {}, Po = {}, al = {}, cl = {};
Object.defineProperty(cl, "__esModule", { value: !0 });
cl.BrowserRandomSource = void 0;
const bg = 65536;
class eS {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let n = 0; n < r.length; n += bg)
      this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, bg)));
    return r;
  }
}
cl.BrowserRandomSource = eS;
function tS(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ul = {}, gn = {};
Object.defineProperty(gn, "__esModule", { value: !0 });
function rS(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
gn.wipe = rS;
const nS = {}, iS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: nS
}, Symbol.toStringTag, { value: "Module" })), sS = /* @__PURE__ */ il(iS);
Object.defineProperty(ul, "__esModule", { value: !0 });
ul.NodeRandomSource = void 0;
const oS = gn;
class aS {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof tS < "u") {
      const e = sS;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(e);
    for (let i = 0; i < n.length; i++)
      n[i] = r[i];
    return (0, oS.wipe)(r), n;
  }
}
ul.NodeRandomSource = aS;
Object.defineProperty(al, "__esModule", { value: !0 });
al.SystemRandomSource = void 0;
const cS = cl, uS = ul;
class lS {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new cS.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new uS.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
al.SystemRandomSource = lS;
var rt = {}, b0 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(o, l) {
    var u = o >>> 16 & 65535, h = o & 65535, f = l >>> 16 & 65535, g = l & 65535;
    return h * g + (u * g + h * f << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(o, l) {
    return o + l | 0;
  }
  t.add = r;
  function n(o, l) {
    return o - l | 0;
  }
  t.sub = n;
  function i(o, l) {
    return o << l | o >>> 32 - l;
  }
  t.rotl = i;
  function s(o, l) {
    return o << 32 - l | o >>> l;
  }
  t.rotr = s;
  function a(o) {
    return typeof o == "number" && isFinite(o) && Math.floor(o) === o;
  }
  t.isInteger = Number.isInteger || a, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(o) {
    return t.isInteger(o) && o >= -t.MAX_SAFE_INTEGER && o <= t.MAX_SAFE_INTEGER;
  };
})(b0);
Object.defineProperty(rt, "__esModule", { value: !0 });
var w0 = b0;
function hS(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
rt.readInt16BE = hS;
function dS(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
rt.readUint16BE = dS;
function fS(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
rt.readInt16LE = fS;
function pS(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
rt.readUint16LE = pS;
function _0(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
rt.writeUint16BE = _0;
rt.writeInt16BE = _0;
function E0(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
rt.writeUint16LE = E0;
rt.writeInt16LE = E0;
function dd(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
rt.readInt32BE = dd;
function fd(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
rt.readUint32BE = fd;
function pd(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
rt.readInt32LE = pd;
function gd(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
rt.readUint32LE = gd;
function gu(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
rt.writeUint32BE = gu;
rt.writeInt32BE = gu;
function yu(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
rt.writeUint32LE = yu;
rt.writeInt32LE = yu;
function gS(t, e) {
  e === void 0 && (e = 0);
  var r = dd(t, e), n = dd(t, e + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
rt.readInt64BE = gS;
function yS(t, e) {
  e === void 0 && (e = 0);
  var r = fd(t, e), n = fd(t, e + 4);
  return r * 4294967296 + n;
}
rt.readUint64BE = yS;
function mS(t, e) {
  e === void 0 && (e = 0);
  var r = pd(t, e), n = pd(t, e + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
rt.readInt64LE = mS;
function vS(t, e) {
  e === void 0 && (e = 0);
  var r = gd(t, e), n = gd(t, e + 4);
  return n * 4294967296 + r;
}
rt.readUint64LE = vS;
function S0(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), gu(t / 4294967296 >>> 0, e, r), gu(t >>> 0, e, r + 4), e;
}
rt.writeUint64BE = S0;
rt.writeInt64BE = S0;
function O0(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), yu(t >>> 0, e, r), yu(t / 4294967296 >>> 0, e, r + 4), e;
}
rt.writeUint64LE = O0;
rt.writeInt64LE = O0;
function bS(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = t / 8 + r - 1; s >= r; s--)
    n += e[s] * i, i *= 256;
  return n;
}
rt.readUintBE = bS;
function wS(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = r; s < r + t / 8; s++)
    n += e[s] * i, i *= 256;
  return n;
}
rt.readUintLE = wS;
function _S(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!w0.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = t / 8 + n - 1; s >= n; s--)
    r[s] = e / i & 255, i *= 256;
  return r;
}
rt.writeUintBE = _S;
function ES(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!w0.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = n; s < n + t / 8; s++)
    r[s] = e / i & 255, i *= 256;
  return r;
}
rt.writeUintLE = ES;
function SS(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
rt.readFloat32BE = SS;
function OS(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
rt.readFloat32LE = OS;
function IS(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
rt.readFloat64BE = IS;
function xS(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
rt.readFloat64LE = xS;
function CS(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t), e;
}
rt.writeFloat32BE = CS;
function DS(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t, !0), e;
}
rt.writeFloat32LE = DS;
function TS(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t), e;
}
rt.writeFloat64BE = TS;
function PS(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t, !0), e;
}
rt.writeFloat64LE = PS;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = al, r = rt, n = gn;
  t.defaultRandomSource = new e.SystemRandomSource();
  function i(u, h = t.defaultRandomSource) {
    return h.randomBytes(u);
  }
  t.randomBytes = i;
  function s(u = t.defaultRandomSource) {
    const h = i(4, u), f = (0, r.readUint32LE)(h);
    return (0, n.wipe)(h), f;
  }
  t.randomUint32 = s;
  const a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function o(u, h = a, f = t.defaultRandomSource) {
    if (h.length < 2)
      throw new Error("randomString charset is too short");
    if (h.length > 256)
      throw new Error("randomString charset is too long");
    let g = "";
    const m = h.length, w = 256 - 256 % m;
    for (; u > 0; ) {
      const S = i(Math.ceil(u * 256 / w), f);
      for (let x = 0; x < S.length && u > 0; x++) {
        const M = S[x];
        M < w && (g += h.charAt(M % m), u--);
      }
      (0, n.wipe)(S);
    }
    return g;
  }
  t.randomString = o;
  function l(u, h = a, f = t.defaultRandomSource) {
    const g = Math.ceil(u / (Math.log(h.length) / Math.LN2));
    return o(g, h, f);
  }
  t.randomStringForEntropy = l;
})(Po);
var I0 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = rt, r = gn;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function o() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return o.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, o.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, o.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, o.prototype.update = function(l, u) {
        if (u === void 0 && (u = l.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var h = 0;
        if (this._bytesHashed += u, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && u > 0; )
            this._buffer[this._bufferLength++] = l[h++], u--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (u >= this.blockSize && (h = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, l, h, u), u %= this.blockSize); u > 0; )
          this._buffer[this._bufferLength++] = l[h++], u--;
        return this;
      }, o.prototype.finish = function(l) {
        if (!this._finished) {
          var u = this._bytesHashed, h = this._bufferLength, f = u / 536870912 | 0, g = u << 3, m = u % 128 < 112 ? 128 : 256;
          this._buffer[h] = 128;
          for (var w = h + 1; w < m - 8; w++)
            this._buffer[w] = 0;
          e.writeUint32BE(f, this._buffer, m - 8), e.writeUint32BE(g, this._buffer, m - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, m), this._finished = !0;
        }
        for (var w = 0; w < this.digestLength / 8; w++)
          e.writeUint32BE(this._stateHi[w], l, w * 8), e.writeUint32BE(this._stateLo[w], l, w * 8 + 4);
        return this;
      }, o.prototype.digest = function() {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }, o.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, o.prototype.restoreState = function(l) {
        return this._stateHi.set(l.stateHi), this._stateLo.set(l.stateLo), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this;
      }, o.prototype.cleanSavedState = function(l) {
        r.wipe(l.stateHi), r.wipe(l.stateLo), l.buffer && r.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0;
      }, o;
    }()
  );
  t.SHA512 = n;
  var i = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(o, l, u, h, f, g, m) {
    for (var w = u[0], S = u[1], x = u[2], M = u[3], _ = u[4], I = u[5], b = u[6], E = u[7], y = h[0], c = h[1], p = h[2], D = h[3], R = h[4], k = h[5], B = h[6], W = h[7], C, N, G, z, $, q, U, V; m >= 128; ) {
      for (var re = 0; re < 16; re++) {
        var K = 8 * re + g;
        o[re] = e.readUint32BE(f, K), l[re] = e.readUint32BE(f, K + 4);
      }
      for (var re = 0; re < 80; re++) {
        var X = w, Y = S, ee = x, L = M, A = _, T = I, d = b, O = E, H = y, Z = c, me = p, we = D, ye = R, De = k, He = B, Ue = W;
        if (C = E, N = W, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = (_ >>> 14 | R << 18) ^ (_ >>> 18 | R << 14) ^ (R >>> 9 | _ << 23), N = (R >>> 14 | _ << 18) ^ (R >>> 18 | _ << 14) ^ (_ >>> 9 | R << 23), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = _ & I ^ ~_ & b, N = R & k ^ ~R & B, $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = i[re * 2], N = i[re * 2 + 1], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = o[re % 16], N = l[re % 16], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, G = U & 65535 | V << 16, z = $ & 65535 | q << 16, C = G, N = z, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = (w >>> 28 | y << 4) ^ (y >>> 2 | w << 30) ^ (y >>> 7 | w << 25), N = (y >>> 28 | w << 4) ^ (w >>> 2 | y << 30) ^ (w >>> 7 | y << 25), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = w & S ^ w & x ^ S & x, N = y & c ^ y & p ^ c & p, $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, O = U & 65535 | V << 16, Ue = $ & 65535 | q << 16, C = L, N = we, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = G, N = z, $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, L = U & 65535 | V << 16, we = $ & 65535 | q << 16, S = X, x = Y, M = ee, _ = L, I = A, b = T, E = d, w = O, c = H, p = Z, D = me, R = we, k = ye, B = De, W = He, y = Ue, re % 16 === 15)
          for (var K = 0; K < 16; K++)
            C = o[K], N = l[K], $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = o[(K + 9) % 16], N = l[(K + 9) % 16], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, G = o[(K + 1) % 16], z = l[(K + 1) % 16], C = (G >>> 1 | z << 31) ^ (G >>> 8 | z << 24) ^ G >>> 7, N = (z >>> 1 | G << 31) ^ (z >>> 8 | G << 24) ^ (z >>> 7 | G << 25), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, G = o[(K + 14) % 16], z = l[(K + 14) % 16], C = (G >>> 19 | z << 13) ^ (z >>> 29 | G << 3) ^ G >>> 6, N = (z >>> 19 | G << 13) ^ (G >>> 29 | z << 3) ^ (z >>> 6 | G << 26), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, o[K] = U & 65535 | V << 16, l[K] = $ & 65535 | q << 16;
      }
      C = w, N = y, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[0], N = h[0], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[0] = w = U & 65535 | V << 16, h[0] = y = $ & 65535 | q << 16, C = S, N = c, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[1], N = h[1], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[1] = S = U & 65535 | V << 16, h[1] = c = $ & 65535 | q << 16, C = x, N = p, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[2], N = h[2], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[2] = x = U & 65535 | V << 16, h[2] = p = $ & 65535 | q << 16, C = M, N = D, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[3], N = h[3], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[3] = M = U & 65535 | V << 16, h[3] = D = $ & 65535 | q << 16, C = _, N = R, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[4], N = h[4], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[4] = _ = U & 65535 | V << 16, h[4] = R = $ & 65535 | q << 16, C = I, N = k, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[5], N = h[5], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[5] = I = U & 65535 | V << 16, h[5] = k = $ & 65535 | q << 16, C = b, N = B, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[6], N = h[6], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[6] = b = U & 65535 | V << 16, h[6] = B = $ & 65535 | q << 16, C = E, N = W, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[7], N = h[7], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[7] = E = U & 65535 | V << 16, h[7] = W = $ & 65535 | q << 16, g += 128, m -= 128;
    }
    return g;
  }
  function a(o) {
    var l = new n();
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.hash = a;
})(I0);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = Po, r = I0, n = gn;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function i(L) {
    const A = new Float64Array(16);
    if (L)
      for (let T = 0; T < L.length; T++)
        A[T] = L[T];
    return A;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const a = i(), o = i([1]), l = i([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), u = i([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), h = i([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), f = i([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), g = i([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function m(L, A) {
    for (let T = 0; T < 16; T++)
      L[T] = A[T] | 0;
  }
  function w(L) {
    let A = 1;
    for (let T = 0; T < 16; T++) {
      let d = L[T] + A + 65535;
      A = Math.floor(d / 65536), L[T] = d - A * 65536;
    }
    L[0] += A - 1 + 37 * (A - 1);
  }
  function S(L, A, T) {
    const d = ~(T - 1);
    for (let O = 0; O < 16; O++) {
      const H = d & (L[O] ^ A[O]);
      L[O] ^= H, A[O] ^= H;
    }
  }
  function x(L, A) {
    const T = i(), d = i();
    for (let O = 0; O < 16; O++)
      d[O] = A[O];
    w(d), w(d), w(d);
    for (let O = 0; O < 2; O++) {
      T[0] = d[0] - 65517;
      for (let Z = 1; Z < 15; Z++)
        T[Z] = d[Z] - 65535 - (T[Z - 1] >> 16 & 1), T[Z - 1] &= 65535;
      T[15] = d[15] - 32767 - (T[14] >> 16 & 1);
      const H = T[15] >> 16 & 1;
      T[14] &= 65535, S(d, T, 1 - H);
    }
    for (let O = 0; O < 16; O++)
      L[2 * O] = d[O] & 255, L[2 * O + 1] = d[O] >> 8;
  }
  function M(L, A) {
    let T = 0;
    for (let d = 0; d < 32; d++)
      T |= L[d] ^ A[d];
    return (1 & T - 1 >>> 8) - 1;
  }
  function _(L, A) {
    const T = new Uint8Array(32), d = new Uint8Array(32);
    return x(T, L), x(d, A), M(T, d);
  }
  function I(L) {
    const A = new Uint8Array(32);
    return x(A, L), A[0] & 1;
  }
  function b(L, A) {
    for (let T = 0; T < 16; T++)
      L[T] = A[2 * T] + (A[2 * T + 1] << 8);
    L[15] &= 32767;
  }
  function E(L, A, T) {
    for (let d = 0; d < 16; d++)
      L[d] = A[d] + T[d];
  }
  function y(L, A, T) {
    for (let d = 0; d < 16; d++)
      L[d] = A[d] - T[d];
  }
  function c(L, A, T) {
    let d, O, H = 0, Z = 0, me = 0, we = 0, ye = 0, De = 0, He = 0, Ue = 0, _e = 0, be = 0, de = 0, fe = 0, ue = 0, ae = 0, oe = 0, te = 0, pe = 0, ve = 0, ne = 0, Ee = 0, Ie = 0, Pe = 0, Re = 0, Te = 0, At = 0, Ft = 0, Qt = 0, It = 0, er = 0, tr = 0, an = 0, We = T[0], Fe = T[1], Qe = T[2], Ze = T[3], Je = T[4], qe = T[5], at = T[6], lt = T[7], ht = T[8], ct = T[9], dt = T[10], it = T[11], Xe = T[12], je = T[13], j = T[14], Q = T[15];
    d = A[0], H += d * We, Z += d * Fe, me += d * Qe, we += d * Ze, ye += d * Je, De += d * qe, He += d * at, Ue += d * lt, _e += d * ht, be += d * ct, de += d * dt, fe += d * it, ue += d * Xe, ae += d * je, oe += d * j, te += d * Q, d = A[1], Z += d * We, me += d * Fe, we += d * Qe, ye += d * Ze, De += d * Je, He += d * qe, Ue += d * at, _e += d * lt, be += d * ht, de += d * ct, fe += d * dt, ue += d * it, ae += d * Xe, oe += d * je, te += d * j, pe += d * Q, d = A[2], me += d * We, we += d * Fe, ye += d * Qe, De += d * Ze, He += d * Je, Ue += d * qe, _e += d * at, be += d * lt, de += d * ht, fe += d * ct, ue += d * dt, ae += d * it, oe += d * Xe, te += d * je, pe += d * j, ve += d * Q, d = A[3], we += d * We, ye += d * Fe, De += d * Qe, He += d * Ze, Ue += d * Je, _e += d * qe, be += d * at, de += d * lt, fe += d * ht, ue += d * ct, ae += d * dt, oe += d * it, te += d * Xe, pe += d * je, ve += d * j, ne += d * Q, d = A[4], ye += d * We, De += d * Fe, He += d * Qe, Ue += d * Ze, _e += d * Je, be += d * qe, de += d * at, fe += d * lt, ue += d * ht, ae += d * ct, oe += d * dt, te += d * it, pe += d * Xe, ve += d * je, ne += d * j, Ee += d * Q, d = A[5], De += d * We, He += d * Fe, Ue += d * Qe, _e += d * Ze, be += d * Je, de += d * qe, fe += d * at, ue += d * lt, ae += d * ht, oe += d * ct, te += d * dt, pe += d * it, ve += d * Xe, ne += d * je, Ee += d * j, Ie += d * Q, d = A[6], He += d * We, Ue += d * Fe, _e += d * Qe, be += d * Ze, de += d * Je, fe += d * qe, ue += d * at, ae += d * lt, oe += d * ht, te += d * ct, pe += d * dt, ve += d * it, ne += d * Xe, Ee += d * je, Ie += d * j, Pe += d * Q, d = A[7], Ue += d * We, _e += d * Fe, be += d * Qe, de += d * Ze, fe += d * Je, ue += d * qe, ae += d * at, oe += d * lt, te += d * ht, pe += d * ct, ve += d * dt, ne += d * it, Ee += d * Xe, Ie += d * je, Pe += d * j, Re += d * Q, d = A[8], _e += d * We, be += d * Fe, de += d * Qe, fe += d * Ze, ue += d * Je, ae += d * qe, oe += d * at, te += d * lt, pe += d * ht, ve += d * ct, ne += d * dt, Ee += d * it, Ie += d * Xe, Pe += d * je, Re += d * j, Te += d * Q, d = A[9], be += d * We, de += d * Fe, fe += d * Qe, ue += d * Ze, ae += d * Je, oe += d * qe, te += d * at, pe += d * lt, ve += d * ht, ne += d * ct, Ee += d * dt, Ie += d * it, Pe += d * Xe, Re += d * je, Te += d * j, At += d * Q, d = A[10], de += d * We, fe += d * Fe, ue += d * Qe, ae += d * Ze, oe += d * Je, te += d * qe, pe += d * at, ve += d * lt, ne += d * ht, Ee += d * ct, Ie += d * dt, Pe += d * it, Re += d * Xe, Te += d * je, At += d * j, Ft += d * Q, d = A[11], fe += d * We, ue += d * Fe, ae += d * Qe, oe += d * Ze, te += d * Je, pe += d * qe, ve += d * at, ne += d * lt, Ee += d * ht, Ie += d * ct, Pe += d * dt, Re += d * it, Te += d * Xe, At += d * je, Ft += d * j, Qt += d * Q, d = A[12], ue += d * We, ae += d * Fe, oe += d * Qe, te += d * Ze, pe += d * Je, ve += d * qe, ne += d * at, Ee += d * lt, Ie += d * ht, Pe += d * ct, Re += d * dt, Te += d * it, At += d * Xe, Ft += d * je, Qt += d * j, It += d * Q, d = A[13], ae += d * We, oe += d * Fe, te += d * Qe, pe += d * Ze, ve += d * Je, ne += d * qe, Ee += d * at, Ie += d * lt, Pe += d * ht, Re += d * ct, Te += d * dt, At += d * it, Ft += d * Xe, Qt += d * je, It += d * j, er += d * Q, d = A[14], oe += d * We, te += d * Fe, pe += d * Qe, ve += d * Ze, ne += d * Je, Ee += d * qe, Ie += d * at, Pe += d * lt, Re += d * ht, Te += d * ct, At += d * dt, Ft += d * it, Qt += d * Xe, It += d * je, er += d * j, tr += d * Q, d = A[15], te += d * We, pe += d * Fe, ve += d * Qe, ne += d * Ze, Ee += d * Je, Ie += d * qe, Pe += d * at, Re += d * lt, Te += d * ht, At += d * ct, Ft += d * dt, Qt += d * it, It += d * Xe, er += d * je, tr += d * j, an += d * Q, H += 38 * pe, Z += 38 * ve, me += 38 * ne, we += 38 * Ee, ye += 38 * Ie, De += 38 * Pe, He += 38 * Re, Ue += 38 * Te, _e += 38 * At, be += 38 * Ft, de += 38 * Qt, fe += 38 * It, ue += 38 * er, ae += 38 * tr, oe += 38 * an, O = 1, d = H + O + 65535, O = Math.floor(d / 65536), H = d - O * 65536, d = Z + O + 65535, O = Math.floor(d / 65536), Z = d - O * 65536, d = me + O + 65535, O = Math.floor(d / 65536), me = d - O * 65536, d = we + O + 65535, O = Math.floor(d / 65536), we = d - O * 65536, d = ye + O + 65535, O = Math.floor(d / 65536), ye = d - O * 65536, d = De + O + 65535, O = Math.floor(d / 65536), De = d - O * 65536, d = He + O + 65535, O = Math.floor(d / 65536), He = d - O * 65536, d = Ue + O + 65535, O = Math.floor(d / 65536), Ue = d - O * 65536, d = _e + O + 65535, O = Math.floor(d / 65536), _e = d - O * 65536, d = be + O + 65535, O = Math.floor(d / 65536), be = d - O * 65536, d = de + O + 65535, O = Math.floor(d / 65536), de = d - O * 65536, d = fe + O + 65535, O = Math.floor(d / 65536), fe = d - O * 65536, d = ue + O + 65535, O = Math.floor(d / 65536), ue = d - O * 65536, d = ae + O + 65535, O = Math.floor(d / 65536), ae = d - O * 65536, d = oe + O + 65535, O = Math.floor(d / 65536), oe = d - O * 65536, d = te + O + 65535, O = Math.floor(d / 65536), te = d - O * 65536, H += O - 1 + 37 * (O - 1), O = 1, d = H + O + 65535, O = Math.floor(d / 65536), H = d - O * 65536, d = Z + O + 65535, O = Math.floor(d / 65536), Z = d - O * 65536, d = me + O + 65535, O = Math.floor(d / 65536), me = d - O * 65536, d = we + O + 65535, O = Math.floor(d / 65536), we = d - O * 65536, d = ye + O + 65535, O = Math.floor(d / 65536), ye = d - O * 65536, d = De + O + 65535, O = Math.floor(d / 65536), De = d - O * 65536, d = He + O + 65535, O = Math.floor(d / 65536), He = d - O * 65536, d = Ue + O + 65535, O = Math.floor(d / 65536), Ue = d - O * 65536, d = _e + O + 65535, O = Math.floor(d / 65536), _e = d - O * 65536, d = be + O + 65535, O = Math.floor(d / 65536), be = d - O * 65536, d = de + O + 65535, O = Math.floor(d / 65536), de = d - O * 65536, d = fe + O + 65535, O = Math.floor(d / 65536), fe = d - O * 65536, d = ue + O + 65535, O = Math.floor(d / 65536), ue = d - O * 65536, d = ae + O + 65535, O = Math.floor(d / 65536), ae = d - O * 65536, d = oe + O + 65535, O = Math.floor(d / 65536), oe = d - O * 65536, d = te + O + 65535, O = Math.floor(d / 65536), te = d - O * 65536, H += O - 1 + 37 * (O - 1), L[0] = H, L[1] = Z, L[2] = me, L[3] = we, L[4] = ye, L[5] = De, L[6] = He, L[7] = Ue, L[8] = _e, L[9] = be, L[10] = de, L[11] = fe, L[12] = ue, L[13] = ae, L[14] = oe, L[15] = te;
  }
  function p(L, A) {
    c(L, A, A);
  }
  function D(L, A) {
    const T = i();
    let d;
    for (d = 0; d < 16; d++)
      T[d] = A[d];
    for (d = 253; d >= 0; d--)
      p(T, T), d !== 2 && d !== 4 && c(T, T, A);
    for (d = 0; d < 16; d++)
      L[d] = T[d];
  }
  function R(L, A) {
    const T = i();
    let d;
    for (d = 0; d < 16; d++)
      T[d] = A[d];
    for (d = 250; d >= 0; d--)
      p(T, T), d !== 1 && c(T, T, A);
    for (d = 0; d < 16; d++)
      L[d] = T[d];
  }
  function k(L, A) {
    const T = i(), d = i(), O = i(), H = i(), Z = i(), me = i(), we = i(), ye = i(), De = i();
    y(T, L[1], L[0]), y(De, A[1], A[0]), c(T, T, De), E(d, L[0], L[1]), E(De, A[0], A[1]), c(d, d, De), c(O, L[3], A[3]), c(O, O, u), c(H, L[2], A[2]), E(H, H, H), y(Z, d, T), y(me, H, O), E(we, H, O), E(ye, d, T), c(L[0], Z, me), c(L[1], ye, we), c(L[2], we, me), c(L[3], Z, ye);
  }
  function B(L, A, T) {
    for (let d = 0; d < 4; d++)
      S(L[d], A[d], T);
  }
  function W(L, A) {
    const T = i(), d = i(), O = i();
    D(O, A[2]), c(T, A[0], O), c(d, A[1], O), x(L, d), L[31] ^= I(T) << 7;
  }
  function C(L, A, T) {
    m(L[0], a), m(L[1], o), m(L[2], o), m(L[3], a);
    for (let d = 255; d >= 0; --d) {
      const O = T[d / 8 | 0] >> (d & 7) & 1;
      B(L, A, O), k(A, L), k(L, L), B(L, A, O);
    }
  }
  function N(L, A) {
    const T = [i(), i(), i(), i()];
    m(T[0], h), m(T[1], f), m(T[2], o), c(T[3], h, f), C(L, T, A);
  }
  function G(L) {
    if (L.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const A = (0, r.hash)(L);
    A[0] &= 248, A[31] &= 127, A[31] |= 64;
    const T = new Uint8Array(32), d = [i(), i(), i(), i()];
    N(d, A), W(T, d);
    const O = new Uint8Array(64);
    return O.set(L), O.set(T, 32), {
      publicKey: T,
      secretKey: O
    };
  }
  t.generateKeyPairFromSeed = G;
  function z(L) {
    const A = (0, e.randomBytes)(32, L), T = G(A);
    return (0, n.wipe)(A), T;
  }
  t.generateKeyPair = z;
  function $(L) {
    if (L.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(L.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = $;
  const q = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function U(L, A) {
    let T, d, O, H;
    for (d = 63; d >= 32; --d) {
      for (T = 0, O = d - 32, H = d - 12; O < H; ++O)
        A[O] += T - 16 * A[d] * q[O - (d - 32)], T = Math.floor((A[O] + 128) / 256), A[O] -= T * 256;
      A[O] += T, A[d] = 0;
    }
    for (T = 0, O = 0; O < 32; O++)
      A[O] += T - (A[31] >> 4) * q[O], T = A[O] >> 8, A[O] &= 255;
    for (O = 0; O < 32; O++)
      A[O] -= T * q[O];
    for (d = 0; d < 32; d++)
      A[d + 1] += A[d] >> 8, L[d] = A[d] & 255;
  }
  function V(L) {
    const A = new Float64Array(64);
    for (let T = 0; T < 64; T++)
      A[T] = L[T];
    for (let T = 0; T < 64; T++)
      L[T] = 0;
    U(L, A);
  }
  function re(L, A) {
    const T = new Float64Array(64), d = [i(), i(), i(), i()], O = (0, r.hash)(L.subarray(0, 32));
    O[0] &= 248, O[31] &= 127, O[31] |= 64;
    const H = new Uint8Array(64);
    H.set(O.subarray(32), 32);
    const Z = new r.SHA512();
    Z.update(H.subarray(32)), Z.update(A);
    const me = Z.digest();
    Z.clean(), V(me), N(d, me), W(H, d), Z.reset(), Z.update(H.subarray(0, 32)), Z.update(L.subarray(32)), Z.update(A);
    const we = Z.digest();
    V(we);
    for (let ye = 0; ye < 32; ye++)
      T[ye] = me[ye];
    for (let ye = 0; ye < 32; ye++)
      for (let De = 0; De < 32; De++)
        T[ye + De] += we[ye] * O[De];
    return U(H.subarray(32), T), H;
  }
  t.sign = re;
  function K(L, A) {
    const T = i(), d = i(), O = i(), H = i(), Z = i(), me = i(), we = i();
    return m(L[2], o), b(L[1], A), p(O, L[1]), c(H, O, l), y(O, O, L[2]), E(H, L[2], H), p(Z, H), p(me, Z), c(we, me, Z), c(T, we, O), c(T, T, H), R(T, T), c(T, T, O), c(T, T, H), c(T, T, H), c(L[0], T, H), p(d, L[0]), c(d, d, H), _(d, O) && c(L[0], L[0], g), p(d, L[0]), c(d, d, H), _(d, O) ? -1 : (I(L[0]) === A[31] >> 7 && y(L[0], a, L[0]), c(L[3], L[0], L[1]), 0);
  }
  function X(L, A, T) {
    const d = new Uint8Array(32), O = [i(), i(), i(), i()], H = [i(), i(), i(), i()];
    if (T.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (K(H, L))
      return !1;
    const Z = new r.SHA512();
    Z.update(T.subarray(0, 32)), Z.update(L), Z.update(A);
    const me = Z.digest();
    return V(me), C(O, H, me), N(H, T.subarray(32)), k(O, H), W(d, O), !M(T, d);
  }
  t.verify = X;
  function Y(L) {
    let A = [i(), i(), i(), i()];
    if (K(A, L))
      throw new Error("Ed25519: invalid public key");
    let T = i(), d = i(), O = A[1];
    E(T, o, O), y(d, o, O), D(d, d), c(T, T, d);
    let H = new Uint8Array(32);
    return x(H, T), H;
  }
  t.convertPublicKeyToX25519 = Y;
  function ee(L) {
    const A = (0, r.hash)(L.subarray(0, 32));
    A[0] &= 248, A[31] &= 127, A[31] |= 64;
    const T = new Uint8Array(A.subarray(0, 32));
    return (0, n.wipe)(A), T;
  }
  t.convertSecretKeyToX25519 = ee;
})($f);
const RS = "EdDSA", NS = "JWT", x0 = ".", C0 = "base64url", AS = "utf8", LS = "utf8", MS = ":", jS = "did", kS = "key", wg = "base58btc", US = "z", $S = "K36", FS = 32;
function Ff(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function D0(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ff(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function yd(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const r = D0(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return Ff(r);
}
function qS(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), a = s.charCodeAt(0);
    if (r[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[a] = i;
  }
  var o = t.length, l = t.charAt(0), u = Math.log(o) / Math.log(256), h = Math.log(256) / Math.log(o);
  function f(w) {
    if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer, w.byteOffset, w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))), !(w instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (w.length === 0)
      return "";
    for (var S = 0, x = 0, M = 0, _ = w.length; M !== _ && w[M] === 0; )
      M++, S++;
    for (var I = (_ - M) * h + 1 >>> 0, b = new Uint8Array(I); M !== _; ) {
      for (var E = w[M], y = 0, c = I - 1; (E !== 0 || y < x) && c !== -1; c--, y++)
        E += 256 * b[c] >>> 0, b[c] = E % o >>> 0, E = E / o >>> 0;
      if (E !== 0)
        throw new Error("Non-zero carry");
      x = y, M++;
    }
    for (var p = I - x; p !== I && b[p] === 0; )
      p++;
    for (var D = l.repeat(S); p < I; ++p)
      D += t.charAt(b[p]);
    return D;
  }
  function g(w) {
    if (typeof w != "string")
      throw new TypeError("Expected String");
    if (w.length === 0)
      return new Uint8Array();
    var S = 0;
    if (w[S] !== " ") {
      for (var x = 0, M = 0; w[S] === l; )
        x++, S++;
      for (var _ = (w.length - S) * u + 1 >>> 0, I = new Uint8Array(_); w[S]; ) {
        var b = r[w.charCodeAt(S)];
        if (b === 255)
          return;
        for (var E = 0, y = _ - 1; (b !== 0 || E < M) && y !== -1; y--, E++)
          b += o * I[y] >>> 0, I[y] = b % 256 >>> 0, b = b / 256 >>> 0;
        if (b !== 0)
          throw new Error("Non-zero carry");
        M = E, S++;
      }
      if (w[S] !== " ") {
        for (var c = _ - M; c !== _ && I[c] === 0; )
          c++;
        for (var p = new Uint8Array(x + (_ - c)), D = x; c !== _; )
          p[D++] = I[c++];
        return p;
      }
    }
  }
  function m(w) {
    var S = g(w);
    if (S)
      return S;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: f,
    decodeUnsafe: g,
    decode: m
  };
}
var zS = qS, VS = zS;
const KS = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, BS = (t) => new TextEncoder().encode(t), HS = (t) => new TextDecoder().decode(t);
class WS {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class GS {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return T0(this, e);
  }
}
class ZS {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return T0(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const T0 = (t, e) => new ZS({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class YS {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new WS(e, r, n), this.decoder = new GS(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const ll = ({ name: t, prefix: e, encode: r, decode: n }) => new YS(t, e, r, n), yc = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = VS(r, e);
  return ll({
    prefix: t,
    name: e,
    encode: n,
    decode: (s) => KS(i(s))
  });
}, QS = (t, e, r, n) => {
  const i = {};
  for (let h = 0; h < e.length; ++h)
    i[e[h]] = h;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * r / 8 | 0);
  let o = 0, l = 0, u = 0;
  for (let h = 0; h < s; ++h) {
    const f = i[t[h]];
    if (f === void 0)
      throw new SyntaxError(`Non-${n} character`);
    l = l << r | f, o += r, o >= 8 && (o -= 8, a[u++] = 255 & l >> o);
  }
  if (o >= r || 255 & l << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, JS = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", a = 0, o = 0;
  for (let l = 0; l < t.length; ++l)
    for (o = o << 8 | t[l], a += 8; a > r; )
      a -= r, s += e[i & o >> a];
  if (a && (s += e[i & o << r - a]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, gr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => ll({
  prefix: e,
  name: t,
  encode(i) {
    return JS(i, n, r);
  },
  decode(i) {
    return QS(i, n, r, t);
  }
}), XS = ll({
  prefix: "\0",
  name: "identity",
  encode: (t) => HS(t),
  decode: (t) => BS(t)
}), e3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: XS
}, Symbol.toStringTag, { value: "Module" })), t3 = gr({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), r3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: t3
}, Symbol.toStringTag, { value: "Module" })), n3 = gr({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), i3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: n3
}, Symbol.toStringTag, { value: "Module" })), s3 = yc({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), o3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: s3
}, Symbol.toStringTag, { value: "Module" })), a3 = gr({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), c3 = gr({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), u3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: a3,
  base16upper: c3
}, Symbol.toStringTag, { value: "Module" })), l3 = gr({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), h3 = gr({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), d3 = gr({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), f3 = gr({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), p3 = gr({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), g3 = gr({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), y3 = gr({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), m3 = gr({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), v3 = gr({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), b3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: l3,
  base32hex: p3,
  base32hexpad: y3,
  base32hexpadupper: m3,
  base32hexupper: g3,
  base32pad: d3,
  base32padupper: f3,
  base32upper: h3,
  base32z: v3
}, Symbol.toStringTag, { value: "Module" })), w3 = yc({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), _3 = yc({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), E3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: w3,
  base36upper: _3
}, Symbol.toStringTag, { value: "Module" })), S3 = yc({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), O3 = yc({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), I3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: S3,
  base58flickr: O3
}, Symbol.toStringTag, { value: "Module" })), x3 = gr({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), C3 = gr({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), D3 = gr({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), T3 = gr({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), P3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: x3,
  base64pad: C3,
  base64url: D3,
  base64urlpad: T3
}, Symbol.toStringTag, { value: "Module" })), P0 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), R3 = P0.reduce((t, e, r) => (t[r] = e, t), []), N3 = P0.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function A3(t) {
  return t.reduce((e, r) => (e += R3[r], e), "");
}
function L3(t) {
  const e = [];
  for (const r of t) {
    const n = N3[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const M3 = ll({
  prefix: "🚀",
  name: "base256emoji",
  encode: A3,
  decode: L3
}), j3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: M3
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const _g = {
  ...e3,
  ...r3,
  ...i3,
  ...o3,
  ...u3,
  ...b3,
  ...E3,
  ...I3,
  ...P3,
  ...j3
};
function R0(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const Eg = R0("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), xh = R0("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = D0(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), N0 = {
  utf8: Eg,
  "utf-8": Eg,
  hex: _g.base16,
  latin1: xh,
  ascii: xh,
  binary: xh,
  ..._g
};
function Gr(t, e = "utf8") {
  const r = N0[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function nn(t, e = "utf8") {
  const r = N0[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ff(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
function mu(t) {
  return Gr(nn(gc(t), AS), C0);
}
function A0(t) {
  const e = nn($S, wg), r = US + Gr(yd([e, t]), wg);
  return [jS, kS, r].join(MS);
}
function k3(t) {
  return Gr(t, C0);
}
function U3(t) {
  return nn([mu(t.header), mu(t.payload)].join(x0), LS);
}
function $3(t) {
  return [
    mu(t.header),
    mu(t.payload),
    k3(t.signature)
  ].join(x0);
}
function Sg(t = Po.randomBytes(FS)) {
  return $f.generateKeyPairFromSeed(t);
}
async function F3(t, e, r, n, i = Ne.fromMiliseconds(Date.now())) {
  const s = { alg: RS, typ: NS }, a = A0(n.publicKey), o = i + r, l = { iss: a, sub: t, aud: e, iat: i, exp: o }, u = U3({ header: s, payload: l }), h = $f.sign(n.secretKey, u);
  return $3({ header: s, payload: l, signature: h });
}
var qf = {}, hl = {};
Object.defineProperty(hl, "__esModule", { value: !0 });
var wr = rt, md = gn, q3 = 20;
function z3(t, e, r) {
  for (var n = 1634760805, i = 857760878, s = 2036477234, a = 1797285236, o = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], l = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], u = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], h = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], f = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], g = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], m = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], w = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], S = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], x = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], M = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], _ = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], I = n, b = i, E = s, y = a, c = o, p = l, D = u, R = h, k = f, B = g, W = m, C = w, N = S, G = x, z = M, $ = _, q = 0; q < q3; q += 2)
    I = I + c | 0, N ^= I, N = N >>> 16 | N << 16, k = k + N | 0, c ^= k, c = c >>> 20 | c << 12, b = b + p | 0, G ^= b, G = G >>> 16 | G << 16, B = B + G | 0, p ^= B, p = p >>> 20 | p << 12, E = E + D | 0, z ^= E, z = z >>> 16 | z << 16, W = W + z | 0, D ^= W, D = D >>> 20 | D << 12, y = y + R | 0, $ ^= y, $ = $ >>> 16 | $ << 16, C = C + $ | 0, R ^= C, R = R >>> 20 | R << 12, E = E + D | 0, z ^= E, z = z >>> 24 | z << 8, W = W + z | 0, D ^= W, D = D >>> 25 | D << 7, y = y + R | 0, $ ^= y, $ = $ >>> 24 | $ << 8, C = C + $ | 0, R ^= C, R = R >>> 25 | R << 7, b = b + p | 0, G ^= b, G = G >>> 24 | G << 8, B = B + G | 0, p ^= B, p = p >>> 25 | p << 7, I = I + c | 0, N ^= I, N = N >>> 24 | N << 8, k = k + N | 0, c ^= k, c = c >>> 25 | c << 7, I = I + p | 0, $ ^= I, $ = $ >>> 16 | $ << 16, W = W + $ | 0, p ^= W, p = p >>> 20 | p << 12, b = b + D | 0, N ^= b, N = N >>> 16 | N << 16, C = C + N | 0, D ^= C, D = D >>> 20 | D << 12, E = E + R | 0, G ^= E, G = G >>> 16 | G << 16, k = k + G | 0, R ^= k, R = R >>> 20 | R << 12, y = y + c | 0, z ^= y, z = z >>> 16 | z << 16, B = B + z | 0, c ^= B, c = c >>> 20 | c << 12, E = E + R | 0, G ^= E, G = G >>> 24 | G << 8, k = k + G | 0, R ^= k, R = R >>> 25 | R << 7, y = y + c | 0, z ^= y, z = z >>> 24 | z << 8, B = B + z | 0, c ^= B, c = c >>> 25 | c << 7, b = b + D | 0, N ^= b, N = N >>> 24 | N << 8, C = C + N | 0, D ^= C, D = D >>> 25 | D << 7, I = I + p | 0, $ ^= I, $ = $ >>> 24 | $ << 8, W = W + $ | 0, p ^= W, p = p >>> 25 | p << 7;
  wr.writeUint32LE(I + n | 0, t, 0), wr.writeUint32LE(b + i | 0, t, 4), wr.writeUint32LE(E + s | 0, t, 8), wr.writeUint32LE(y + a | 0, t, 12), wr.writeUint32LE(c + o | 0, t, 16), wr.writeUint32LE(p + l | 0, t, 20), wr.writeUint32LE(D + u | 0, t, 24), wr.writeUint32LE(R + h | 0, t, 28), wr.writeUint32LE(k + f | 0, t, 32), wr.writeUint32LE(B + g | 0, t, 36), wr.writeUint32LE(W + m | 0, t, 40), wr.writeUint32LE(C + w | 0, t, 44), wr.writeUint32LE(N + S | 0, t, 48), wr.writeUint32LE(G + x | 0, t, 52), wr.writeUint32LE(z + M | 0, t, 56), wr.writeUint32LE($ + _ | 0, t, 60);
}
function L0(t, e, r, n, i) {
  if (i === void 0 && (i = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, a;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), a = s.length - e.length, s.set(e, a);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, a = i;
  }
  for (var o = new Uint8Array(64), l = 0; l < r.length; l += 64) {
    z3(o, s, t);
    for (var u = l; u < l + 64 && u < r.length; u++)
      n[u] = r[u] ^ o[u - l];
    K3(s, 0, a);
  }
  return md.wipe(o), i === 0 && md.wipe(s), n;
}
hl.streamXOR = L0;
function V3(t, e, r, n) {
  return n === void 0 && (n = 0), md.wipe(r), L0(t, e, r, r, n);
}
hl.stream = V3;
function K3(t, e, r) {
  for (var n = 1; r--; )
    n = n + (t[e] & 255) | 0, t[e] = n & 255, n >>>= 8, e++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var M0 = {}, Qi = {};
Object.defineProperty(Qi, "__esModule", { value: !0 });
function B3(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Qi.select = B3;
function H3(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Qi.lessOrEqual = H3;
function j0(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, n = 0; n < t.length; n++)
    r |= t[n] ^ e[n];
  return 1 & r - 1 >>> 8;
}
Qi.compare = j0;
function W3(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : j0(t, e) !== 0;
}
Qi.equal = W3;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Qi, r = gn;
  t.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function a(o) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var l = o[0] | o[1] << 8;
        this._r[0] = l & 8191;
        var u = o[2] | o[3] << 8;
        this._r[1] = (l >>> 13 | u << 3) & 8191;
        var h = o[4] | o[5] << 8;
        this._r[2] = (u >>> 10 | h << 6) & 7939;
        var f = o[6] | o[7] << 8;
        this._r[3] = (h >>> 7 | f << 9) & 8191;
        var g = o[8] | o[9] << 8;
        this._r[4] = (f >>> 4 | g << 12) & 255, this._r[5] = g >>> 1 & 8190;
        var m = o[10] | o[11] << 8;
        this._r[6] = (g >>> 14 | m << 2) & 8191;
        var w = o[12] | o[13] << 8;
        this._r[7] = (m >>> 11 | w << 5) & 8065;
        var S = o[14] | o[15] << 8;
        this._r[8] = (w >>> 8 | S << 8) & 8191, this._r[9] = S >>> 5 & 127, this._pad[0] = o[16] | o[17] << 8, this._pad[1] = o[18] | o[19] << 8, this._pad[2] = o[20] | o[21] << 8, this._pad[3] = o[22] | o[23] << 8, this._pad[4] = o[24] | o[25] << 8, this._pad[5] = o[26] | o[27] << 8, this._pad[6] = o[28] | o[29] << 8, this._pad[7] = o[30] | o[31] << 8;
      }
      return a.prototype._blocks = function(o, l, u) {
        for (var h = this._fin ? 0 : 2048, f = this._h[0], g = this._h[1], m = this._h[2], w = this._h[3], S = this._h[4], x = this._h[5], M = this._h[6], _ = this._h[7], I = this._h[8], b = this._h[9], E = this._r[0], y = this._r[1], c = this._r[2], p = this._r[3], D = this._r[4], R = this._r[5], k = this._r[6], B = this._r[7], W = this._r[8], C = this._r[9]; u >= 16; ) {
          var N = o[l + 0] | o[l + 1] << 8;
          f += N & 8191;
          var G = o[l + 2] | o[l + 3] << 8;
          g += (N >>> 13 | G << 3) & 8191;
          var z = o[l + 4] | o[l + 5] << 8;
          m += (G >>> 10 | z << 6) & 8191;
          var $ = o[l + 6] | o[l + 7] << 8;
          w += (z >>> 7 | $ << 9) & 8191;
          var q = o[l + 8] | o[l + 9] << 8;
          S += ($ >>> 4 | q << 12) & 8191, x += q >>> 1 & 8191;
          var U = o[l + 10] | o[l + 11] << 8;
          M += (q >>> 14 | U << 2) & 8191;
          var V = o[l + 12] | o[l + 13] << 8;
          _ += (U >>> 11 | V << 5) & 8191;
          var re = o[l + 14] | o[l + 15] << 8;
          I += (V >>> 8 | re << 8) & 8191, b += re >>> 5 | h;
          var K = 0, X = K;
          X += f * E, X += g * (5 * C), X += m * (5 * W), X += w * (5 * B), X += S * (5 * k), K = X >>> 13, X &= 8191, X += x * (5 * R), X += M * (5 * D), X += _ * (5 * p), X += I * (5 * c), X += b * (5 * y), K += X >>> 13, X &= 8191;
          var Y = K;
          Y += f * y, Y += g * E, Y += m * (5 * C), Y += w * (5 * W), Y += S * (5 * B), K = Y >>> 13, Y &= 8191, Y += x * (5 * k), Y += M * (5 * R), Y += _ * (5 * D), Y += I * (5 * p), Y += b * (5 * c), K += Y >>> 13, Y &= 8191;
          var ee = K;
          ee += f * c, ee += g * y, ee += m * E, ee += w * (5 * C), ee += S * (5 * W), K = ee >>> 13, ee &= 8191, ee += x * (5 * B), ee += M * (5 * k), ee += _ * (5 * R), ee += I * (5 * D), ee += b * (5 * p), K += ee >>> 13, ee &= 8191;
          var L = K;
          L += f * p, L += g * c, L += m * y, L += w * E, L += S * (5 * C), K = L >>> 13, L &= 8191, L += x * (5 * W), L += M * (5 * B), L += _ * (5 * k), L += I * (5 * R), L += b * (5 * D), K += L >>> 13, L &= 8191;
          var A = K;
          A += f * D, A += g * p, A += m * c, A += w * y, A += S * E, K = A >>> 13, A &= 8191, A += x * (5 * C), A += M * (5 * W), A += _ * (5 * B), A += I * (5 * k), A += b * (5 * R), K += A >>> 13, A &= 8191;
          var T = K;
          T += f * R, T += g * D, T += m * p, T += w * c, T += S * y, K = T >>> 13, T &= 8191, T += x * E, T += M * (5 * C), T += _ * (5 * W), T += I * (5 * B), T += b * (5 * k), K += T >>> 13, T &= 8191;
          var d = K;
          d += f * k, d += g * R, d += m * D, d += w * p, d += S * c, K = d >>> 13, d &= 8191, d += x * y, d += M * E, d += _ * (5 * C), d += I * (5 * W), d += b * (5 * B), K += d >>> 13, d &= 8191;
          var O = K;
          O += f * B, O += g * k, O += m * R, O += w * D, O += S * p, K = O >>> 13, O &= 8191, O += x * c, O += M * y, O += _ * E, O += I * (5 * C), O += b * (5 * W), K += O >>> 13, O &= 8191;
          var H = K;
          H += f * W, H += g * B, H += m * k, H += w * R, H += S * D, K = H >>> 13, H &= 8191, H += x * p, H += M * c, H += _ * y, H += I * E, H += b * (5 * C), K += H >>> 13, H &= 8191;
          var Z = K;
          Z += f * C, Z += g * W, Z += m * B, Z += w * k, Z += S * R, K = Z >>> 13, Z &= 8191, Z += x * D, Z += M * p, Z += _ * c, Z += I * y, Z += b * E, K += Z >>> 13, Z &= 8191, K = (K << 2) + K | 0, K = K + X | 0, X = K & 8191, K = K >>> 13, Y += K, f = X, g = Y, m = ee, w = L, S = A, x = T, M = d, _ = O, I = H, b = Z, l += 16, u -= 16;
        }
        this._h[0] = f, this._h[1] = g, this._h[2] = m, this._h[3] = w, this._h[4] = S, this._h[5] = x, this._h[6] = M, this._h[7] = _, this._h[8] = I, this._h[9] = b;
      }, a.prototype.finish = function(o, l) {
        l === void 0 && (l = 0);
        var u = new Uint16Array(10), h, f, g, m;
        if (this._leftover) {
          for (m = this._leftover, this._buffer[m++] = 1; m < 16; m++)
            this._buffer[m] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (h = this._h[1] >>> 13, this._h[1] &= 8191, m = 2; m < 10; m++)
          this._h[m] += h, h = this._h[m] >>> 13, this._h[m] &= 8191;
        for (this._h[0] += h * 5, h = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += h, h = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += h, u[0] = this._h[0] + 5, h = u[0] >>> 13, u[0] &= 8191, m = 1; m < 10; m++)
          u[m] = this._h[m] + h, h = u[m] >>> 13, u[m] &= 8191;
        for (u[9] -= 8192, f = (h ^ 1) - 1, m = 0; m < 10; m++)
          u[m] &= f;
        for (f = ~f, m = 0; m < 10; m++)
          this._h[m] = this._h[m] & f | u[m];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, g = this._h[0] + this._pad[0], this._h[0] = g & 65535, m = 1; m < 8; m++)
          g = (this._h[m] + this._pad[m] | 0) + (g >>> 16) | 0, this._h[m] = g & 65535;
        return o[l + 0] = this._h[0] >>> 0, o[l + 1] = this._h[0] >>> 8, o[l + 2] = this._h[1] >>> 0, o[l + 3] = this._h[1] >>> 8, o[l + 4] = this._h[2] >>> 0, o[l + 5] = this._h[2] >>> 8, o[l + 6] = this._h[3] >>> 0, o[l + 7] = this._h[3] >>> 8, o[l + 8] = this._h[4] >>> 0, o[l + 9] = this._h[4] >>> 8, o[l + 10] = this._h[5] >>> 0, o[l + 11] = this._h[5] >>> 8, o[l + 12] = this._h[6] >>> 0, o[l + 13] = this._h[6] >>> 8, o[l + 14] = this._h[7] >>> 0, o[l + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, a.prototype.update = function(o) {
        var l = 0, u = o.length, h;
        if (this._leftover) {
          h = 16 - this._leftover, h > u && (h = u);
          for (var f = 0; f < h; f++)
            this._buffer[this._leftover + f] = o[l + f];
          if (u -= h, l += h, this._leftover += h, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (u >= 16 && (h = u - u % 16, this._blocks(o, l, h), l += h, u -= h), u) {
          for (var f = 0; f < u; f++)
            this._buffer[this._leftover + f] = o[l + f];
          this._leftover += u;
        }
        return this;
      }, a.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var o = new Uint8Array(16);
        return this.finish(o), o;
      }, a.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, a;
    }()
  );
  t.Poly1305 = n;
  function i(a, o) {
    var l = new n(a);
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.oneTimeAuth = i;
  function s(a, o) {
    return a.length !== t.DIGEST_LENGTH || o.length !== t.DIGEST_LENGTH ? !1 : e.equal(a, o);
  }
  t.equal = s;
})(M0);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = hl, r = M0, n = gn, i = rt, s = Qi;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var a = new Uint8Array(16), o = (
    /** @class */
    function() {
      function l(u) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, u.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(u);
      }
      return l.prototype.seal = function(u, h, f, g) {
        if (u.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var m = new Uint8Array(16);
        m.set(u, m.length - u.length);
        var w = new Uint8Array(32);
        e.stream(this._key, m, w, 4);
        var S = h.length + this.tagLength, x;
        if (g) {
          if (g.length !== S)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          x = g;
        } else
          x = new Uint8Array(S);
        return e.streamXOR(this._key, m, h, x, 4), this._authenticate(x.subarray(x.length - this.tagLength, x.length), w, x.subarray(0, x.length - this.tagLength), f), n.wipe(m), x;
      }, l.prototype.open = function(u, h, f, g) {
        if (u.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (h.length < this.tagLength)
          return null;
        var m = new Uint8Array(16);
        m.set(u, m.length - u.length);
        var w = new Uint8Array(32);
        e.stream(this._key, m, w, 4);
        var S = new Uint8Array(this.tagLength);
        if (this._authenticate(S, w, h.subarray(0, h.length - this.tagLength), f), !s.equal(S, h.subarray(h.length - this.tagLength, h.length)))
          return null;
        var x = h.length - this.tagLength, M;
        if (g) {
          if (g.length !== x)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          M = g;
        } else
          M = new Uint8Array(x);
        return e.streamXOR(this._key, m, h.subarray(0, h.length - this.tagLength), M, 4), n.wipe(m), M;
      }, l.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, l.prototype._authenticate = function(u, h, f, g) {
        var m = new r.Poly1305(h);
        g && (m.update(g), g.length % 16 > 0 && m.update(a.subarray(g.length % 16))), m.update(f), f.length % 16 > 0 && m.update(a.subarray(f.length % 16));
        var w = new Uint8Array(8);
        g && i.writeUint64LE(g.length, w), m.update(w), i.writeUint64LE(f.length, w), m.update(w);
        for (var S = m.digest(), x = 0; x < S.length; x++)
          u[x] = S[x];
        m.clean(), n.wipe(S), n.wipe(w);
      }, l;
    }()
  );
  t.ChaCha20Poly1305 = o;
})(qf);
var k0 = {}, mc = {}, zf = {};
Object.defineProperty(zf, "__esModule", { value: !0 });
function G3(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
zf.isSerializableHash = G3;
Object.defineProperty(mc, "__esModule", { value: !0 });
var Kn = zf, Z3 = Qi, Y3 = gn, U0 = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 54;
      this._inner.update(n);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 106;
      this._outer.update(n), Kn.isSerializableHash(this._inner) && Kn.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), Y3.wipe(n);
    }
    return t.prototype.reset = function() {
      if (!Kn.isSerializableHash(this._inner) || !Kn.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Kn.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Kn.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Kn.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Kn.isSerializableHash(this._inner) || !Kn.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Kn.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
mc.HMAC = U0;
function Q3(t, e, r) {
  var n = new U0(t, e);
  n.update(r);
  var i = n.digest();
  return n.clean(), i;
}
mc.hmac = Q3;
mc.equal = Z3.equal;
Object.defineProperty(k0, "__esModule", { value: !0 });
var Og = mc, Ig = gn, J3 = (
  /** @class */
  function() {
    function t(e, r, n, i) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
      var s = Og.hmac(this._hash, n, r);
      this._hmac = new Og.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), Ig.wipe(this._buffer), Ig.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), X3 = k0.HKDF = J3, dl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = rt, r = gn;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function o() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return o.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, o.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, o.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, o.prototype.update = function(l, u) {
        if (u === void 0 && (u = l.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var h = 0;
        if (this._bytesHashed += u, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && u > 0; )
            this._buffer[this._bufferLength++] = l[h++], u--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (u >= this.blockSize && (h = s(this._temp, this._state, l, h, u), u %= this.blockSize); u > 0; )
          this._buffer[this._bufferLength++] = l[h++], u--;
        return this;
      }, o.prototype.finish = function(l) {
        if (!this._finished) {
          var u = this._bytesHashed, h = this._bufferLength, f = u / 536870912 | 0, g = u << 3, m = u % 64 < 56 ? 64 : 128;
          this._buffer[h] = 128;
          for (var w = h + 1; w < m - 8; w++)
            this._buffer[w] = 0;
          e.writeUint32BE(f, this._buffer, m - 8), e.writeUint32BE(g, this._buffer, m - 4), s(this._temp, this._state, this._buffer, 0, m), this._finished = !0;
        }
        for (var w = 0; w < this.digestLength / 4; w++)
          e.writeUint32BE(this._state[w], l, w * 4);
        return this;
      }, o.prototype.digest = function() {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }, o.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, o.prototype.restoreState = function(l) {
        return this._state.set(l.state), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this;
      }, o.prototype.cleanSavedState = function(l) {
        r.wipe(l.state), l.buffer && r.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0;
      }, o;
    }()
  );
  t.SHA256 = n;
  var i = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(o, l, u, h, f) {
    for (; f >= 64; ) {
      for (var g = l[0], m = l[1], w = l[2], S = l[3], x = l[4], M = l[5], _ = l[6], I = l[7], b = 0; b < 16; b++) {
        var E = h + b * 4;
        o[b] = e.readUint32BE(u, E);
      }
      for (var b = 16; b < 64; b++) {
        var y = o[b - 2], c = (y >>> 17 | y << 15) ^ (y >>> 19 | y << 13) ^ y >>> 10;
        y = o[b - 15];
        var p = (y >>> 7 | y << 25) ^ (y >>> 18 | y << 14) ^ y >>> 3;
        o[b] = (c + o[b - 7] | 0) + (p + o[b - 16] | 0);
      }
      for (var b = 0; b < 64; b++) {
        var c = (((x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)) + (x & M ^ ~x & _) | 0) + (I + (i[b] + o[b] | 0) | 0) | 0, p = ((g >>> 2 | g << 30) ^ (g >>> 13 | g << 19) ^ (g >>> 22 | g << 10)) + (g & m ^ g & w ^ m & w) | 0;
        I = _, _ = M, M = x, x = S + c | 0, S = w, w = m, m = g, g = c + p | 0;
      }
      l[0] += g, l[1] += m, l[2] += w, l[3] += S, l[4] += x, l[5] += M, l[6] += _, l[7] += I, h += 64, f -= 64;
    }
    return h;
  }
  function a(o) {
    var l = new n();
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.hash = a;
})(dl);
var Vf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = Po, r = gn;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function n(b) {
    const E = new Float64Array(16);
    if (b)
      for (let y = 0; y < b.length; y++)
        E[y] = b[y];
    return E;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = n([56129, 1]);
  function a(b) {
    let E = 1;
    for (let y = 0; y < 16; y++) {
      let c = b[y] + E + 65535;
      E = Math.floor(c / 65536), b[y] = c - E * 65536;
    }
    b[0] += E - 1 + 37 * (E - 1);
  }
  function o(b, E, y) {
    const c = ~(y - 1);
    for (let p = 0; p < 16; p++) {
      const D = c & (b[p] ^ E[p]);
      b[p] ^= D, E[p] ^= D;
    }
  }
  function l(b, E) {
    const y = n(), c = n();
    for (let p = 0; p < 16; p++)
      c[p] = E[p];
    a(c), a(c), a(c);
    for (let p = 0; p < 2; p++) {
      y[0] = c[0] - 65517;
      for (let R = 1; R < 15; R++)
        y[R] = c[R] - 65535 - (y[R - 1] >> 16 & 1), y[R - 1] &= 65535;
      y[15] = c[15] - 32767 - (y[14] >> 16 & 1);
      const D = y[15] >> 16 & 1;
      y[14] &= 65535, o(c, y, 1 - D);
    }
    for (let p = 0; p < 16; p++)
      b[2 * p] = c[p] & 255, b[2 * p + 1] = c[p] >> 8;
  }
  function u(b, E) {
    for (let y = 0; y < 16; y++)
      b[y] = E[2 * y] + (E[2 * y + 1] << 8);
    b[15] &= 32767;
  }
  function h(b, E, y) {
    for (let c = 0; c < 16; c++)
      b[c] = E[c] + y[c];
  }
  function f(b, E, y) {
    for (let c = 0; c < 16; c++)
      b[c] = E[c] - y[c];
  }
  function g(b, E, y) {
    let c, p, D = 0, R = 0, k = 0, B = 0, W = 0, C = 0, N = 0, G = 0, z = 0, $ = 0, q = 0, U = 0, V = 0, re = 0, K = 0, X = 0, Y = 0, ee = 0, L = 0, A = 0, T = 0, d = 0, O = 0, H = 0, Z = 0, me = 0, we = 0, ye = 0, De = 0, He = 0, Ue = 0, _e = y[0], be = y[1], de = y[2], fe = y[3], ue = y[4], ae = y[5], oe = y[6], te = y[7], pe = y[8], ve = y[9], ne = y[10], Ee = y[11], Ie = y[12], Pe = y[13], Re = y[14], Te = y[15];
    c = E[0], D += c * _e, R += c * be, k += c * de, B += c * fe, W += c * ue, C += c * ae, N += c * oe, G += c * te, z += c * pe, $ += c * ve, q += c * ne, U += c * Ee, V += c * Ie, re += c * Pe, K += c * Re, X += c * Te, c = E[1], R += c * _e, k += c * be, B += c * de, W += c * fe, C += c * ue, N += c * ae, G += c * oe, z += c * te, $ += c * pe, q += c * ve, U += c * ne, V += c * Ee, re += c * Ie, K += c * Pe, X += c * Re, Y += c * Te, c = E[2], k += c * _e, B += c * be, W += c * de, C += c * fe, N += c * ue, G += c * ae, z += c * oe, $ += c * te, q += c * pe, U += c * ve, V += c * ne, re += c * Ee, K += c * Ie, X += c * Pe, Y += c * Re, ee += c * Te, c = E[3], B += c * _e, W += c * be, C += c * de, N += c * fe, G += c * ue, z += c * ae, $ += c * oe, q += c * te, U += c * pe, V += c * ve, re += c * ne, K += c * Ee, X += c * Ie, Y += c * Pe, ee += c * Re, L += c * Te, c = E[4], W += c * _e, C += c * be, N += c * de, G += c * fe, z += c * ue, $ += c * ae, q += c * oe, U += c * te, V += c * pe, re += c * ve, K += c * ne, X += c * Ee, Y += c * Ie, ee += c * Pe, L += c * Re, A += c * Te, c = E[5], C += c * _e, N += c * be, G += c * de, z += c * fe, $ += c * ue, q += c * ae, U += c * oe, V += c * te, re += c * pe, K += c * ve, X += c * ne, Y += c * Ee, ee += c * Ie, L += c * Pe, A += c * Re, T += c * Te, c = E[6], N += c * _e, G += c * be, z += c * de, $ += c * fe, q += c * ue, U += c * ae, V += c * oe, re += c * te, K += c * pe, X += c * ve, Y += c * ne, ee += c * Ee, L += c * Ie, A += c * Pe, T += c * Re, d += c * Te, c = E[7], G += c * _e, z += c * be, $ += c * de, q += c * fe, U += c * ue, V += c * ae, re += c * oe, K += c * te, X += c * pe, Y += c * ve, ee += c * ne, L += c * Ee, A += c * Ie, T += c * Pe, d += c * Re, O += c * Te, c = E[8], z += c * _e, $ += c * be, q += c * de, U += c * fe, V += c * ue, re += c * ae, K += c * oe, X += c * te, Y += c * pe, ee += c * ve, L += c * ne, A += c * Ee, T += c * Ie, d += c * Pe, O += c * Re, H += c * Te, c = E[9], $ += c * _e, q += c * be, U += c * de, V += c * fe, re += c * ue, K += c * ae, X += c * oe, Y += c * te, ee += c * pe, L += c * ve, A += c * ne, T += c * Ee, d += c * Ie, O += c * Pe, H += c * Re, Z += c * Te, c = E[10], q += c * _e, U += c * be, V += c * de, re += c * fe, K += c * ue, X += c * ae, Y += c * oe, ee += c * te, L += c * pe, A += c * ve, T += c * ne, d += c * Ee, O += c * Ie, H += c * Pe, Z += c * Re, me += c * Te, c = E[11], U += c * _e, V += c * be, re += c * de, K += c * fe, X += c * ue, Y += c * ae, ee += c * oe, L += c * te, A += c * pe, T += c * ve, d += c * ne, O += c * Ee, H += c * Ie, Z += c * Pe, me += c * Re, we += c * Te, c = E[12], V += c * _e, re += c * be, K += c * de, X += c * fe, Y += c * ue, ee += c * ae, L += c * oe, A += c * te, T += c * pe, d += c * ve, O += c * ne, H += c * Ee, Z += c * Ie, me += c * Pe, we += c * Re, ye += c * Te, c = E[13], re += c * _e, K += c * be, X += c * de, Y += c * fe, ee += c * ue, L += c * ae, A += c * oe, T += c * te, d += c * pe, O += c * ve, H += c * ne, Z += c * Ee, me += c * Ie, we += c * Pe, ye += c * Re, De += c * Te, c = E[14], K += c * _e, X += c * be, Y += c * de, ee += c * fe, L += c * ue, A += c * ae, T += c * oe, d += c * te, O += c * pe, H += c * ve, Z += c * ne, me += c * Ee, we += c * Ie, ye += c * Pe, De += c * Re, He += c * Te, c = E[15], X += c * _e, Y += c * be, ee += c * de, L += c * fe, A += c * ue, T += c * ae, d += c * oe, O += c * te, H += c * pe, Z += c * ve, me += c * ne, we += c * Ee, ye += c * Ie, De += c * Pe, He += c * Re, Ue += c * Te, D += 38 * Y, R += 38 * ee, k += 38 * L, B += 38 * A, W += 38 * T, C += 38 * d, N += 38 * O, G += 38 * H, z += 38 * Z, $ += 38 * me, q += 38 * we, U += 38 * ye, V += 38 * De, re += 38 * He, K += 38 * Ue, p = 1, c = D + p + 65535, p = Math.floor(c / 65536), D = c - p * 65536, c = R + p + 65535, p = Math.floor(c / 65536), R = c - p * 65536, c = k + p + 65535, p = Math.floor(c / 65536), k = c - p * 65536, c = B + p + 65535, p = Math.floor(c / 65536), B = c - p * 65536, c = W + p + 65535, p = Math.floor(c / 65536), W = c - p * 65536, c = C + p + 65535, p = Math.floor(c / 65536), C = c - p * 65536, c = N + p + 65535, p = Math.floor(c / 65536), N = c - p * 65536, c = G + p + 65535, p = Math.floor(c / 65536), G = c - p * 65536, c = z + p + 65535, p = Math.floor(c / 65536), z = c - p * 65536, c = $ + p + 65535, p = Math.floor(c / 65536), $ = c - p * 65536, c = q + p + 65535, p = Math.floor(c / 65536), q = c - p * 65536, c = U + p + 65535, p = Math.floor(c / 65536), U = c - p * 65536, c = V + p + 65535, p = Math.floor(c / 65536), V = c - p * 65536, c = re + p + 65535, p = Math.floor(c / 65536), re = c - p * 65536, c = K + p + 65535, p = Math.floor(c / 65536), K = c - p * 65536, c = X + p + 65535, p = Math.floor(c / 65536), X = c - p * 65536, D += p - 1 + 37 * (p - 1), p = 1, c = D + p + 65535, p = Math.floor(c / 65536), D = c - p * 65536, c = R + p + 65535, p = Math.floor(c / 65536), R = c - p * 65536, c = k + p + 65535, p = Math.floor(c / 65536), k = c - p * 65536, c = B + p + 65535, p = Math.floor(c / 65536), B = c - p * 65536, c = W + p + 65535, p = Math.floor(c / 65536), W = c - p * 65536, c = C + p + 65535, p = Math.floor(c / 65536), C = c - p * 65536, c = N + p + 65535, p = Math.floor(c / 65536), N = c - p * 65536, c = G + p + 65535, p = Math.floor(c / 65536), G = c - p * 65536, c = z + p + 65535, p = Math.floor(c / 65536), z = c - p * 65536, c = $ + p + 65535, p = Math.floor(c / 65536), $ = c - p * 65536, c = q + p + 65535, p = Math.floor(c / 65536), q = c - p * 65536, c = U + p + 65535, p = Math.floor(c / 65536), U = c - p * 65536, c = V + p + 65535, p = Math.floor(c / 65536), V = c - p * 65536, c = re + p + 65535, p = Math.floor(c / 65536), re = c - p * 65536, c = K + p + 65535, p = Math.floor(c / 65536), K = c - p * 65536, c = X + p + 65535, p = Math.floor(c / 65536), X = c - p * 65536, D += p - 1 + 37 * (p - 1), b[0] = D, b[1] = R, b[2] = k, b[3] = B, b[4] = W, b[5] = C, b[6] = N, b[7] = G, b[8] = z, b[9] = $, b[10] = q, b[11] = U, b[12] = V, b[13] = re, b[14] = K, b[15] = X;
  }
  function m(b, E) {
    g(b, E, E);
  }
  function w(b, E) {
    const y = n();
    for (let c = 0; c < 16; c++)
      y[c] = E[c];
    for (let c = 253; c >= 0; c--)
      m(y, y), c !== 2 && c !== 4 && g(y, y, E);
    for (let c = 0; c < 16; c++)
      b[c] = y[c];
  }
  function S(b, E) {
    const y = new Uint8Array(32), c = new Float64Array(80), p = n(), D = n(), R = n(), k = n(), B = n(), W = n();
    for (let z = 0; z < 31; z++)
      y[z] = b[z];
    y[31] = b[31] & 127 | 64, y[0] &= 248, u(c, E);
    for (let z = 0; z < 16; z++)
      D[z] = c[z];
    p[0] = k[0] = 1;
    for (let z = 254; z >= 0; --z) {
      const $ = y[z >>> 3] >>> (z & 7) & 1;
      o(p, D, $), o(R, k, $), h(B, p, R), f(p, p, R), h(R, D, k), f(D, D, k), m(k, B), m(W, p), g(p, R, p), g(R, D, B), h(B, p, R), f(p, p, R), m(D, p), f(R, k, W), g(p, R, s), h(p, p, k), g(R, R, p), g(p, k, W), g(k, D, c), m(D, B), o(p, D, $), o(R, k, $);
    }
    for (let z = 0; z < 16; z++)
      c[z + 16] = p[z], c[z + 32] = R[z], c[z + 48] = D[z], c[z + 64] = k[z];
    const C = c.subarray(32), N = c.subarray(16);
    w(C, C), g(N, N, C);
    const G = new Uint8Array(32);
    return l(G, N), G;
  }
  t.scalarMult = S;
  function x(b) {
    return S(b, i);
  }
  t.scalarMultBase = x;
  function M(b) {
    if (b.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const E = new Uint8Array(b);
    return {
      publicKey: x(E),
      secretKey: E
    };
  }
  t.generateKeyPairFromSeed = M;
  function _(b) {
    const E = (0, e.randomBytes)(32, b), y = M(E);
    return (0, r.wipe)(E), y;
  }
  t.generateKeyPair = _;
  function I(b, E, y = !1) {
    if (b.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (E.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const c = S(b, E);
    if (y) {
      let p = 0;
      for (let D = 0; D < c.length; D++)
        p |= c[D];
      if (p === 0)
        throw new Error("X25519: invalid shared key");
    }
    return c;
  }
  t.sharedKey = I;
})(Vf);
var xg = function(t, e, r) {
  if (r || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return t.concat(s || Array.prototype.slice.call(e));
}, e5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n) {
      this.name = e, this.version = r, this.os = n, this.type = "browser";
    }
    return t;
  }()
), t5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t;
  }()
), r5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n, i) {
      this.name = e, this.version = r, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return t;
  }()
), n5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), i5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), s5 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, o5 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Cg = 3, a5 = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", s5]
], Dg = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function c5(t) {
  return t ? Tg(t) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new i5() : typeof navigator < "u" ? Tg(navigator.userAgent) : h5();
}
function u5(t) {
  return t !== "" && a5.reduce(function(e, r) {
    var n = r[0], i = r[1];
    if (e)
      return e;
    var s = i.exec(t);
    return !!s && [n, s];
  }, !1);
}
function Tg(t) {
  var e = u5(t);
  if (!e)
    return null;
  var r = e[0], n = e[1];
  if (r === "searchbot")
    return new n5();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < Cg && (i = xg(xg([], i, !0), d5(Cg - i.length), !0)) : i = [];
  var s = i.join("."), a = l5(t), o = o5.exec(t);
  return o && o[1] ? new r5(r, s, a, o[1]) : new e5(r, s, a);
}
function l5(t) {
  for (var e = 0, r = Dg.length; e < r; e++) {
    var n = Dg[e], i = n[0], s = n[1], a = s.exec(t);
    if (a)
      return i;
  }
  return null;
}
function h5() {
  var t = typeof process < "u" && process.version;
  return t ? new t5(process.version.slice(1)) : null;
}
function d5(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: !0 });
Rt.getLocalStorage = Rt.getLocalStorageOrThrow = Rt.getCrypto = Rt.getCryptoOrThrow = $0 = Rt.getLocation = Rt.getLocationOrThrow = Bf = Rt.getNavigator = Rt.getNavigatorOrThrow = Kf = Rt.getDocument = Rt.getDocumentOrThrow = Rt.getFromWindowOrThrow = Rt.getFromWindow = void 0;
function As(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Rt.getFromWindow = As;
function Ro(t) {
  const e = As(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Rt.getFromWindowOrThrow = Ro;
function f5() {
  return Ro("document");
}
Rt.getDocumentOrThrow = f5;
function p5() {
  return As("document");
}
var Kf = Rt.getDocument = p5;
function g5() {
  return Ro("navigator");
}
Rt.getNavigatorOrThrow = g5;
function y5() {
  return As("navigator");
}
var Bf = Rt.getNavigator = y5;
function m5() {
  return Ro("location");
}
Rt.getLocationOrThrow = m5;
function v5() {
  return As("location");
}
var $0 = Rt.getLocation = v5;
function b5() {
  return Ro("crypto");
}
Rt.getCryptoOrThrow = b5;
function w5() {
  return As("crypto");
}
Rt.getCrypto = w5;
function _5() {
  return Ro("localStorage");
}
Rt.getLocalStorageOrThrow = _5;
function E5() {
  return As("localStorage");
}
Rt.getLocalStorage = E5;
var Hf = {};
Object.defineProperty(Hf, "__esModule", { value: !0 });
var F0 = Hf.getWindowMetadata = void 0;
const Pg = Rt;
function S5() {
  let t, e;
  try {
    t = Pg.getDocumentOrThrow(), e = Pg.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const f = t.getElementsByTagName("link"), g = [];
    for (let m = 0; m < f.length; m++) {
      const w = f[m], S = w.getAttribute("rel");
      if (S && S.toLowerCase().indexOf("icon") > -1) {
        const x = w.getAttribute("href");
        if (x)
          if (x.toLowerCase().indexOf("https:") === -1 && x.toLowerCase().indexOf("http:") === -1 && x.indexOf("//") !== 0) {
            let M = e.protocol + "//" + e.host;
            if (x.indexOf("/") === 0)
              M += x;
            else {
              const _ = e.pathname.split("/");
              _.pop();
              const I = _.join("/");
              M += I + "/" + x;
            }
            g.push(M);
          } else if (x.indexOf("//") === 0) {
            const M = e.protocol + x;
            g.push(M);
          } else
            g.push(x);
      }
    }
    return g;
  }
  function n(...f) {
    const g = t.getElementsByTagName("meta");
    for (let m = 0; m < g.length; m++) {
      const w = g[m], S = ["itemprop", "property", "name"].map((x) => w.getAttribute(x)).filter((x) => x ? f.includes(x) : !1);
      if (S.length && S) {
        const x = w.getAttribute("content");
        if (x)
          return x;
      }
    }
    return "";
  }
  function i() {
    let f = n("name", "og:site_name", "og:title", "twitter:title");
    return f || (f = t.title), f;
  }
  function s() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const a = i(), o = s(), l = e.origin, u = r();
  return {
    description: o,
    url: l,
    icons: u,
    name: a
  };
}
F0 = Hf.getWindowMetadata = S5;
var Ca = {}, O5 = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), q0 = "%[a-f0-9]{2}", Rg = new RegExp("(" + q0 + ")|([^%]+?)", "gi"), Ng = new RegExp("(" + q0 + ")+", "gi");
function vd(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), n = t.slice(e);
  return Array.prototype.concat.call([], vd(r), vd(n));
}
function I5(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(Rg) || [], r = 1; r < e.length; r++)
      t = vd(e, r).join(""), e = t.match(Rg) || [];
    return t;
  }
}
function x5(t) {
  for (var e = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, r = Ng.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = I5(r[0]);
      n !== r[0] && (e[r[0]] = n);
    }
    r = Ng.exec(t);
  }
  e["%C2"] = "�";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var a = i[s];
    t = t.replace(new RegExp(a, "g"), e[a]);
  }
  return t;
}
var C5 = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return x5(t);
  }
}, D5 = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, T5 = function(t, e) {
  for (var r = {}, n = Object.keys(t), i = Array.isArray(e), s = 0; s < n.length; s++) {
    var a = n[s], o = t[a];
    (i ? e.indexOf(a) !== -1 : e(a, o, t)) && (r[a] = o);
  }
  return r;
};
(function(t) {
  const e = O5, r = C5, n = D5, i = T5, s = (_) => _ == null, a = Symbol("encodeFragmentIdentifier");
  function o(_) {
    switch (_.arrayFormat) {
      case "index":
        return (I) => (b, E) => {
          const y = b.length;
          return E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, [h(I, _), "[", y, "]"].join("")] : [
            ...b,
            [h(I, _), "[", h(y, _), "]=", h(E, _)].join("")
          ];
        };
      case "bracket":
        return (I) => (b, E) => E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, [h(I, _), "[]"].join("")] : [...b, [h(I, _), "[]=", h(E, _)].join("")];
      case "colon-list-separator":
        return (I) => (b, E) => E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, [h(I, _), ":list="].join("")] : [...b, [h(I, _), ":list=", h(E, _)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const I = _.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (b) => (E, y) => y === void 0 || _.skipNull && y === null || _.skipEmptyString && y === "" ? E : (y = y === null ? "" : y, E.length === 0 ? [[h(b, _), I, h(y, _)].join("")] : [[E, h(y, _)].join(_.arrayFormatSeparator)]);
      }
      default:
        return (I) => (b, E) => E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, h(I, _)] : [...b, [h(I, _), "=", h(E, _)].join("")];
    }
  }
  function l(_) {
    let I;
    switch (_.arrayFormat) {
      case "index":
        return (b, E, y) => {
          if (I = /\[(\d*)\]$/.exec(b), b = b.replace(/\[\d*\]$/, ""), !I) {
            y[b] = E;
            return;
          }
          y[b] === void 0 && (y[b] = {}), y[b][I[1]] = E;
        };
      case "bracket":
        return (b, E, y) => {
          if (I = /(\[\])$/.exec(b), b = b.replace(/\[\]$/, ""), !I) {
            y[b] = E;
            return;
          }
          if (y[b] === void 0) {
            y[b] = [E];
            return;
          }
          y[b] = [].concat(y[b], E);
        };
      case "colon-list-separator":
        return (b, E, y) => {
          if (I = /(:list)$/.exec(b), b = b.replace(/:list$/, ""), !I) {
            y[b] = E;
            return;
          }
          if (y[b] === void 0) {
            y[b] = [E];
            return;
          }
          y[b] = [].concat(y[b], E);
        };
      case "comma":
      case "separator":
        return (b, E, y) => {
          const c = typeof E == "string" && E.includes(_.arrayFormatSeparator), p = typeof E == "string" && !c && f(E, _).includes(_.arrayFormatSeparator);
          E = p ? f(E, _) : E;
          const D = c || p ? E.split(_.arrayFormatSeparator).map((R) => f(R, _)) : E === null ? E : f(E, _);
          y[b] = D;
        };
      case "bracket-separator":
        return (b, E, y) => {
          const c = /(\[\])$/.test(b);
          if (b = b.replace(/\[\]$/, ""), !c) {
            y[b] = E && f(E, _);
            return;
          }
          const p = E === null ? [] : E.split(_.arrayFormatSeparator).map((D) => f(D, _));
          if (y[b] === void 0) {
            y[b] = p;
            return;
          }
          y[b] = [].concat(y[b], p);
        };
      default:
        return (b, E, y) => {
          if (y[b] === void 0) {
            y[b] = E;
            return;
          }
          y[b] = [].concat(y[b], E);
        };
    }
  }
  function u(_) {
    if (typeof _ != "string" || _.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function h(_, I) {
    return I.encode ? I.strict ? e(_) : encodeURIComponent(_) : _;
  }
  function f(_, I) {
    return I.decode ? r(_) : _;
  }
  function g(_) {
    return Array.isArray(_) ? _.sort() : typeof _ == "object" ? g(Object.keys(_)).sort((I, b) => Number(I) - Number(b)).map((I) => _[I]) : _;
  }
  function m(_) {
    const I = _.indexOf("#");
    return I !== -1 && (_ = _.slice(0, I)), _;
  }
  function w(_) {
    let I = "";
    const b = _.indexOf("#");
    return b !== -1 && (I = _.slice(b)), I;
  }
  function S(_) {
    _ = m(_);
    const I = _.indexOf("?");
    return I === -1 ? "" : _.slice(I + 1);
  }
  function x(_, I) {
    return I.parseNumbers && !Number.isNaN(Number(_)) && typeof _ == "string" && _.trim() !== "" ? _ = Number(_) : I.parseBooleans && _ !== null && (_.toLowerCase() === "true" || _.toLowerCase() === "false") && (_ = _.toLowerCase() === "true"), _;
  }
  function M(_, I) {
    I = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, I), u(I.arrayFormatSeparator);
    const b = l(I), E = /* @__PURE__ */ Object.create(null);
    if (typeof _ != "string" || (_ = _.trim().replace(/^[?#&]/, ""), !_))
      return E;
    for (const y of _.split("&")) {
      if (y === "")
        continue;
      let [c, p] = n(I.decode ? y.replace(/\+/g, " ") : y, "=");
      p = p === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(I.arrayFormat) ? p : f(p, I), b(f(c, I), p, E);
    }
    for (const y of Object.keys(E)) {
      const c = E[y];
      if (typeof c == "object" && c !== null)
        for (const p of Object.keys(c))
          c[p] = x(c[p], I);
      else
        E[y] = x(c, I);
    }
    return I.sort === !1 ? E : (I.sort === !0 ? Object.keys(E).sort() : Object.keys(E).sort(I.sort)).reduce((y, c) => {
      const p = E[c];
      return p && typeof p == "object" && !Array.isArray(p) ? y[c] = g(p) : y[c] = p, y;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = S, t.parse = M, t.stringify = (_, I) => {
    if (!_)
      return "";
    I = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, I), u(I.arrayFormatSeparator);
    const b = (p) => I.skipNull && s(_[p]) || I.skipEmptyString && _[p] === "", E = o(I), y = {};
    for (const p of Object.keys(_))
      b(p) || (y[p] = _[p]);
    const c = Object.keys(y);
    return I.sort !== !1 && c.sort(I.sort), c.map((p) => {
      const D = _[p];
      return D === void 0 ? "" : D === null ? h(p, I) : Array.isArray(D) ? D.length === 0 && I.arrayFormat === "bracket-separator" ? h(p, I) + "[]" : D.reduce(E(p), []).join("&") : h(p, I) + "=" + h(D, I);
    }).filter((p) => p.length > 0).join("&");
  }, t.parseUrl = (_, I) => {
    I = Object.assign({
      decode: !0
    }, I);
    const [b, E] = n(_, "#");
    return Object.assign(
      {
        url: b.split("?")[0] || "",
        query: M(S(_), I)
      },
      I && I.parseFragmentIdentifier && E ? { fragmentIdentifier: f(E, I) } : {}
    );
  }, t.stringifyUrl = (_, I) => {
    I = Object.assign({
      encode: !0,
      strict: !0,
      [a]: !0
    }, I);
    const b = m(_.url).split("?")[0] || "", E = t.extract(_.url), y = t.parse(E, { sort: !1 }), c = Object.assign(y, _.query);
    let p = t.stringify(c, I);
    p && (p = `?${p}`);
    let D = w(_.url);
    return _.fragmentIdentifier && (D = `#${I[a] ? h(_.fragmentIdentifier, I) : _.fragmentIdentifier}`), `${b}${p}${D}`;
  }, t.pick = (_, I, b) => {
    b = Object.assign({
      parseFragmentIdentifier: !0,
      [a]: !1
    }, b);
    const { url: E, query: y, fragmentIdentifier: c } = t.parseUrl(_, b);
    return t.stringifyUrl({
      url: E,
      query: i(y, I),
      fragmentIdentifier: c
    }, b);
  }, t.exclude = (_, I, b) => {
    const E = Array.isArray(I) ? (y) => !I.includes(y) : (y, c) => !I(y, c);
    return t.pick(_, E, b);
  };
})(Ca);
const P5 = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function z0(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
const V0 = "base10", Hr = "base16", bd = "base64pad", Wf = "utf8", K0 = 0, Ls = 1, R5 = 0, Ag = 1, wd = 12, Gf = 32;
function N5() {
  const t = Vf.generateKeyPair();
  return { privateKey: Gr(t.secretKey, Hr), publicKey: Gr(t.publicKey, Hr) };
}
function _d() {
  const t = Po.randomBytes(Gf);
  return Gr(t, Hr);
}
function A5(t, e) {
  const r = Vf.sharedKey(nn(t, Hr), nn(e, Hr), !0), n = new X3(dl.SHA256, r).expand(Gf);
  return Gr(n, Hr);
}
function L5(t) {
  const e = dl.hash(nn(t, Hr));
  return Gr(e, Hr);
}
function ao(t) {
  const e = dl.hash(nn(t, Wf));
  return Gr(e, Hr);
}
function M5(t) {
  return nn(`${t}`, V0);
}
function vc(t) {
  return Number(Gr(t, V0));
}
function j5(t) {
  const e = M5(typeof t.type < "u" ? t.type : K0);
  if (vc(e) === Ls && typeof t.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? nn(t.senderPublicKey, Hr) : void 0, n = typeof t.iv < "u" ? nn(t.iv, Hr) : Po.randomBytes(wd), i = new qf.ChaCha20Poly1305(nn(t.symKey, Hr)).seal(n, nn(t.message, Wf));
  return U5({ type: e, sealed: i, iv: n, senderPublicKey: r });
}
function k5(t) {
  const e = new qf.ChaCha20Poly1305(nn(t.symKey, Hr)), { sealed: r, iv: n } = vu(t.encoded), i = e.open(n, r);
  if (i === null)
    throw new Error("Failed to decrypt");
  return Gr(i, Wf);
}
function U5(t) {
  if (vc(t.type) === Ls) {
    if (typeof t.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return Gr(yd([t.type, t.senderPublicKey, t.iv, t.sealed]), bd);
  }
  return Gr(yd([t.type, t.iv, t.sealed]), bd);
}
function vu(t) {
  const e = nn(t, bd), r = e.slice(R5, Ag), n = Ag;
  if (vc(r) === Ls) {
    const o = n + Gf, l = o + wd, u = e.slice(n, o), h = e.slice(o, l), f = e.slice(l);
    return { type: r, sealed: f, iv: h, senderPublicKey: u };
  }
  const i = n + wd, s = e.slice(n, i), a = e.slice(i);
  return { type: r, sealed: a, iv: s };
}
function $5(t, e) {
  const r = vu(t);
  return B0({ type: vc(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? Gr(r.senderPublicKey, Hr) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function B0(t) {
  const e = (t == null ? void 0 : t.type) || K0;
  if (e === Ls) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Lg(t) {
  return t.type === Ls && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
var F5 = Object.defineProperty, Mg = Object.getOwnPropertySymbols, q5 = Object.prototype.hasOwnProperty, z5 = Object.prototype.propertyIsEnumerable, jg = (t, e, r) => e in t ? F5(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, kg = (t, e) => {
  for (var r in e || (e = {}))
    q5.call(e, r) && jg(t, r, e[r]);
  if (Mg)
    for (var r of Mg(e))
      z5.call(e, r) && jg(t, r, e[r]);
  return t;
};
const V5 = "ReactNative", fn = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, K5 = "js";
function Zf() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function No() {
  return !Kf() && !!Bf() && navigator.product === V5;
}
function Ao() {
  return !Zf() && !!Bf() && !!Kf();
}
function bc() {
  return No() ? fn.reactNative : Zf() ? fn.node : Ao() ? fn.browser : fn.unknown;
}
function B5() {
  var t;
  try {
    return No() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function H5(t, e) {
  let r = Ca.parse(t);
  return r = kg(kg({}, r), e), t = Ca.stringify(r), t;
}
function W5() {
  return F0() || { name: "", description: "", url: "", icons: [""] };
}
function G5() {
  if (bc() === fn.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r, Version: n } = global.Platform;
    return [r, n].join("-");
  }
  const t = c5();
  if (t === null)
    return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Z5() {
  var t;
  const e = bc();
  return e === fn.browser ? [e, ((t = $0()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function Y5(t, e, r) {
  const n = G5(), i = Z5();
  return [[t, e].join("-"), [K5, r].join("-"), n, i].join("/");
}
function Q5({ protocol: t, version: e, relayUrl: r, sdkVersion: n, auth: i, projectId: s, useOnCloseEvent: a, bundleId: o }) {
  const l = r.split("?"), u = Y5(t, e, n), h = { auth: i, ua: u, projectId: s, useOnCloseEvent: a || void 0, origin: o || void 0 }, f = H5(l[1] || "", h);
  return l[0] + "?" + f;
}
function ys(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function H0(t) {
  return Object.fromEntries(t.entries());
}
function W0(t) {
  return new Map(Object.entries(t));
}
function Ys(t = Ne.FIVE_MINUTES, e) {
  const r = Ne.toMiliseconds(t || Ne.FIVE_MINUTES);
  let n, i, s;
  return { resolve: (a) => {
    s && n && (clearTimeout(s), n(a));
  }, reject: (a) => {
    s && i && (clearTimeout(s), i(a));
  }, done: () => new Promise((a, o) => {
    s = setTimeout(() => {
      o(new Error(e));
    }, r), n = a, i = o;
  }) };
}
function Da(t, e, r) {
  return new Promise(async (n, i) => {
    const s = setTimeout(() => i(new Error(r)), e);
    try {
      const a = await t;
      n(a);
    } catch (a) {
      i(a);
    }
    clearTimeout(s);
  });
}
function G0(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`))
    return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function J5(t) {
  return G0("topic", t);
}
function X5(t) {
  return G0("id", t);
}
function Z0(t) {
  const [e, r] = t.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string")
    n.topic = r;
  else if (e === "id" && Number.isInteger(Number(r)))
    n.id = Number(r);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return n;
}
function hn(t, e) {
  return Ne.fromMiliseconds((e || Date.now()) + Ne.toMiliseconds(t));
}
function Ri(t) {
  return Date.now() >= Ne.toMiliseconds(t);
}
function Ht(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
async function e6({ id: t, topic: e, wcDeepLink: r }) {
  try {
    if (!r)
      return;
    const n = typeof r == "string" ? JSON.parse(r) : r;
    let i = n == null ? void 0 : n.href;
    if (typeof i != "string")
      return;
    i.endsWith("/") && (i = i.slice(0, -1));
    const s = `${i}/wc?requestId=${t}&sessionTopic=${e}`, a = bc();
    a === fn.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : a === fn.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (n) {
    console.error(n);
  }
}
async function t6(t, e) {
  try {
    return await t.getItem(e) || (Ao() ? localStorage.getItem(e) : void 0);
  } catch (r) {
    console.error(r);
  }
}
const r6 = "irn";
function Ed(t) {
  return (t == null ? void 0 : t.relay) || { protocol: r6 };
}
function su(t) {
  const e = P5[t];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var n6 = Object.defineProperty, i6 = Object.defineProperties, s6 = Object.getOwnPropertyDescriptors, Ug = Object.getOwnPropertySymbols, o6 = Object.prototype.hasOwnProperty, a6 = Object.prototype.propertyIsEnumerable, $g = (t, e, r) => e in t ? n6(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, c6 = (t, e) => {
  for (var r in e || (e = {}))
    o6.call(e, r) && $g(t, r, e[r]);
  if (Ug)
    for (var r of Ug(e))
      a6.call(e, r) && $g(t, r, e[r]);
  return t;
}, u6 = (t, e) => i6(t, s6(e));
function l6(t, e = "-") {
  const r = {}, n = "relay" + e;
  return Object.keys(t).forEach((i) => {
    if (i.startsWith(n)) {
      const s = i.replace(n, ""), a = t[i];
      r[s] = a;
    }
  }), r;
}
function Fg(t) {
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, n = t.substring(0, e), i = t.substring(e + 1, r).split("@"), s = typeof r < "u" ? t.substring(r) : "", a = Ca.parse(s);
  return { protocol: n, topic: h6(i[0]), version: parseInt(i[1], 10), symKey: a.symKey, relay: l6(a), expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0 };
}
function h6(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function d6(t, e = "-") {
  const r = "relay", n = {};
  return Object.keys(t).forEach((i) => {
    const s = r + e + i;
    t[i] && (n[s] = t[i]);
  }), n;
}
function f6(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + Ca.stringify(u6(c6({ symKey: t.symKey }, d6(t.relay)), { expiryTimestamp: t.expiryTimestamp }));
}
function Lo(t) {
  const e = [];
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.push(`${n}:${i}`);
  }), e;
}
function p6(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...Lo(r.accounts));
  }), e;
}
function g6(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    Lo(n.accounts).includes(e) && r.push(...n.methods);
  }), r;
}
function y6(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    Lo(n.accounts).includes(e) && r.push(...n.events);
  }), r;
}
const m6 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, v6 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function le(t, e) {
  const { message: r, code: n } = v6[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function zt(t, e) {
  const { message: r, code: n } = m6[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function wc(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : !0 : !1;
}
function bu(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function zr(t) {
  return typeof t > "u";
}
function cr(t, e) {
  return e && zr(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function Yf(t, e) {
  return e && zr(t) ? !0 : typeof t == "number" && !isNaN(t);
}
function b6(t, e) {
  const { requiredNamespaces: r } = e, n = Object.keys(t.namespaces), i = Object.keys(r);
  let s = !0;
  return ys(i, n) ? (n.forEach((a) => {
    const { accounts: o, methods: l, events: u } = t.namespaces[a], h = Lo(o), f = r[a];
    (!ys(z0(a, f), h) || !ys(f.methods, l) || !ys(f.events, u)) && (s = !1);
  }), s) : !1;
}
function wu(t) {
  return cr(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function w6(t) {
  if (cr(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && wu(r);
    }
  }
  return !1;
}
function _6(t) {
  if (cr(t, !1))
    try {
      return typeof new URL(t) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function E6(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function S6(t) {
  return t == null ? void 0 : t.topic;
}
function O6(t, e) {
  let r = null;
  return cr(t == null ? void 0 : t.publicKey, !1) || (r = le("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function qg(t) {
  let e = !0;
  return wc(t) ? t.length && (e = t.every((r) => cr(r, !1))) : e = !1, e;
}
function I6(t, e, r) {
  let n = null;
  return wc(e) && e.length ? e.forEach((i) => {
    n || wu(i) || (n = zt("UNSUPPORTED_CHAINS", `${r}, chain ${i} should be a string and conform to "namespace:chainId" format`));
  }) : wu(t) || (n = zt("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function x6(t, e, r) {
  let n = null;
  return Object.entries(t).forEach(([i, s]) => {
    if (n)
      return;
    const a = I6(i, z0(i, s), `${e} ${r}`);
    a && (n = a);
  }), n;
}
function C6(t, e) {
  let r = null;
  return wc(t) ? t.forEach((n) => {
    r || w6(n) || (r = zt("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = zt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function D6(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r)
      return;
    const i = C6(n == null ? void 0 : n.accounts, `${e} namespace`);
    i && (r = i);
  }), r;
}
function T6(t, e) {
  let r = null;
  return qg(t == null ? void 0 : t.methods) ? qg(t == null ? void 0 : t.events) || (r = zt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = zt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function Y0(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r)
      return;
    const i = T6(n, `${e}, namespace`);
    i && (r = i);
  }), r;
}
function P6(t, e, r) {
  let n = null;
  if (t && bu(t)) {
    const i = Y0(t, e);
    i && (n = i);
    const s = x6(t, e, r);
    s && (n = s);
  } else
    n = le("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return n;
}
function Ch(t, e) {
  let r = null;
  if (t && bu(t)) {
    const n = Y0(t, e);
    n && (r = n);
    const i = D6(t, e);
    i && (r = i);
  } else
    r = le("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function Q0(t) {
  return cr(t.protocol, !0);
}
function R6(t, e) {
  let r = !1;
  return e && !t ? r = !0 : t && wc(t) && t.length && t.forEach((n) => {
    r = Q0(n);
  }), r;
}
function N6(t) {
  return typeof t == "number";
}
function tn(t) {
  return typeof t < "u" && typeof t !== null;
}
function A6(t) {
  return !(!t || typeof t != "object" || !t.code || !Yf(t.code, !1) || !t.message || !cr(t.message, !1));
}
function L6(t) {
  return !(zr(t) || !cr(t.method, !1));
}
function M6(t) {
  return !(zr(t) || zr(t.result) && zr(t.error) || !Yf(t.id, !1) || !cr(t.jsonrpc, !1));
}
function j6(t) {
  return !(zr(t) || !cr(t.name, !1));
}
function zg(t, e) {
  return !(!wu(e) || !p6(t).includes(e));
}
function k6(t, e, r) {
  return cr(r, !1) ? g6(t, e).includes(r) : !1;
}
function U6(t, e, r) {
  return cr(r, !1) ? y6(t, e).includes(r) : !1;
}
function Vg(t, e, r) {
  let n = null;
  const i = $6(t), s = F6(e), a = Object.keys(i), o = Object.keys(s), l = Kg(Object.keys(t)), u = Kg(Object.keys(e)), h = l.filter((f) => !u.includes(f));
  return h.length && (n = le("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${h.toString()}
      Received: ${Object.keys(e).toString()}`)), ys(a, o) || (n = le("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`)), Object.keys(e).forEach((f) => {
    if (!f.includes(":") || n)
      return;
    const g = Lo(e[f].accounts);
    g.includes(f) || (n = le("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${f}
        Required: ${f}
        Approved: ${g.toString()}`));
  }), a.forEach((f) => {
    n || (ys(i[f].methods, s[f].methods) ? ys(i[f].events, s[f].events) || (n = le("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${f}`)) : n = le("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${f}`));
  }), n;
}
function $6(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var n;
    r.includes(":") ? e[r] = t[r] : (n = t[r].chains) == null || n.forEach((i) => {
      e[i] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function Kg(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function F6(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":"))
      e[r] = t[r];
    else {
      const n = Lo(t[r].accounts);
      n == null || n.forEach((i) => {
        e[i] = { accounts: t[r].accounts.filter((s) => s.includes(`${i}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function q6(t, e) {
  return Yf(t, !1) && t <= e.max && t >= e.min;
}
function Bg() {
  const t = bc();
  return new Promise((e) => {
    switch (t) {
      case fn.browser:
        e(z6());
        break;
      case fn.reactNative:
        e(V6());
        break;
      case fn.node:
        e(K6());
        break;
      default:
        e(!0);
    }
  });
}
function z6() {
  return Ao() && (navigator == null ? void 0 : navigator.onLine);
}
async function V6() {
  if (No() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function K6() {
  return !0;
}
function B6(t) {
  switch (bc()) {
    case fn.browser:
      H6(t);
      break;
    case fn.reactNative:
      W6(t);
      break;
  }
}
function H6(t) {
  !No() && Ao() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function W6(t) {
  No() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
const Dh = {};
let qc = class {
  static get(e) {
    return Dh[e];
  }
  static set(e, r) {
    Dh[e] = r;
  }
  static delete(e) {
    delete Dh[e];
  }
};
const G6 = "PARSE_ERROR", Z6 = "INVALID_REQUEST", Y6 = "METHOD_NOT_FOUND", Q6 = "INVALID_PARAMS", J0 = "INTERNAL_ERROR", Qf = "SERVER_ERROR", J6 = [-32700, -32600, -32601, -32602, -32603], Sa = {
  [G6]: { code: -32700, message: "Parse error" },
  [Z6]: { code: -32600, message: "Invalid Request" },
  [Y6]: { code: -32601, message: "Method not found" },
  [Q6]: { code: -32602, message: "Invalid params" },
  [J0]: { code: -32603, message: "Internal error" },
  [Qf]: { code: -32e3, message: "Server error" }
}, X0 = Qf;
function X6(t) {
  return J6.includes(t);
}
function Hg(t) {
  return Object.keys(Sa).includes(t) ? Sa[t] : Sa[X0];
}
function eO(t) {
  const e = Object.values(Sa).find((r) => r.code === t);
  return e || Sa[X0];
}
function tO(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var eb = {}, hi = {}, Wg;
function rO() {
  if (Wg)
    return hi;
  Wg = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.isBrowserCryptoAvailable = hi.getSubtleCrypto = hi.getBrowerCrypto = void 0;
  function t() {
    return (Qn == null ? void 0 : Qn.crypto) || (Qn == null ? void 0 : Qn.msCrypto) || {};
  }
  hi.getBrowerCrypto = t;
  function e() {
    const n = t();
    return n.subtle || n.webkitSubtle;
  }
  hi.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return hi.isBrowserCryptoAvailable = r, hi;
}
var di = {}, Gg;
function nO() {
  if (Gg)
    return di;
  Gg = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.isBrowser = di.isNode = di.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  di.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  di.isNode = e;
  function r() {
    return !t() && !e();
  }
  return di.isBrowser = r, di;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = ni;
  e.__exportStar(rO(), t), e.__exportStar(nO(), t);
})(eb);
function Jf(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function tb(t = 6) {
  return BigInt(Jf(t));
}
function co(t, e, r) {
  return {
    id: r || Jf(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function Xf(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function ep(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: iO(e, r)
  };
}
function iO(t, e) {
  return typeof t > "u" ? Hg(J0) : (typeof t == "string" && (t = Object.assign(Object.assign({}, Hg(Qf)), { message: t })), typeof e < "u" && (t.data = e), X6(t.code) && (t = eO(t.code)), t);
}
class sO {
}
class oO extends sO {
  constructor() {
    super();
  }
}
class aO extends oO {
  constructor(e) {
    super();
  }
}
const cO = "^wss?:";
function uO(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function lO(t, e) {
  const r = uO(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function Zg(t) {
  return lO(t, cO);
}
function hO(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function rb(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function tp(t) {
  return rb(t) && "method" in t;
}
function fl(t) {
  return rb(t) && (_i(t) || Cn(t));
}
function _i(t) {
  return "result" in t;
}
function Cn(t) {
  return "error" in t;
}
class dO extends aO {
  constructor(e) {
    super(e), this.events = new wn.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(co(e.method, e.params || [], e.id || tb().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (s) {
          i(s);
        }
      this.events.on(`${e.id}`, (s) => {
        Cn(s) ? i(s.error) : n(s.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), fl(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
      type: e.method,
      data: e.params
    });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
const fO = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), pO = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", Yg = (t) => t.split("?")[0], Qg = 10, gO = fO();
class yO {
  constructor(e) {
    if (this.url = e, this.events = new wn.EventEmitter(), this.registering = !1, !Zg(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(gc(e));
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  register(e = this.url) {
    if (!Zg(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return i(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, n) => {
      const i = new URLSearchParams(e).get("origin"), s = eb.isReactNative() ? { headers: { origin: i } } : { rejectUnauthorized: !hO(e) }, a = new gO(e, [], s);
      pO() ? a.onerror = (o) => {
        const l = o;
        n(this.emitError(l.error));
      } : a.on("error", (o) => {
        n(this.emitError(o));
      }), a.onopen = () => {
        this.onOpen(a), r(a);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const r = typeof e.data == "string" ? ol(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = ep(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return tO(e, Yg(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > Qg && this.events.setMaxListeners(Qg);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${Yg(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
}
var _u = { exports: {} };
_u.exports;
(function(t, e) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, a = 9007199254740991, o = "[object Arguments]", l = "[object Array]", u = "[object AsyncFunction]", h = "[object Boolean]", f = "[object Date]", g = "[object Error]", m = "[object Function]", w = "[object GeneratorFunction]", S = "[object Map]", x = "[object Number]", M = "[object Null]", _ = "[object Object]", I = "[object Promise]", b = "[object Proxy]", E = "[object RegExp]", y = "[object Set]", c = "[object String]", p = "[object Symbol]", D = "[object Undefined]", R = "[object WeakMap]", k = "[object ArrayBuffer]", B = "[object DataView]", W = "[object Float32Array]", C = "[object Float64Array]", N = "[object Int8Array]", G = "[object Int16Array]", z = "[object Int32Array]", $ = "[object Uint8Array]", q = "[object Uint8ClampedArray]", U = "[object Uint16Array]", V = "[object Uint32Array]", re = /[\\^$.*+?()[\]{}|]/g, K = /^\[object .+?Constructor\]$/, X = /^(?:0|[1-9]\d*)$/, Y = {};
  Y[W] = Y[C] = Y[N] = Y[G] = Y[z] = Y[$] = Y[q] = Y[U] = Y[V] = !0, Y[o] = Y[l] = Y[k] = Y[h] = Y[B] = Y[f] = Y[g] = Y[m] = Y[S] = Y[x] = Y[_] = Y[E] = Y[y] = Y[c] = Y[R] = !1;
  var ee = typeof Qn == "object" && Qn && Qn.Object === Object && Qn, L = typeof self == "object" && self && self.Object === Object && self, A = ee || L || Function("return this")(), T = e && !e.nodeType && e, d = T && !0 && t && !t.nodeType && t, O = d && d.exports === T, H = O && ee.process, Z = function() {
    try {
      return H && H.binding && H.binding("util");
    } catch {
    }
  }(), me = Z && Z.isTypedArray;
  function we(v, P) {
    for (var F = -1, J = v == null ? 0 : v.length, ke = 0, ce = []; ++F < J; ) {
      var Ge = v[F];
      P(Ge, F, v) && (ce[ke++] = Ge);
    }
    return ce;
  }
  function ye(v, P) {
    for (var F = -1, J = P.length, ke = v.length; ++F < J; )
      v[ke + F] = P[F];
    return v;
  }
  function De(v, P) {
    for (var F = -1, J = v == null ? 0 : v.length; ++F < J; )
      if (P(v[F], F, v))
        return !0;
    return !1;
  }
  function He(v, P) {
    for (var F = -1, J = Array(v); ++F < v; )
      J[F] = P(F);
    return J;
  }
  function Ue(v) {
    return function(P) {
      return v(P);
    };
  }
  function _e(v, P) {
    return v.has(P);
  }
  function be(v, P) {
    return v == null ? void 0 : v[P];
  }
  function de(v) {
    var P = -1, F = Array(v.size);
    return v.forEach(function(J, ke) {
      F[++P] = [ke, J];
    }), F;
  }
  function fe(v, P) {
    return function(F) {
      return v(P(F));
    };
  }
  function ue(v) {
    var P = -1, F = Array(v.size);
    return v.forEach(function(J) {
      F[++P] = J;
    }), F;
  }
  var ae = Array.prototype, oe = Function.prototype, te = Object.prototype, pe = A["__core-js_shared__"], ve = oe.toString, ne = te.hasOwnProperty, Ee = function() {
    var v = /[^.]+$/.exec(pe && pe.keys && pe.keys.IE_PROTO || "");
    return v ? "Symbol(src)_1." + v : "";
  }(), Ie = te.toString, Pe = RegExp(
    "^" + ve.call(ne).replace(re, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Re = O ? A.Buffer : void 0, Te = A.Symbol, At = A.Uint8Array, Ft = te.propertyIsEnumerable, Qt = ae.splice, It = Te ? Te.toStringTag : void 0, er = Object.getOwnPropertySymbols, tr = Re ? Re.isBuffer : void 0, an = fe(Object.keys, Object), We = un(A, "DataView"), Fe = un(A, "Map"), Qe = un(A, "Promise"), Ze = un(A, "Set"), Je = un(A, "WeakMap"), qe = un(Object, "create"), at = Lr(We), lt = Lr(Fe), ht = Lr(Qe), ct = Lr(Ze), dt = Lr(Je), it = Te ? Te.prototype : void 0, Xe = it ? it.valueOf : void 0;
  function je(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.clear(); ++P < F; ) {
      var J = v[P];
      this.set(J[0], J[1]);
    }
  }
  function j() {
    this.__data__ = qe ? qe(null) : {}, this.size = 0;
  }
  function Q(v) {
    var P = this.has(v) && delete this.__data__[v];
    return this.size -= P ? 1 : 0, P;
  }
  function ge(v) {
    var P = this.__data__;
    if (qe) {
      var F = P[v];
      return F === n ? void 0 : F;
    }
    return ne.call(P, v) ? P[v] : void 0;
  }
  function $e(v) {
    var P = this.__data__;
    return qe ? P[v] !== void 0 : ne.call(P, v);
  }
  function mt(v, P) {
    var F = this.__data__;
    return this.size += this.has(v) ? 0 : 1, F[v] = qe && P === void 0 ? n : P, this;
  }
  je.prototype.clear = j, je.prototype.delete = Q, je.prototype.get = ge, je.prototype.has = $e, je.prototype.set = mt;
  function Ke(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.clear(); ++P < F; ) {
      var J = v[P];
      this.set(J[0], J[1]);
    }
  }
  function gt() {
    this.__data__ = [], this.size = 0;
  }
  function ut(v) {
    var P = this.__data__, F = oi(P, v);
    if (F < 0)
      return !1;
    var J = P.length - 1;
    return F == J ? P.pop() : Qt.call(P, F, 1), --this.size, !0;
  }
  function Jt(v) {
    var P = this.__data__, F = oi(P, v);
    return F < 0 ? void 0 : P[F][1];
  }
  function Lt(v) {
    return oi(this.__data__, v) > -1;
  }
  function kt(v, P) {
    var F = this.__data__, J = oi(F, v);
    return J < 0 ? (++this.size, F.push([v, P])) : F[J][1] = P, this;
  }
  Ke.prototype.clear = gt, Ke.prototype.delete = ut, Ke.prototype.get = Jt, Ke.prototype.has = Lt, Ke.prototype.set = kt;
  function Ct(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.clear(); ++P < F; ) {
      var J = v[P];
      this.set(J[0], J[1]);
    }
  }
  function qn() {
    this.size = 0, this.__data__ = {
      hash: new je(),
      map: new (Fe || Ke)(),
      string: new je()
    };
  }
  function Fs(v) {
    var P = ai(this, v).delete(v);
    return this.size -= P ? 1 : 0, P;
  }
  function cn(v) {
    return ai(this, v).get(v);
  }
  function Ul(v) {
    return ai(this, v).has(v);
  }
  function $l(v, P) {
    var F = ai(this, v), J = F.size;
    return F.set(v, P), this.size += F.size == J ? 0 : 1, this;
  }
  Ct.prototype.clear = qn, Ct.prototype.delete = Fs, Ct.prototype.get = cn, Ct.prototype.has = Ul, Ct.prototype.set = $l;
  function si(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.__data__ = new Ct(); ++P < F; )
      this.add(v[P]);
  }
  function Fl(v) {
    return this.__data__.set(v, n), this;
  }
  function ql(v) {
    return this.__data__.has(v);
  }
  si.prototype.add = si.prototype.push = Fl, si.prototype.has = ql;
  function hr(v) {
    var P = this.__data__ = new Ke(v);
    this.size = P.size;
  }
  function zl() {
    this.__data__ = new Ke(), this.size = 0;
  }
  function Vl(v) {
    var P = this.__data__, F = P.delete(v);
    return this.size = P.size, F;
  }
  function Kl(v) {
    return this.__data__.get(v);
  }
  function Bl(v) {
    return this.__data__.has(v);
  }
  function Hl(v, P) {
    var F = this.__data__;
    if (F instanceof Ke) {
      var J = F.__data__;
      if (!Fe || J.length < r - 1)
        return J.push([v, P]), this.size = ++F.size, this;
      F = this.__data__ = new Ct(J);
    }
    return F.set(v, P), this.size = F.size, this;
  }
  hr.prototype.clear = zl, hr.prototype.delete = Vl, hr.prototype.get = Kl, hr.prototype.has = Bl, hr.prototype.set = Hl;
  function Wl(v, P) {
    var F = ci(v), J = !F && ch(v), ke = !F && !J && es(v), ce = !F && !J && !ke && Yo(v), Ge = F || J || ke || ce, yt = Ge ? He(v.length, String) : [], vt = yt.length;
    for (var Be in v)
      (P || ne.call(v, Be)) && !(Ge && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Be == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      ke && (Be == "offset" || Be == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      ce && (Be == "buffer" || Be == "byteLength" || Be == "byteOffset") || // Skip index properties.
      nh(Be, vt))) && yt.push(Be);
    return yt;
  }
  function oi(v, P) {
    for (var F = v.length; F--; )
      if (Ho(v[F][0], P))
        return F;
    return -1;
  }
  function Gl(v, P, F) {
    var J = P(v);
    return ci(v) ? J : ye(J, F(v));
  }
  function Sn(v) {
    return v == null ? v === void 0 ? D : M : It && It in Object(v) ? th(v) : ah(v);
  }
  function zo(v) {
    return On(v) && Sn(v) == o;
  }
  function Vo(v, P, F, J, ke) {
    return v === P ? !0 : v == null || P == null || !On(v) && !On(P) ? v !== v && P !== P : Zl(v, P, F, J, Vo, ke);
  }
  function Zl(v, P, F, J, ke, ce) {
    var Ge = ci(v), yt = ci(P), vt = Ge ? l : dr(v), Be = yt ? l : dr(P);
    vt = vt == o ? _ : vt, Be = Be == o ? _ : Be;
    var Pt = vt == _, qt = Be == _, _t = vt == Be;
    if (_t && es(v)) {
      if (!es(P))
        return !1;
      Ge = !0, Pt = !1;
    }
    if (_t && !Pt)
      return ce || (ce = new hr()), Ge || Yo(v) ? Ko(v, P, F, J, ke, ce) : Xl(v, P, vt, F, J, ke, ce);
    if (!(F & i)) {
      var Mt = Pt && ne.call(v, "__wrapped__"), jt = qt && ne.call(P, "__wrapped__");
      if (Mt || jt) {
        var fr = Mt ? v.value() : v, Xt = jt ? P.value() : P;
        return ce || (ce = new hr()), ke(fr, Xt, F, J, ce);
      }
    }
    return _t ? (ce || (ce = new hr()), eh(v, P, F, J, ke, ce)) : !1;
  }
  function Yl(v) {
    if (!Zo(v) || sh(v))
      return !1;
    var P = Wo(v) ? Pe : K;
    return P.test(Lr(v));
  }
  function Ql(v) {
    return On(v) && Go(v.length) && !!Y[Sn(v)];
  }
  function Jl(v) {
    if (!oh(v))
      return an(v);
    var P = [];
    for (var F in Object(v))
      ne.call(v, F) && F != "constructor" && P.push(F);
    return P;
  }
  function Ko(v, P, F, J, ke, ce) {
    var Ge = F & i, yt = v.length, vt = P.length;
    if (yt != vt && !(Ge && vt > yt))
      return !1;
    var Be = ce.get(v);
    if (Be && ce.get(P))
      return Be == P;
    var Pt = -1, qt = !0, _t = F & s ? new si() : void 0;
    for (ce.set(v, P), ce.set(P, v); ++Pt < yt; ) {
      var Mt = v[Pt], jt = P[Pt];
      if (J)
        var fr = Ge ? J(jt, Mt, Pt, P, v, ce) : J(Mt, jt, Pt, v, P, ce);
      if (fr !== void 0) {
        if (fr)
          continue;
        qt = !1;
        break;
      }
      if (_t) {
        if (!De(P, function(Xt, Mr) {
          if (!_e(_t, Mr) && (Mt === Xt || ke(Mt, Xt, F, J, ce)))
            return _t.push(Mr);
        })) {
          qt = !1;
          break;
        }
      } else if (!(Mt === jt || ke(Mt, jt, F, J, ce))) {
        qt = !1;
        break;
      }
    }
    return ce.delete(v), ce.delete(P), qt;
  }
  function Xl(v, P, F, J, ke, ce, Ge) {
    switch (F) {
      case B:
        if (v.byteLength != P.byteLength || v.byteOffset != P.byteOffset)
          return !1;
        v = v.buffer, P = P.buffer;
      case k:
        return !(v.byteLength != P.byteLength || !ce(new At(v), new At(P)));
      case h:
      case f:
      case x:
        return Ho(+v, +P);
      case g:
        return v.name == P.name && v.message == P.message;
      case E:
      case c:
        return v == P + "";
      case S:
        var yt = de;
      case y:
        var vt = J & i;
        if (yt || (yt = ue), v.size != P.size && !vt)
          return !1;
        var Be = Ge.get(v);
        if (Be)
          return Be == P;
        J |= s, Ge.set(v, P);
        var Pt = Ko(yt(v), yt(P), J, ke, ce, Ge);
        return Ge.delete(v), Pt;
      case p:
        if (Xe)
          return Xe.call(v) == Xe.call(P);
    }
    return !1;
  }
  function eh(v, P, F, J, ke, ce) {
    var Ge = F & i, yt = Bo(v), vt = yt.length, Be = Bo(P), Pt = Be.length;
    if (vt != Pt && !Ge)
      return !1;
    for (var qt = vt; qt--; ) {
      var _t = yt[qt];
      if (!(Ge ? _t in P : ne.call(P, _t)))
        return !1;
    }
    var Mt = ce.get(v);
    if (Mt && ce.get(P))
      return Mt == P;
    var jt = !0;
    ce.set(v, P), ce.set(P, v);
    for (var fr = Ge; ++qt < vt; ) {
      _t = yt[qt];
      var Xt = v[_t], Mr = P[_t];
      if (J)
        var Qo = Ge ? J(Mr, Xt, _t, P, v, ce) : J(Xt, Mr, _t, v, P, ce);
      if (!(Qo === void 0 ? Xt === Mr || ke(Xt, Mr, F, J, ce) : Qo)) {
        jt = !1;
        break;
      }
      fr || (fr = _t == "constructor");
    }
    if (jt && !fr) {
      var ui = v.constructor, li = P.constructor;
      ui != li && "constructor" in v && "constructor" in P && !(typeof ui == "function" && ui instanceof ui && typeof li == "function" && li instanceof li) && (jt = !1);
    }
    return ce.delete(v), ce.delete(P), jt;
  }
  function Bo(v) {
    return Gl(v, hh, rh);
  }
  function ai(v, P) {
    var F = v.__data__;
    return ih(P) ? F[typeof P == "string" ? "string" : "hash"] : F.map;
  }
  function un(v, P) {
    var F = be(v, P);
    return Yl(F) ? F : void 0;
  }
  function th(v) {
    var P = ne.call(v, It), F = v[It];
    try {
      v[It] = void 0;
      var J = !0;
    } catch {
    }
    var ke = Ie.call(v);
    return J && (P ? v[It] = F : delete v[It]), ke;
  }
  var rh = er ? function(v) {
    return v == null ? [] : (v = Object(v), we(er(v), function(P) {
      return Ft.call(v, P);
    }));
  } : dh, dr = Sn;
  (We && dr(new We(new ArrayBuffer(1))) != B || Fe && dr(new Fe()) != S || Qe && dr(Qe.resolve()) != I || Ze && dr(new Ze()) != y || Je && dr(new Je()) != R) && (dr = function(v) {
    var P = Sn(v), F = P == _ ? v.constructor : void 0, J = F ? Lr(F) : "";
    if (J)
      switch (J) {
        case at:
          return B;
        case lt:
          return S;
        case ht:
          return I;
        case ct:
          return y;
        case dt:
          return R;
      }
    return P;
  });
  function nh(v, P) {
    return P = P ?? a, !!P && (typeof v == "number" || X.test(v)) && v > -1 && v % 1 == 0 && v < P;
  }
  function ih(v) {
    var P = typeof v;
    return P == "string" || P == "number" || P == "symbol" || P == "boolean" ? v !== "__proto__" : v === null;
  }
  function sh(v) {
    return !!Ee && Ee in v;
  }
  function oh(v) {
    var P = v && v.constructor, F = typeof P == "function" && P.prototype || te;
    return v === F;
  }
  function ah(v) {
    return Ie.call(v);
  }
  function Lr(v) {
    if (v != null) {
      try {
        return ve.call(v);
      } catch {
      }
      try {
        return v + "";
      } catch {
      }
    }
    return "";
  }
  function Ho(v, P) {
    return v === P || v !== v && P !== P;
  }
  var ch = zo(/* @__PURE__ */ function() {
    return arguments;
  }()) ? zo : function(v) {
    return On(v) && ne.call(v, "callee") && !Ft.call(v, "callee");
  }, ci = Array.isArray;
  function uh(v) {
    return v != null && Go(v.length) && !Wo(v);
  }
  var es = tr || fh;
  function lh(v, P) {
    return Vo(v, P);
  }
  function Wo(v) {
    if (!Zo(v))
      return !1;
    var P = Sn(v);
    return P == m || P == w || P == u || P == b;
  }
  function Go(v) {
    return typeof v == "number" && v > -1 && v % 1 == 0 && v <= a;
  }
  function Zo(v) {
    var P = typeof v;
    return v != null && (P == "object" || P == "function");
  }
  function On(v) {
    return v != null && typeof v == "object";
  }
  var Yo = me ? Ue(me) : Ql;
  function hh(v) {
    return uh(v) ? Wl(v) : Jl(v);
  }
  function dh() {
    return [];
  }
  function fh() {
    return !1;
  }
  t.exports = lh;
})(_u, _u.exports);
var mO = _u.exports;
const vO = /* @__PURE__ */ dc(mO);
function bO(t, e) {
  return e = e || {}, new Promise(function(r, n) {
    var i = new XMLHttpRequest(), s = [], a = [], o = {}, l = function() {
      return { ok: (i.status / 100 | 0) == 2, statusText: i.statusText, status: i.status, url: i.responseURL, text: function() {
        return Promise.resolve(i.responseText);
      }, json: function() {
        return Promise.resolve(i.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([i.response]));
      }, clone: l, headers: { keys: function() {
        return s;
      }, entries: function() {
        return a;
      }, get: function(h) {
        return o[h.toLowerCase()];
      }, has: function(h) {
        return h.toLowerCase() in o;
      } } };
    };
    for (var u in i.open(e.method || "get", t, !0), i.onload = function() {
      i.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(h, f, g) {
        s.push(f = f.toLowerCase()), a.push([f, g]), o[f] = o[f] ? o[f] + "," + g : g;
      }), r(l());
    }, i.onerror = n, i.withCredentials = e.credentials == "include", e.headers)
      i.setRequestHeader(u, e.headers[u]);
    i.send(e.body || null);
  });
}
const wO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: bO
}, Symbol.toStringTag, { value: "Module" })), Jg = /* @__PURE__ */ il(wO);
var _O = fetch || (self.fetch = Jg.default || Jg);
const EO = /* @__PURE__ */ dc(_O);
function SO(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), a = s.charCodeAt(0);
    if (r[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[a] = i;
  }
  var o = t.length, l = t.charAt(0), u = Math.log(o) / Math.log(256), h = Math.log(256) / Math.log(o);
  function f(w) {
    if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer, w.byteOffset, w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))), !(w instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (w.length === 0)
      return "";
    for (var S = 0, x = 0, M = 0, _ = w.length; M !== _ && w[M] === 0; )
      M++, S++;
    for (var I = (_ - M) * h + 1 >>> 0, b = new Uint8Array(I); M !== _; ) {
      for (var E = w[M], y = 0, c = I - 1; (E !== 0 || y < x) && c !== -1; c--, y++)
        E += 256 * b[c] >>> 0, b[c] = E % o >>> 0, E = E / o >>> 0;
      if (E !== 0)
        throw new Error("Non-zero carry");
      x = y, M++;
    }
    for (var p = I - x; p !== I && b[p] === 0; )
      p++;
    for (var D = l.repeat(S); p < I; ++p)
      D += t.charAt(b[p]);
    return D;
  }
  function g(w) {
    if (typeof w != "string")
      throw new TypeError("Expected String");
    if (w.length === 0)
      return new Uint8Array();
    var S = 0;
    if (w[S] !== " ") {
      for (var x = 0, M = 0; w[S] === l; )
        x++, S++;
      for (var _ = (w.length - S) * u + 1 >>> 0, I = new Uint8Array(_); w[S]; ) {
        var b = r[w.charCodeAt(S)];
        if (b === 255)
          return;
        for (var E = 0, y = _ - 1; (b !== 0 || E < M) && y !== -1; y--, E++)
          b += o * I[y] >>> 0, I[y] = b % 256 >>> 0, b = b / 256 >>> 0;
        if (b !== 0)
          throw new Error("Non-zero carry");
        M = E, S++;
      }
      if (w[S] !== " ") {
        for (var c = _ - M; c !== _ && I[c] === 0; )
          c++;
        for (var p = new Uint8Array(x + (_ - c)), D = x; c !== _; )
          p[D++] = I[c++];
        return p;
      }
    }
  }
  function m(w) {
    var S = g(w);
    if (S)
      return S;
    throw new Error(`Non-${e} character`);
  }
  return { encode: f, decodeUnsafe: g, decode: m };
}
var OO = SO, IO = OO;
const nb = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, xO = (t) => new TextEncoder().encode(t), CO = (t) => new TextDecoder().decode(t);
let DO = class {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}, TO = class {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ib(this, e);
  }
}, PO = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ib(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const ib = (t, e) => new PO({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class RO {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new DO(e, r, n), this.decoder = new TO(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const pl = ({ name: t, prefix: e, encode: r, decode: n }) => new RO(t, e, r, n), _c = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = IO(r, e);
  return pl({ prefix: t, name: e, encode: n, decode: (s) => nb(i(s)) });
}, NO = (t, e, r, n) => {
  const i = {};
  for (let h = 0; h < e.length; ++h)
    i[e[h]] = h;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * r / 8 | 0);
  let o = 0, l = 0, u = 0;
  for (let h = 0; h < s; ++h) {
    const f = i[t[h]];
    if (f === void 0)
      throw new SyntaxError(`Non-${n} character`);
    l = l << r | f, o += r, o >= 8 && (o -= 8, a[u++] = 255 & l >> o);
  }
  if (o >= r || 255 & l << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, AO = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", a = 0, o = 0;
  for (let l = 0; l < t.length; ++l)
    for (o = o << 8 | t[l], a += 8; a > r; )
      a -= r, s += e[i & o >> a];
  if (a && (s += e[i & o << r - a]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, yr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => pl({ prefix: e, name: t, encode(i) {
  return AO(i, n, r);
}, decode(i) {
  return NO(i, n, r, t);
} }), LO = pl({ prefix: "\0", name: "identity", encode: (t) => CO(t), decode: (t) => xO(t) });
var MO = Object.freeze({ __proto__: null, identity: LO });
const jO = yr({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var kO = Object.freeze({ __proto__: null, base2: jO });
const UO = yr({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var $O = Object.freeze({ __proto__: null, base8: UO });
const FO = _c({ prefix: "9", name: "base10", alphabet: "0123456789" });
var qO = Object.freeze({ __proto__: null, base10: FO });
const zO = yr({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), VO = yr({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var KO = Object.freeze({ __proto__: null, base16: zO, base16upper: VO });
const BO = yr({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), HO = yr({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), WO = yr({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), GO = yr({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), ZO = yr({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), YO = yr({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), QO = yr({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), JO = yr({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), XO = yr({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var e2 = Object.freeze({ __proto__: null, base32: BO, base32upper: HO, base32pad: WO, base32padupper: GO, base32hex: ZO, base32hexupper: YO, base32hexpad: QO, base32hexpadupper: JO, base32z: XO });
const t2 = _c({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), r2 = _c({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var n2 = Object.freeze({ __proto__: null, base36: t2, base36upper: r2 });
const i2 = _c({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), s2 = _c({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var o2 = Object.freeze({ __proto__: null, base58btc: i2, base58flickr: s2 });
const a2 = yr({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), c2 = yr({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), u2 = yr({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), l2 = yr({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var h2 = Object.freeze({ __proto__: null, base64: a2, base64pad: c2, base64url: u2, base64urlpad: l2 });
const sb = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), d2 = sb.reduce((t, e, r) => (t[r] = e, t), []), f2 = sb.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function p2(t) {
  return t.reduce((e, r) => (e += d2[r], e), "");
}
function g2(t) {
  const e = [];
  for (const r of t) {
    const n = f2[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const y2 = pl({ prefix: "🚀", name: "base256emoji", encode: p2, decode: g2 });
var m2 = Object.freeze({ __proto__: null, base256emoji: y2 }), v2 = ob, Xg = 128, b2 = 127, w2 = ~b2, _2 = Math.pow(2, 31);
function ob(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= _2; )
    e[r++] = t & 255 | Xg, t /= 128;
  for (; t & w2; )
    e[r++] = t & 255 | Xg, t >>>= 7;
  return e[r] = t | 0, ob.bytes = r - n + 1, e;
}
var E2 = Sd, S2 = 128, ey = 127;
function Sd(t, n) {
  var r = 0, n = n || 0, i = 0, s = n, a, o = t.length;
  do {
    if (s >= o)
      throw Sd.bytes = 0, new RangeError("Could not decode varint");
    a = t[s++], r += i < 28 ? (a & ey) << i : (a & ey) * Math.pow(2, i), i += 7;
  } while (a >= S2);
  return Sd.bytes = s - n, r;
}
var O2 = Math.pow(2, 7), I2 = Math.pow(2, 14), x2 = Math.pow(2, 21), C2 = Math.pow(2, 28), D2 = Math.pow(2, 35), T2 = Math.pow(2, 42), P2 = Math.pow(2, 49), R2 = Math.pow(2, 56), N2 = Math.pow(2, 63), A2 = function(t) {
  return t < O2 ? 1 : t < I2 ? 2 : t < x2 ? 3 : t < C2 ? 4 : t < D2 ? 5 : t < T2 ? 6 : t < P2 ? 7 : t < R2 ? 8 : t < N2 ? 9 : 10;
}, L2 = { encode: v2, decode: E2, encodingLength: A2 }, ab = L2;
const ty = (t, e, r = 0) => (ab.encode(t, e, r), e), ry = (t) => ab.encodingLength(t), Od = (t, e) => {
  const r = e.byteLength, n = ry(t), i = n + ry(r), s = new Uint8Array(i + r);
  return ty(t, s, 0), ty(r, s, n), s.set(e, i), new M2(t, r, e, s);
};
let M2 = class {
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
};
const cb = ({ name: t, code: e, encode: r }) => new j2(t, e, r);
let j2 = class {
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? Od(this.code, r) : r.then((n) => Od(this.code, n));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
const ub = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), k2 = cb({ name: "sha2-256", code: 18, encode: ub("SHA-256") }), U2 = cb({ name: "sha2-512", code: 19, encode: ub("SHA-512") });
var $2 = Object.freeze({ __proto__: null, sha256: k2, sha512: U2 });
const lb = 0, F2 = "identity", hb = nb, q2 = (t) => Od(lb, hb(t)), z2 = { code: lb, name: F2, encode: hb, digest: q2 };
var V2 = Object.freeze({ __proto__: null, identity: z2 });
new TextEncoder(), new TextDecoder();
const ny = { ...MO, ...kO, ...$O, ...qO, ...KO, ...e2, ...n2, ...o2, ...h2, ...m2 };
({ ...$2, ...V2 });
function db(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function K2(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? db(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function fb(t, e, r, n) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
}
const iy = fb("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Th = fb("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = K2(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), B2 = { utf8: iy, "utf-8": iy, hex: ny.base16, latin1: Th, ascii: Th, binary: Th, ...ny };
function H2(t, e = "utf8") {
  const r = B2[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? db(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
const pb = "wc", W2 = 2, rp = "core", $i = `${pb}@2:${rp}:`, G2 = { name: rp, logger: "error" }, Z2 = { database: ":memory:" }, Y2 = "crypto", sy = "client_ed25519_seed", Q2 = Ne.ONE_DAY, J2 = "keychain", X2 = "0.3", eI = "messages", tI = "0.3", rI = Ne.SIX_HOURS, nI = "publisher", gb = "irn", iI = "error", yb = "wss://relay.walletconnect.com", oy = "wss://relay.walletconnect.org", sI = "relayer", Tr = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, oI = "_subscription", fi = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, aI = Ne.ONE_SECOND, cI = "2.11.1", uI = 1e4, lI = "0.3", hI = "WALLETCONNECT_CLIENT_ID", In = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, dI = "subscription", fI = "0.3", pI = Ne.FIVE_SECONDS * 1e3, gI = "pairing", yI = "0.3", na = { wc_pairingDelete: { req: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: Ne.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: Ne.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: Ne.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: Ne.ONE_DAY, prompt: !1, tag: 0 } } }, pa = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, Bn = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, mI = "history", vI = "0.3", bI = "expirer", mn = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, wI = "0.3", Ph = "verify-api", ro = "https://verify.walletconnect.com", Id = "https://verify.walletconnect.org", _I = [ro, Id], EI = "echo", SI = "https://echo.walletconnect.com";
class OI {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = J2, this.version = X2, this.initialized = !1, this.storagePrefix = $i, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, i) => {
      this.isInitialized(), this.keychain.set(n, i), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.keychain.get(n);
      if (typeof i > "u") {
        const { message: s } = le("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(s);
      }
      return i;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = e, this.logger = bt.generateChildLogger(r, this.name);
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, H0(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? W0(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
let II = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.name = Y2, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(), s = Sg(i);
      return A0(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = N5();
      return this.setPrivateKey(i.publicKey, i.privateKey);
    }, this.signJWT = async (i) => {
      this.isInitialized();
      const s = await this.getClientSeed(), a = Sg(s), o = _d();
      return await F3(o, i, Q2, a);
    }, this.generateSharedKey = (i, s, a) => {
      this.isInitialized();
      const o = this.getPrivateKey(i), l = A5(o, s);
      return this.setSymKey(l, a);
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const a = s || L5(i);
      return await this.keychain.set(a, i), a;
    }, this.deleteKeyPair = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.deleteSymKey = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.encode = async (i, s, a) => {
      this.isInitialized();
      const o = B0(a), l = gc(s);
      if (Lg(o)) {
        const g = o.senderPublicKey, m = o.receiverPublicKey;
        i = await this.generateSharedKey(g, m);
      }
      const u = this.getSymKey(i), { type: h, senderPublicKey: f } = o;
      return j5({ type: h, symKey: u, message: l, senderPublicKey: f });
    }, this.decode = async (i, s, a) => {
      this.isInitialized();
      const o = $5(s, a);
      if (Lg(o)) {
        const l = o.receiverPublicKey, u = o.senderPublicKey;
        i = await this.generateSharedKey(l, u);
      }
      try {
        const l = this.getSymKey(i), u = k5({ symKey: l, encoded: s });
        return ol(u);
      } catch (l) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(l);
      }
    }, this.getPayloadType = (i) => {
      const s = vu(i);
      return vc(s.type);
    }, this.getPayloadSenderPublicKey = (i) => {
      const s = vu(i);
      return s.senderPublicKey ? Gr(s.senderPublicKey, Hr) : void 0;
    }, this.core = e, this.logger = bt.generateChildLogger(r, this.name), this.keychain = n || new OI(this.core, this.logger);
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(sy);
    } catch {
      e = _d(), await this.keychain.set(sy, e);
    }
    return H2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, xI = class extends KE {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = eI, this.version = tI, this.initialized = !1, this.storagePrefix = $i, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, i) => {
      this.isInitialized();
      const s = ao(i);
      let a = this.messages.get(n);
      return typeof a > "u" && (a = {}), typeof a[s] < "u" || (a[s] = i, this.messages.set(n, a), await this.persist()), s;
    }, this.get = (n) => {
      this.isInitialized();
      let i = this.messages.get(n);
      return typeof i > "u" && (i = {}), i;
    }, this.has = (n, i) => {
      this.isInitialized();
      const s = this.get(n), a = ao(i);
      return typeof s[a] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = bt.generateChildLogger(e, this.name), this.core = r;
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, H0(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? W0(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class CI extends BE {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new wn.EventEmitter(), this.name = nI, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = Ne.toMiliseconds(Ne.TEN_SECONDS * 2), this.needsTransportRestart = !1, this.publish = async (n, i, s) => {
      var a;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      try {
        const o = (s == null ? void 0 : s.ttl) || rI, l = Ed(s), u = (s == null ? void 0 : s.prompt) || !1, h = (s == null ? void 0 : s.tag) || 0, f = (s == null ? void 0 : s.id) || tb().toString(), g = { topic: n, message: i, opts: { ttl: o, relay: l, prompt: u, tag: h, id: f } }, m = setTimeout(() => this.queue.set(f, g), this.publishTimeout);
        try {
          await await Da(this.rpcPublish(n, i, o, l, u, h, f), this.publishTimeout, `Failed to publish payload, please try again. id:${f} tag:${h}`), this.removeRequestFromQueue(f), this.relayer.events.emit(Tr.publish, g);
        } catch (w) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (a = s == null ? void 0 : s.internal) != null && a.throwOnFailedPublish)
            throw this.removeRequestFromQueue(f), w;
          return;
        } finally {
          clearTimeout(m);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      } catch (o) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o), o;
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.relayer = e, this.logger = bt.generateChildLogger(r, this.name), this.registerEventListeners();
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  rpcPublish(e, r, n, i, s, a, o) {
    var l, u, h, f;
    const g = { method: su(i.protocol).publish, params: { topic: e, message: r, ttl: n, prompt: s, tag: a }, id: o };
    return zr((l = g.params) == null ? void 0 : l.prompt) && ((u = g.params) == null || delete u.prompt), zr((h = g.params) == null ? void 0 : h.tag) && ((f = g.params) == null || delete f.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: g }), this.relayer.request(g);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: n, opts: i } = e;
      await this.publish(r, n, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(To.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(Tr.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(Tr.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
let DI = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const n = this.get(e);
      this.exists(e, r) || this.map.set(e, [...n, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const n = this.get(e);
      if (!this.exists(e, r))
        return;
      const i = n.filter((s) => s !== r);
      if (!i.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var TI = Object.defineProperty, PI = Object.defineProperties, RI = Object.getOwnPropertyDescriptors, ay = Object.getOwnPropertySymbols, NI = Object.prototype.hasOwnProperty, AI = Object.prototype.propertyIsEnumerable, cy = (t, e, r) => e in t ? TI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ia = (t, e) => {
  for (var r in e || (e = {}))
    NI.call(e, r) && cy(t, r, e[r]);
  if (ay)
    for (var r of ay(e))
      AI.call(e, r) && cy(t, r, e[r]);
  return t;
}, Rh = (t, e) => PI(t, RI(e));
let LI = class extends GE {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new DI(), this.events = new wn.EventEmitter(), this.name = dI, this.version = fI, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = $i, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } });
      try {
        const s = Ed(i), a = { topic: n, relay: s };
        this.pending.set(n, a);
        const o = await this.rpcSubscribe(n, s);
        return this.onSubscribe(o, a), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } }), o;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i);
    }, this.isSubscribed = async (n) => {
      if (this.topics.includes(n))
        return !0;
      const i = `${this.pendingSubscriptionWatchLabel}_${n}`;
      return await new Promise((s, a) => {
        const o = new Ne.Watch();
        o.start(i);
        const l = setInterval(() => {
          !this.pending.has(n) && this.topics.includes(n) && (clearInterval(l), o.stop(i), s(!0)), o.elapsed(i) >= pI && (clearInterval(l), o.stop(i), a(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = bt.generateChildLogger(r, this.name), this.clientId = "";
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === r;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (i) => await this.unsubscribeById(e, i, r)));
  }
  async unsubscribeById(e, r, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    try {
      const i = Ed(n);
      await this.rpcUnsubscribe(e, r, i);
      const s = zt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i;
    }
  }
  async rpcSubscribe(e, r) {
    const n = { method: su(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      await await Da(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Tr.connection_stalled);
    }
    return ao(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const r = e[0].relay, n = { method: su(r.protocol).batchSubscribe, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await Da(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(Tr.connection_stalled);
    }
  }
  rpcUnsubscribe(e, r, n) {
    const i = { method: su(n.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i }), this.relayer.request(i);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, Rh(ia({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, ia({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, n) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r));
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, ia({}, r)), this.topicMap.set(r.topic, e), this.events.emit(In.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: n } = le("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(In.deleted, Rh(ia({}, n), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(In.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(n);
      }
    }
    this.events.emit(In.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: r } = le("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const r = await this.rpcBatchSubscribe(e);
    wc(r) && this.onBatchSubscribe(r.map((n, i) => Rh(ia({}, e[i]), { id: n })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(To.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(Tr.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(Tr.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(In.created, async (e) => {
      const r = In.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(In.deleted, async (e) => {
      const r = In.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
};
var MI = Object.defineProperty, uy = Object.getOwnPropertySymbols, jI = Object.prototype.hasOwnProperty, kI = Object.prototype.propertyIsEnumerable, ly = (t, e, r) => e in t ? MI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, UI = (t, e) => {
  for (var r in e || (e = {}))
    jI.call(e, r) && ly(t, r, e[r]);
  if (uy)
    for (var r of uy(e))
      kI.call(e, r) && ly(t, r, e[r]);
  return t;
};
class $I extends HE {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new wn.EventEmitter(), this.name = sI, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.request = async (r) => {
      this.logger.debug("Publishing Request Payload");
      const n = r.id, i = this.provider.request(r);
      this.requestsInFlight.set(n, { promise: i, request: r });
      try {
        return await this.toEstablishConnection(), await i;
      } catch (s) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(s), s;
      } finally {
        this.requestsInFlight.delete(n);
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r);
    }, this.onConnectHandler = () => {
      this.events.emit(Tr.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(Tr.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(fi.payload, this.onPayloadHandler), this.provider.on(fi.connect, this.onConnectHandler), this.provider.on(fi.disconnect, this.onDisconnectHandler), this.provider.on(fi.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? bt.generateChildLogger(e.logger, this.name) : bt.pino(bt.getDefaultLoggerOptions({ level: e.logger || iI })), this.messages = new xI(this.logger, e.core), this.subscriber = new LI(this, this.logger), this.publisher = new CI(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || yb, this.projectId = e.projectId, this.bundleId = B5(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${oy}...`), await this.restartTransport(oy);
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, uI);
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, r, n) {
    this.isInitialized(), await this.publisher.publish(e, r, n), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now() });
  }
  async subscribe(e, r) {
    var n;
    this.isInitialized();
    let i = ((n = this.subscriber.topicMap.get(e)) == null ? void 0 : n[0]) || "";
    if (i)
      return i;
    let s;
    const a = (o) => {
      o.topic === e && (this.subscriber.off(In.created, a), s());
    };
    return await Promise.all([new Promise((o) => {
      s = o, this.subscriber.on(In.created, a);
    }), new Promise(async (o) => {
      i = await this.subscriber.subscribe(e, r), o();
    })]), i;
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportClose() {
    this.requestsInFlight.size > 0 && (this.logger.debug("Waiting for all in-flight requests to finish before closing transport..."), this.requestsInFlight.forEach(async (e) => {
      await e.promise;
    })), this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await Da(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
      try {
        await Promise.all([new Promise((r) => {
          if (!this.initialized)
            return r();
          this.subscriber.once(In.resubscribed, () => {
            r();
          });
        }), new Promise(async (r, n) => {
          try {
            await Da(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (i) {
            n(i);
            return;
          }
          r();
        })]);
      } catch (r) {
        this.logger.error(r);
        const n = r;
        if (!this.isConnectionStalled(n.message))
          throw r;
        this.provider.events.emit(fi.disconnect);
      } finally {
        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Bg())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new dO(new yO(Q5({ sdkVersion: cI, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: n } = e;
    await this.messages.set(r, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: n } = e;
    if (!n || n.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isSubscribed(r))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const i = this.messages.has(r, n);
    return i && this.logger.debug(`Ignoring duplicate message: ${n}`), i;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), tp(e)) {
      if (!e.method.endsWith(oI))
        return;
      const r = e.params, { topic: n, message: i, publishedAt: s } = r.data, a = { topic: n, message: i, publishedAt: s };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(UI({ type: "event", event: r.id }, a)), this.events.emit(r.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else
      fl(e) && this.events.emit(Tr.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(Tr.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = Xf(e.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off(fi.payload, this.onPayloadHandler), this.provider.off(fi.connect, this.onConnectHandler), this.provider.off(fi.disconnect, this.onDisconnectHandler), this.provider.off(fi.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(Tr.connection_stalled, () => {
      this.restartTransport().catch((r) => this.logger.error(r));
    });
    let e = await Bg();
    B6(async (r) => {
      this.initialized && e !== r && (e = r, r ? await this.restartTransport().catch((n) => this.logger.error(n)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((n) => this.logger.error(n))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(Tr.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, Ne.toMiliseconds(aI)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const r = setInterval(() => {
            this.connected && (clearInterval(r), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
}
var FI = Object.defineProperty, hy = Object.getOwnPropertySymbols, qI = Object.prototype.hasOwnProperty, zI = Object.prototype.propertyIsEnumerable, dy = (t, e, r) => e in t ? FI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, fy = (t, e) => {
  for (var r in e || (e = {}))
    qI.call(e, r) && dy(t, r, e[r]);
  if (hy)
    for (var r of hy(e))
      zI.call(e, r) && dy(t, r, e[r]);
  return t;
};
class gl extends WE {
  constructor(e, r, n, i = $i, s = void 0) {
    super(e, r, n, i), this.core = e, this.logger = r, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = lI, this.cached = [], this.initialized = !1, this.storagePrefix = $i, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a) => {
        this.getKey && a !== null && !zr(a) ? this.map.set(this.getKey(a), a) : E6(a) ? this.map.set(a.id, a) : S6(a) && this.map.set(a.topic, a);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (a, o) => {
      this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a, value: o }), this.map.set(a, o), await this.persist());
    }, this.get = (a) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a }), this.getData(a)), this.getAll = (a) => (this.isInitialized(), a ? this.values.filter((o) => Object.keys(a).every((l) => vO(o[l], a[l]))) : this.values), this.update = async (a, o) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a, update: o });
      const l = fy(fy({}, this.getData(a)), o);
      this.map.set(a, l), await this.persist();
    }, this.delete = async (a, o) => {
      this.isInitialized(), this.map.has(a) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a, reason: o }), this.map.delete(a), await this.persist());
    }, this.logger = bt.generateChildLogger(r, this.name), this.storagePrefix = i, this.getKey = s;
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      const { message: n } = le("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: r } = le("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class VI {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = gI, this.version = yI, this.events = new fc(), this.initialized = !1, this.storagePrefix = $i, this.ignoredPayloadTypes = [Ls], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async () => {
      this.isInitialized();
      const n = _d(), i = await this.core.crypto.setSymKey(n), s = hn(Ne.FIVE_MINUTES), a = { protocol: gb }, o = { topic: i, expiry: s, relay: a, active: !1 }, l = f6({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: n, relay: a, expiryTimestamp: s });
      return await this.pairings.set(i, o), await this.core.relayer.subscribe(i), this.core.expirer.set(i, s), { topic: i, uri: l };
    }, this.pair = async (n) => {
      this.isInitialized(), this.isValidPair(n);
      const { topic: i, symKey: s, relay: a, expiryTimestamp: o } = Fg(n.uri);
      let l;
      if (this.pairings.keys.includes(i) && (l = this.pairings.get(i), l.active))
        throw new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
      const u = o || hn(Ne.FIVE_MINUTES), h = { topic: i, relay: a, expiry: u, active: !1 };
      return await this.pairings.set(i, h), this.core.expirer.set(i, u), n.activatePairing && await this.activate({ topic: i }), this.events.emit(pa.create, h), this.core.crypto.keychain.has(i) || (await this.core.crypto.setSymKey(s, i), await this.core.relayer.subscribe(i, { relay: a })), h;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const i = hn(Ne.THIRTY_DAYS);
      await this.pairings.update(n, { active: !0, expiry: i }), this.core.expirer.set(n, i);
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: i } = n;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}), { done: a, resolve: o, reject: l } = Ys();
        this.events.once(Ht("pairing_ping", s), ({ error: u }) => {
          u ? l(u) : o();
        }), await a();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: i }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: i });
    }, this.updateMetadata = async ({ topic: n, metadata: i }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: i });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: i } = n;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", zt("USER_DISCONNECTED")), await this.deletePairing(i));
    }, this.sendRequest = async (n, i, s) => {
      const a = co(i, s), o = await this.core.crypto.encode(n, a), l = na[i].req;
      return this.core.history.set(n, a), this.core.relayer.publish(n, o, l), a.id;
    }, this.sendResult = async (n, i, s) => {
      const a = Xf(n, s), o = await this.core.crypto.encode(i, a), l = await this.core.history.get(i, n), u = na[l.request.method].res;
      await this.core.relayer.publish(i, o, u), await this.core.history.resolve(a);
    }, this.sendError = async (n, i, s) => {
      const a = ep(n, s), o = await this.core.crypto.encode(i, a), l = await this.core.history.get(i, n), u = na[l.request.method] ? na[l.request.method].res : na.unregistered_method.res;
      await this.core.relayer.publish(i, o, u), await this.core.history.resolve(a);
    }, this.deletePairing = async (n, i) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, zt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((i) => Ri(i.expiry));
      await Promise.all(n.map((i) => this.deletePairing(i.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: i, payload: s } = n;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s);
      }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: i, payload: s } = n, a = (await this.core.history.get(i, s.id)).request.method;
      switch (a) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(a);
      }
    }, this.onPairingPingRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(s, n, !0), this.events.emit(pa.ping, { id: s, topic: n });
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onPairingPingResponse = (n, i) => {
      const { id: s } = i;
      setTimeout(() => {
        _i(i) ? this.events.emit(Ht("pairing_ping", s), {}) : Cn(i) && this.events.emit(Ht("pairing_ping", s), { error: i.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(pa.delete, { id: s, topic: n });
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodRequest = async (n, i) => {
      const { id: s, method: a } = i;
      try {
        if (this.registeredMethods.includes(a))
          return;
        const o = zt("WC_METHOD_UNSUPPORTED", a);
        await this.sendError(s, n, o), this.logger.error(o);
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(zt("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n) => {
      var i;
      if (!tn(n)) {
        const { message: a } = le("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw new Error(a);
      }
      if (!_6(n.uri)) {
        const { message: a } = le("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw new Error(a);
      }
      const s = Fg(n.uri);
      if (!((i = s == null ? void 0 : s.relay) != null && i.protocol)) {
        const { message: a } = le("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(a);
      }
      if (!(s != null && s.symKey)) {
        const { message: a } = le("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(a);
      }
      if (s != null && s.expiryTimestamp && Ne.toMiliseconds(s == null ? void 0 : s.expiryTimestamp) < Date.now()) {
        const { message: a } = le("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }, this.isValidPing = async (n) => {
      if (!tn(n)) {
        const { message: s } = le("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidDisconnect = async (n) => {
      if (!tn(n)) {
        const { message: s } = le("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidPairingTopic = async (n) => {
      if (!cr(n, !1)) {
        const { message: i } = le("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(i);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: i } = le("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(i);
      }
      if (Ri(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: i } = le("EXPIRED", `pairing topic: ${n}`);
        throw new Error(i);
      }
    }, this.core = e, this.logger = bt.generateChildLogger(r, this.name), this.pairings = new gl(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(Tr.message, async (e) => {
      const { topic: r, message: n } = e;
      if (!this.pairings.keys.includes(r) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n)))
        return;
      const i = await this.core.crypto.decode(r, n);
      try {
        tp(i) ? (this.core.history.set(r, i), this.onRelayEventRequest({ topic: r, payload: i })) : fl(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({ topic: r, payload: i }), this.core.history.delete(r, i.id));
      } catch (s) {
        this.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(mn.expired, async (e) => {
      const { topic: r } = Z0(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(pa.expire, { topic: r }));
    });
  }
}
let KI = class extends VE {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new wn.EventEmitter(), this.name = mI, this.version = vI, this.cached = [], this.initialized = !1, this.storagePrefix = $i, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, i, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: i, chainId: s }), this.records.has(i.id))
        return;
      const a = { id: i.id, topic: n, request: { method: i.method, params: i.params || null }, chainId: s, expiry: hn(Ne.THIRTY_DAYS) };
      this.records.set(a.id, a), this.events.emit(Bn.created, a);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id))
        return;
      const i = await this.getRecord(n.id);
      typeof i.response > "u" && (i.response = Cn(n) ? { error: n.error } : { result: n.result }, this.records.set(i.id, i), this.events.emit(Bn.updated, i));
    }, this.get = async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: i }), await this.getRecord(i)), this.delete = (n, i) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i }), this.values.forEach((s) => {
        if (s.topic === n) {
          if (typeof i < "u" && s.id !== i)
            return;
          this.records.delete(s.id), this.events.emit(Bn.deleted, s);
        }
      });
    }, this.exists = async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = bt.generateChildLogger(r, this.name);
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u")
        return;
      const n = { topic: r.topic, request: co(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: n } = le("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Bn.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: r } = le("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Bn.created, (e) => {
      const r = Bn.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Bn.updated, (e) => {
      const r = Bn.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Bn.deleted, (e) => {
      const r = Bn.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.core.heartbeat.on(To.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        Ne.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, BI = class extends ZE {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new wn.EventEmitter(), this.name = bI, this.version = wI, this.cached = [], this.initialized = !1, this.storagePrefix = $i, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const i = this.formatTarget(n);
        return typeof this.getExpiration(i) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, i) => {
      this.isInitialized();
      const s = this.formatTarget(n), a = { target: s, expiry: i };
      this.expirations.set(s, a), this.checkExpiry(s, a), this.events.emit(mn.created, { target: s, expiration: a });
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.formatTarget(n);
      return this.getExpiration(i);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const i = this.formatTarget(n), s = this.getExpiration(i);
        this.expirations.delete(i), this.events.emit(mn.deleted, { target: i, expiration: s });
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = bt.generateChildLogger(r, this.name);
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return J5(e);
    if (typeof e == "number")
      return X5(e);
    const { message: r } = le("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(mn.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: r } = le("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: n } = le("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: n } = r;
    Ne.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(mn.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(To.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(mn.created, (e) => {
      const r = mn.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(mn.expired, (e) => {
      const r = mn.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(mn.deleted, (e) => {
      const r = mn.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class HI extends YE {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.name = Ph, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (n) => {
      if (this.verifyDisabled || No() || !Ao())
        return;
      const i = this.getVerifyUrl(n == null ? void 0 : n.verifyUrl);
      this.verifyUrl !== i && this.removeIframe(), this.verifyUrl = i;
      try {
        await this.createIframe();
      } catch (s) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = Id;
        try {
          await this.createIframe();
        } catch (s) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s), this.verifyDisabled = !0;
        }
      }
    }, this.register = async (n) => {
      this.initialized ? this.sendPost(n.attestationId) : (this.addToQueue(n.attestationId), await this.init());
    }, this.resolve = async (n) => {
      if (this.isDevEnv)
        return "";
      const i = this.getVerifyUrl(n == null ? void 0 : n.verifyUrl);
      let s;
      try {
        s = await this.fetchAttestation(n.attestationId, i);
      } catch (a) {
        this.logger.info(`failed to resolve attestation: ${n.attestationId} from url: ${i}`), this.logger.info(a), s = await this.fetchAttestation(n.attestationId, Id);
      }
      return s;
    }, this.fetchAttestation = async (n, i) => {
      this.logger.info(`resolving attestation: ${n} from url: ${i}`);
      const s = this.startAbortTimer(Ne.ONE_SECOND * 2), a = await fetch(`${i}/attestation/${n}`, { signal: this.abortController.signal });
      return clearTimeout(s), a.status === 200 ? await a.json() : void 0;
    }, this.addToQueue = (n) => {
      this.queue.push(n);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((n) => this.sendPost(n)), this.queue = []);
    }, this.sendPost = (n) => {
      var i;
      try {
        if (!this.iframe)
          return;
        (i = this.iframe.contentWindow) == null || i.postMessage(n, "*"), this.logger.info(`postMessage sent: ${n} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let n;
      const i = (s) => {
        s.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", i), n());
      };
      await Promise.race([new Promise((s) => {
        if (document.getElementById(Ph))
          return s();
        window.addEventListener("message", i);
        const a = document.createElement("iframe");
        a.id = Ph, a.src = `${this.verifyUrl}/${this.projectId}`, a.style.display = "none", document.body.append(a), this.iframe = a, n = s;
      }), new Promise((s, a) => setTimeout(() => {
        window.removeEventListener("message", i), a("verify iframe load timeout");
      }, Ne.toMiliseconds(Ne.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);
    }, this.getVerifyUrl = (n) => {
      let i = n || ro;
      return _I.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${ro}`), i = ro), i;
    }, this.logger = bt.generateChildLogger(r, this.name), this.verifyUrl = ro, this.abortController = new AbortController(), this.isDevEnv = Zf() && process.env.IS_VITEST;
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), Ne.toMiliseconds(e));
  }
}
let WI = class extends QE {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.context = EI, this.registerDeviceToken = async (n) => {
      const { clientId: i, token: s, notificationType: a, enableEncrypted: o = !1 } = n, l = `${SI}/${this.projectId}/clients`;
      await EO(l, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i, type: a, token: s, always_raw: o }) });
    }, this.logger = bt.generateChildLogger(r, this.context);
  }
};
var GI = Object.defineProperty, py = Object.getOwnPropertySymbols, ZI = Object.prototype.hasOwnProperty, YI = Object.prototype.propertyIsEnumerable, gy = (t, e, r) => e in t ? GI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, yy = (t, e) => {
  for (var r in e || (e = {}))
    ZI.call(e, r) && gy(t, r, e[r]);
  if (py)
    for (var r of py(e))
      YI.call(e, r) && gy(t, r, e[r]);
  return t;
};
let QI = class mb extends zE {
  constructor(e) {
    super(e), this.protocol = pb, this.version = W2, this.name = rp, this.events = new wn.EventEmitter(), this.initialized = !1, this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || yb, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : bt.pino(bt.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || G2.logger }));
    this.logger = bt.generateChildLogger(r, this.name), this.heartbeat = new To.HeartBeat(), this.crypto = new II(this, this.logger, e == null ? void 0 : e.keychain), this.history = new KI(this, this.logger), this.expirer = new BI(this, this.logger), this.storage = e != null && e.storage ? e.storage : new sE(yy(yy({}, Z2), e == null ? void 0 : e.storageOptions)), this.relayer = new $I({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new VI(this, this.logger), this.verify = new HI(this.projectId || "", this.logger), this.echoClient = new WI(this.projectId || "", this.logger);
  }
  static async init(e) {
    const r = new mb(e);
    await r.initialize();
    const n = await r.crypto.getClientId();
    return await r.storage.setItem(hI, n), r;
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
const JI = QI, vb = "wc", bb = 2, wb = "client", np = `${vb}@${bb}:${wb}:`, Nh = { name: wb, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, my = "WALLETCONNECT_DEEPLINK_CHOICE", XI = "proposal", ex = "Proposal expired", tx = "session", zc = Ne.SEVEN_DAYS, rx = "engine", pi = { wc_sessionPropose: { req: { ttl: Ne.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: Ne.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: Ne.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: Ne.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: Ne.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: Ne.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: Ne.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: Ne.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: Ne.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: Ne.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: Ne.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Ah = { min: Ne.FIVE_MINUTES, max: Ne.SEVEN_DAYS }, gi = { idle: "IDLE", active: "ACTIVE" }, nx = "request", ix = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var sx = Object.defineProperty, ox = Object.defineProperties, ax = Object.getOwnPropertyDescriptors, vy = Object.getOwnPropertySymbols, cx = Object.prototype.hasOwnProperty, ux = Object.prototype.propertyIsEnumerable, by = (t, e, r) => e in t ? sx(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, kr = (t, e) => {
  for (var r in e || (e = {}))
    cx.call(e, r) && by(t, r, e[r]);
  if (vy)
    for (var r of vy(e))
      ux.call(e, r) && by(t, r, e[r]);
  return t;
}, Vs = (t, e) => ox(t, ax(e));
let lx = class extends XE {
  constructor(e) {
    super(e), this.name = rx, this.events = new fc(), this.initialized = !1, this.ignoredPayloadTypes = [Ls], this.requestQueue = { state: gi.idle, queue: [] }, this.sessionRequestQueue = { state: gi.idle, queue: [] }, this.requestQueueDelay = Ne.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(pi) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, Ne.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      await this.isInitialized();
      const n = Vs(kr({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: a, sessionProperties: o, relays: l } = n;
      let u = i, h, f = !1;
      if (u && (f = this.client.core.pairing.pairings.get(u).active), !u || !f) {
        const { topic: b, uri: E } = await this.client.core.pairing.create();
        u = b, h = E;
      }
      const g = await this.client.core.crypto.generateKeyPair(), m = pi.wc_sessionPropose.req.ttl || Ne.FIVE_MINUTES, w = hn(m), S = kr({ requiredNamespaces: s, optionalNamespaces: a, relays: l ?? [{ protocol: gb }], proposer: { publicKey: g, metadata: this.client.metadata }, expiryTimestamp: w }, o && { sessionProperties: o }), { reject: x, resolve: M, done: _ } = Ys(m, ex);
      if (this.events.once(Ht("session_connect"), async ({ error: b, session: E }) => {
        if (b)
          x(b);
        else if (E) {
          E.self.publicKey = g;
          const y = Vs(kr({}, E), { requiredNamespaces: S.requiredNamespaces, optionalNamespaces: S.optionalNamespaces });
          await this.client.session.set(E.topic, y), await this.setExpiry(E.topic, E.expiry), u && await this.client.core.pairing.updateMetadata({ topic: u, metadata: E.peer.metadata }), M(y);
        }
      }), !u) {
        const { message: b } = le("NO_MATCHING_KEY", `connect() pairing topic: ${u}`);
        throw new Error(b);
      }
      const I = await this.sendRequest({ topic: u, method: "wc_sessionPropose", params: S, throwOnFailedPublish: !0 });
      return await this.setProposal(I, kr({ id: I }, S)), { uri: h, approval: _ };
    }, this.pair = async (r) => (await this.isInitialized(), await this.client.core.pairing.pair(r)), this.approve = async (r) => {
      await this.isInitialized(), await this.isValidApprove(r);
      const { id: n, relayProtocol: i, namespaces: s, sessionProperties: a } = r, o = this.client.proposal.get(n);
      let { pairingTopic: l, proposer: u, requiredNamespaces: h, optionalNamespaces: f } = o;
      l = l || "";
      const g = await this.client.core.crypto.generateKeyPair(), m = u.publicKey, w = await this.client.core.crypto.generateSharedKey(g, m);
      l && n && (await this.client.core.pairing.updateMetadata({ topic: l, metadata: u.metadata }), await this.sendResult({ id: n, topic: l, result: { relay: { protocol: i ?? "irn" }, responderPublicKey: g } }), await this.client.proposal.delete(n, zt("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l }));
      const S = kr({ relay: { protocol: i ?? "irn" }, namespaces: s, pairingTopic: l, controller: { publicKey: g, metadata: this.client.metadata }, expiry: hn(zc) }, a && { sessionProperties: a });
      await this.client.core.relayer.subscribe(w);
      const x = Vs(kr({}, S), { topic: w, requiredNamespaces: h, optionalNamespaces: f, pairingTopic: l, acknowledged: !1, self: S.controller, peer: { publicKey: u.publicKey, metadata: u.metadata }, controller: g });
      await this.client.session.set(w, x);
      try {
        await this.sendRequest({ topic: w, method: "wc_sessionSettle", params: S, throwOnFailedPublish: !0 });
      } catch (M) {
        throw this.client.logger.error(M), this.client.session.delete(w, zt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(w), M;
      }
      return await this.setExpiry(w, hn(zc)), { topic: w, acknowledged: () => new Promise((M) => setTimeout(() => M(this.client.session.get(w)), 500)) };
    }, this.reject = async (r) => {
      await this.isInitialized(), await this.isValidReject(r);
      const { id: n, reason: i } = r, { pairingTopic: s } = this.client.proposal.get(n);
      s && (await this.sendError(n, s, i), await this.client.proposal.delete(n, zt("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      await this.isInitialized(), await this.isValidUpdate(r);
      const { topic: n, namespaces: i } = r, s = await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: i } }), { done: a, resolve: o, reject: l } = Ys();
      return this.events.once(Ht("session_update", s), ({ error: u }) => {
        u ? l(u) : o();
      }), await this.client.session.update(n, { namespaces: i }), { acknowledged: a };
    }, this.extend = async (r) => {
      await this.isInitialized(), await this.isValidExtend(r);
      const { topic: n } = r, i = await this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {} }), { done: s, resolve: a, reject: o } = Ys();
      return this.events.once(Ht("session_extend", i), ({ error: l }) => {
        l ? o(l) : a();
      }), await this.setExpiry(n, hn(zc)), { acknowledged: s };
    }, this.request = async (r) => {
      await this.isInitialized(), await this.isValidRequest(r);
      const { chainId: n, request: i, topic: s, expiry: a = pi.wc_sessionRequest.req.ttl } = r, o = Jf(), { done: l, resolve: u, reject: h } = Ys(a, "Request expired. Please try again.");
      return this.events.once(Ht("session_request", o), ({ error: f, result: g }) => {
        f ? h(f) : u(g);
      }), await Promise.all([new Promise(async (f) => {
        await this.sendRequest({ clientRpcId: o, topic: s, method: "wc_sessionRequest", params: { request: Vs(kr({}, i), { expiryTimestamp: hn(a) }), chainId: n }, expiry: a, throwOnFailedPublish: !0 }).catch((g) => h(g)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: o }), f();
      }), new Promise(async (f) => {
        const g = await t6(this.client.core.storage, my);
        e6({ id: o, topic: s, wcDeepLink: g }), f();
      }), l()]).then((f) => f[2]);
    }, this.respond = async (r) => {
      await this.isInitialized(), await this.isValidRespond(r);
      const { topic: n, response: i } = r, { id: s } = i;
      _i(i) ? await this.sendResult({ id: s, topic: n, result: i.result, throwOnFailedPublish: !0 }) : Cn(i) && await this.sendError(s, n, i.error), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      await this.isInitialized(), await this.isValidPing(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const i = await this.sendRequest({ topic: n, method: "wc_sessionPing", params: {} }), { done: s, resolve: a, reject: o } = Ys();
        this.events.once(Ht("session_ping", i), ({ error: l }) => {
          l ? o(l) : a();
        }), await s();
      } else
        this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (r) => {
      await this.isInitialized(), await this.isValidEmit(r);
      const { topic: n, event: i, chainId: s } = r;
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: i, chainId: s } });
    }, this.disconnect = async (r) => {
      await this.isInitialized(), await this.isValidDisconnect(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n))
        await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: zt("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: n, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(n))
        await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: i } = le("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(i);
      }
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((n) => b6(n, r))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic)
        try {
          const n = this.client.core.pairing.pairings.get(r.pairingTopic), i = this.client.core.pairing.pairings.getAll().filter((s) => {
            var a, o;
            return ((a = s.peerMetadata) == null ? void 0 : a.url) && ((o = s.peerMetadata) == null ? void 0 : o.url) === r.peer.metadata.url && s.topic && s.topic !== n.topic;
          });
          if (i.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (n) {
          this.client.logger.error(n);
        }
    }, this.deleteSession = async (r) => {
      const { topic: n, expirerHasDeleted: i = !1, emitEvent: s = !0, id: a = 0 } = r, { self: o } = this.client.session.get(n);
      await this.client.core.relayer.unsubscribe(n), await this.client.session.delete(n, zt("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(o.publicKey) && await this.client.core.crypto.deleteKeyPair(o.publicKey), this.client.core.crypto.keychain.has(n) && await this.client.core.crypto.deleteSymKey(n), i || this.client.core.expirer.del(n), this.client.core.storage.removeItem(my).catch((l) => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach((l) => {
        l.topic === n && this.deletePendingSessionRequest(l.id, zt("USER_DISCONNECTED"));
      }), s && this.client.events.emit("session_delete", { id: a, topic: n });
    }, this.deleteProposal = async (r, n) => {
      await Promise.all([this.client.proposal.delete(r, zt("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.deletePendingSessionRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== r), i && (this.sessionRequestQueue.state = gi.idle, this.client.events.emit("session_request_expire", { id: r }));
    }, this.setExpiry = async (r, n) => {
      this.client.session.keys.includes(r) && await this.client.session.update(r, { expiry: n }), this.client.core.expirer.set(r, n);
    }, this.setProposal = async (r, n) => {
      await this.client.proposal.set(r, n), this.client.core.expirer.set(r, hn(pi.wc_sessionPropose.req.ttl));
    }, this.setPendingSessionRequest = async (r) => {
      const { id: n, topic: i, params: s, verifyContext: a } = r, o = s.request.expiryTimestamp || hn(pi.wc_sessionRequest.req.ttl);
      await this.client.pendingRequest.set(n, { id: n, topic: i, params: s, verifyContext: a }), o && this.client.core.expirer.set(n, o);
    }, this.sendRequest = async (r) => {
      const { topic: n, method: i, params: s, expiry: a, relayRpcId: o, clientRpcId: l, throwOnFailedPublish: u } = r, h = co(i, s, l);
      if (Ao() && ix.includes(i)) {
        const m = ao(JSON.stringify(h));
        this.client.core.verify.register({ attestationId: m });
      }
      const f = await this.client.core.crypto.encode(n, h), g = pi[i].req;
      return a && (g.ttl = a), o && (g.id = o), this.client.core.history.set(n, h), u ? (g.internal = Vs(kr({}, g.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, f, g)) : this.client.core.relayer.publish(n, f, g).catch((m) => this.client.logger.error(m)), h.id;
    }, this.sendResult = async (r) => {
      const { id: n, topic: i, result: s, throwOnFailedPublish: a } = r, o = Xf(n, s), l = await this.client.core.crypto.encode(i, o), u = await this.client.core.history.get(i, n), h = pi[u.request.method].res;
      a ? (h.internal = Vs(kr({}, h.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, l, h)) : this.client.core.relayer.publish(i, l, h).catch((f) => this.client.logger.error(f)), await this.client.core.history.resolve(o);
    }, this.sendError = async (r, n, i) => {
      const s = ep(r, i), a = await this.client.core.crypto.encode(n, s), o = await this.client.core.history.get(n, r), l = pi[o.request.method].res;
      this.client.core.relayer.publish(n, a, l), await this.client.core.history.resolve(s);
    }, this.cleanup = async () => {
      const r = [], n = [];
      this.client.session.getAll().forEach((i) => {
        let s = !1;
        Ri(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && r.push(i.topic);
      }), this.client.proposal.getAll().forEach((i) => {
        Ri(i.expiryTimestamp) && n.push(i.id);
      }), await Promise.all([...r.map((i) => this.deleteSession({ topic: i })), ...n.map((i) => this.deleteProposal(i))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === gi.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = gi.active;
        const r = this.requestQueue.queue.shift();
        if (r)
          try {
            this.processRequest(r), await new Promise((n) => setTimeout(n, 300));
          } catch (n) {
            this.client.logger.warn(n);
          }
      }
      this.requestQueue.state = gi.idle;
    }, this.processRequest = (r) => {
      const { topic: n, payload: i } = r, s = i.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(n, i);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(n, i);
        case "wc_sessionPing":
          return this.onSessionPingRequest(n, i);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequest(n, i);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(n, i);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: n, payload: i } = r, s = (await this.client.core.history.get(n, i.id)).request.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, i);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, i);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: n } = r, { message: i } = le("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i);
    }, this.onSessionProposeRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        this.isValidConnect(kr({}, n.params));
        const a = i.expiryTimestamp || hn(pi.wc_sessionPropose.req.ttl), o = kr({ id: s, pairingTopic: r, expiryTimestamp: a }, i);
        await this.setProposal(s, o);
        const l = ao(JSON.stringify(n)), u = await this.getVerifyContext(l, o.proposer.metadata);
        this.client.events.emit("session_proposal", { id: s, params: o, verifyContext: u });
      } catch (a) {
        await this.sendError(s, r, a), this.client.logger.error(a);
      }
    }, this.onSessionProposeResponse = async (r, n) => {
      const { id: i } = n;
      if (_i(n)) {
        const { result: s } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: s });
        const a = this.client.proposal.get(i);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const o = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o });
        const l = s.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l });
        const u = await this.client.core.crypto.generateSharedKey(o, l);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: u });
        const h = await this.client.core.relayer.subscribe(u);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h }), await this.client.core.pairing.activate({ topic: r });
      } else
        Cn(n) && (await this.client.proposal.delete(i, zt("USER_DISCONNECTED")), this.events.emit(Ht("session_connect"), { error: n.error }));
    }, this.onSessionSettleRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: a, controller: o, expiry: l, namespaces: u, sessionProperties: h, pairingTopic: f } = n.params, g = kr({ topic: r, relay: a, expiry: l, namespaces: u, acknowledged: !0, pairingTopic: f, requiredNamespaces: {}, optionalNamespaces: {}, controller: o.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o.publicKey, metadata: o.metadata } }, h && { sessionProperties: h });
        await this.sendResult({ id: n.id, topic: r, result: !0 }), this.events.emit(Ht("session_connect"), { session: g }), this.cleanupDuplicatePairings(g);
      } catch (a) {
        await this.sendError(i, r, a), this.client.logger.error(a);
      }
    }, this.onSessionSettleResponse = async (r, n) => {
      const { id: i } = n;
      _i(n) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(Ht("session_approve", i), {})) : Cn(n) && (await this.client.session.delete(r, zt("USER_DISCONNECTED")), this.events.emit(Ht("session_approve", i), { error: n.error }));
    }, this.onSessionUpdateRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        const a = `${r}_session_update`, o = qc.get(a);
        if (o && this.isRequestOutOfSync(o, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidUpdate(kr({ topic: r }, i)), await this.client.session.update(r, { namespaces: i.namespaces }), await this.sendResult({ id: s, topic: r, result: !0 }), this.client.events.emit("session_update", { id: s, topic: r, params: i }), qc.set(a, s);
      } catch (a) {
        await this.sendError(s, r, a), this.client.logger.error(a);
      }
    }, this.isRequestOutOfSync = (r, n) => parseInt(n.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, n) => {
      const { id: i } = n;
      _i(n) ? this.events.emit(Ht("session_update", i), {}) : Cn(n) && this.events.emit(Ht("session_update", i), { error: n.error });
    }, this.onSessionExtendRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, hn(zc)), await this.sendResult({ id: i, topic: r, result: !0 }), this.client.events.emit("session_extend", { id: i, topic: r });
      } catch (s) {
        await this.sendError(i, r, s), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (r, n) => {
      const { id: i } = n;
      _i(n) ? this.events.emit(Ht("session_extend", i), {}) : Cn(n) && this.events.emit(Ht("session_extend", i), { error: n.error });
    }, this.onSessionPingRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: i, topic: r, result: !0 }), this.client.events.emit("session_ping", { id: i, topic: r });
      } catch (s) {
        await this.sendError(i, r, s), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (r, n) => {
      const { id: i } = n;
      setTimeout(() => {
        _i(n) ? this.events.emit(Ht("session_ping", i), {}) : Cn(n) && this.events.emit(Ht("session_ping", i), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidDisconnect({ topic: r, reason: n.params }), await Promise.all([new Promise((s) => {
          this.client.core.relayer.once(Tr.publish, async () => {
            s(await this.deleteSession({ topic: r, id: i }));
          });
        }), this.sendResult({ id: i, topic: r, result: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: r, error: zt("USER_DISCONNECTED") })]);
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidRequest(kr({ topic: r }, s));
        const a = ao(JSON.stringify(co("wc_sessionRequest", s, i))), o = this.client.session.get(r), l = await this.getVerifyContext(a, o.peer.metadata), u = { id: i, topic: r, params: s, verifyContext: l };
        await this.setPendingSessionRequest(u), this.addSessionRequestToSessionRequestQueue(u), this.processSessionRequestQueue();
      } catch (a) {
        await this.sendError(i, r, a), this.client.logger.error(a);
      }
    }, this.onSessionRequestResponse = (r, n) => {
      const { id: i } = n;
      _i(n) ? this.events.emit(Ht("session_request", i), { result: n.result }) : Cn(n) && this.events.emit(Ht("session_request", i), { error: n.error });
    }, this.onSessionEventRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        const a = `${r}_session_event_${s.event.name}`, o = qc.get(a);
        if (o && this.isRequestOutOfSync(o, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return;
        }
        this.isValidEmit(kr({ topic: r }, s)), this.client.events.emit("session_event", { id: i, topic: r, params: s }), qc.set(a, i);
      } catch (a) {
        await this.sendError(i, r, a), this.client.logger.error(a);
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = gi.idle, this.processSessionRequestQueue();
      }, Ne.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: r, error: n }) => {
      const i = this.client.core.history.pending;
      i.length > 0 && i.filter((s) => s.topic === r && s.request.method === "wc_sessionRequest").forEach((s) => {
        this.events.emit(Ht("session_request", s.request.id), { error: n });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === gi.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = gi.active, this.client.events.emit("session_request", r);
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.onPairingCreated = (r) => {
      if (r.active)
        return;
      const n = this.client.proposal.getAll().find((i) => i.pairingTopic === r.topic);
      n && this.onSessionProposeRequest(r.topic, co("wc_sessionPropose", { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties }, n.id));
    }, this.isValidConnect = async (r) => {
      if (!tn(r)) {
        const { message: l } = le("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(l);
      }
      const { pairingTopic: n, requiredNamespaces: i, optionalNamespaces: s, sessionProperties: a, relays: o } = r;
      if (zr(n) || await this.isValidPairingTopic(n), !R6(o, !0)) {
        const { message: l } = le("MISSING_OR_INVALID", `connect() relays: ${o}`);
        throw new Error(l);
      }
      !zr(i) && bu(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !zr(s) && bu(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), zr(a) || this.validateSessionProps(a, "sessionProperties");
    }, this.validateNamespaces = (r, n) => {
      const i = P6(r, "connect()", n);
      if (i)
        throw new Error(i.message);
    }, this.isValidApprove = async (r) => {
      if (!tn(r))
        throw new Error(le("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: n, namespaces: i, relayProtocol: s, sessionProperties: a } = r;
      await this.isValidProposalId(n);
      const o = this.client.proposal.get(n), l = Ch(i, "approve()");
      if (l)
        throw new Error(l.message);
      const u = Vg(o.requiredNamespaces, i, "approve()");
      if (u)
        throw new Error(u.message);
      if (!cr(s, !0)) {
        const { message: h } = le("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(h);
      }
      zr(a) || this.validateSessionProps(a, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!tn(r)) {
        const { message: s } = le("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(s);
      }
      const { id: n, reason: i } = r;
      if (await this.isValidProposalId(n), !A6(i)) {
        const { message: s } = le("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!tn(r)) {
        const { message: u } = le("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(u);
      }
      const { relay: n, controller: i, namespaces: s, expiry: a } = r;
      if (!Q0(n)) {
        const { message: u } = le("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(u);
      }
      const o = O6(i, "onSessionSettleRequest()");
      if (o)
        throw new Error(o.message);
      const l = Ch(s, "onSessionSettleRequest()");
      if (l)
        throw new Error(l.message);
      if (Ri(a)) {
        const { message: u } = le("EXPIRED", "onSessionSettleRequest()");
        throw new Error(u);
      }
    }, this.isValidUpdate = async (r) => {
      if (!tn(r)) {
        const { message: l } = le("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(l);
      }
      const { topic: n, namespaces: i } = r;
      await this.isValidSessionTopic(n);
      const s = this.client.session.get(n), a = Ch(i, "update()");
      if (a)
        throw new Error(a.message);
      const o = Vg(s.requiredNamespaces, i, "update()");
      if (o)
        throw new Error(o.message);
    }, this.isValidExtend = async (r) => {
      if (!tn(r)) {
        const { message: i } = le("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (r) => {
      if (!tn(r)) {
        const { message: l } = le("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(l);
      }
      const { topic: n, request: i, chainId: s, expiry: a } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!zg(o, s)) {
        const { message: l } = le("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(l);
      }
      if (!L6(i)) {
        const { message: l } = le("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(l);
      }
      if (!k6(o, s, i.method)) {
        const { message: l } = le("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(l);
      }
      if (a && !q6(a, Ah)) {
        const { message: l } = le("MISSING_OR_INVALID", `request() expiry: ${a}. Expiry must be a number (in seconds) between ${Ah.min} and ${Ah.max}`);
        throw new Error(l);
      }
    }, this.isValidRespond = async (r) => {
      var n;
      if (!tn(r)) {
        const { message: a } = le("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(a);
      }
      const { topic: i, response: s } = r;
      try {
        await this.isValidSessionTopic(i);
      } catch (a) {
        throw (n = r == null ? void 0 : r.response) != null && n.id && this.cleanupAfterResponse(r), a;
      }
      if (!M6(s)) {
        const { message: a } = le("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
    }, this.isValidPing = async (r) => {
      if (!tn(r)) {
        const { message: i } = le("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (r) => {
      if (!tn(r)) {
        const { message: o } = le("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(o);
      }
      const { topic: n, event: i, chainId: s } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!zg(a, s)) {
        const { message: o } = le("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(o);
      }
      if (!j6(i)) {
        const { message: o } = le("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(o);
      }
      if (!U6(a, s, i.name)) {
        const { message: o } = le("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(o);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!tn(r)) {
        const { message: i } = le("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.getVerifyContext = async (r, n) => {
      const i = { verified: { verifyUrl: n.verifyUrl || ro, validation: "UNKNOWN", origin: n.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: r, verifyUrl: n.verifyUrl });
        s && (i.verified.origin = s.origin, i.verified.isScam = s.isScam, i.verified.validation = s.origin === new URL(n.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.info(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`), i;
    }, this.validateSessionProps = (r, n) => {
      Object.values(r).forEach((i) => {
        if (!cr(i, !1)) {
          const { message: s } = le("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: e } = le("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(Tr.message, async (e) => {
      const { topic: r, message: n } = e;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(n)))
        return;
      const i = await this.client.core.crypto.decode(r, n);
      try {
        tp(i) ? (this.client.core.history.set(r, i), this.onRelayEventRequest({ topic: r, payload: i })) : fl(i) ? (await this.client.core.history.resolve(i), await this.onRelayEventResponse({ topic: r, payload: i }), this.client.core.history.delete(r, i.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: i });
      } catch (s) {
        this.client.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(mn.expired, async (e) => {
      const { topic: r, id: n } = Z0(e.target);
      if (n && this.client.pendingRequest.keys.includes(n))
        return await this.deletePendingSessionRequest(n, le("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: r })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(pa.create, (e) => this.onPairingCreated(e));
  }
  isValidPairingTopic(e) {
    if (!cr(e, !1)) {
      const { message: r } = le("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = le("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Ri(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = le("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!cr(e, !1)) {
      const { message: r } = le("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: r } = le("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Ri(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: r } = le("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: r } = le("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (cr(e, !1)) {
      const { message: r } = le("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = le("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!N6(e)) {
      const { message: r } = le("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = le("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Ri(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: r } = le("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
};
class hx extends gl {
  constructor(e, r) {
    super(e, r, XI, np), this.core = e, this.logger = r;
  }
}
let dx = class extends gl {
  constructor(e, r) {
    super(e, r, tx, np), this.core = e, this.logger = r;
  }
}, fx = class extends gl {
  constructor(e, r) {
    super(e, r, nx, np, (n) => n.id), this.core = e, this.logger = r;
  }
};
class ip extends JE {
  constructor(e) {
    super(e), this.protocol = vb, this.version = bb, this.name = Nh.name, this.events = new wn.EventEmitter(), this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.name = (e == null ? void 0 : e.name) || Nh.name, this.metadata = (e == null ? void 0 : e.metadata) || W5();
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : bt.pino(bt.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || Nh.logger }));
    this.core = (e == null ? void 0 : e.core) || new JI(e), this.logger = bt.generateChildLogger(r, this.name), this.session = new dx(this.core, this.logger), this.proposal = new hx(this.core, this.logger), this.pendingRequest = new fx(this.core, this.logger), this.engine = new lx(this);
  }
  static async init(e) {
    const r = new ip(e);
    return await r.initialize(), r;
  }
  get context() {
    return bt.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
var px = Object.defineProperty, gx = Object.defineProperties, yx = Object.getOwnPropertyDescriptors, wy = Object.getOwnPropertySymbols, mx = Object.prototype.hasOwnProperty, vx = Object.prototype.propertyIsEnumerable, _y = (t, e, r) => e in t ? px(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, bx = (t, e) => {
  for (var r in e || (e = {}))
    mx.call(e, r) && _y(t, r, e[r]);
  if (wy)
    for (var r of wy(e))
      vx.call(e, r) && _y(t, r, e[r]);
  return t;
}, wx = (t, e) => gx(t, yx(e)), sp = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, Ut = (t, e, r) => (sp(t, e, "read from private field"), r ? r.call(t) : e.get(t)), as = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, Eu = (t, e, r, n) => (sp(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), Sr = (t, e, r) => (sp(t, e, "access private method"), r), fs, Qs, ga, or, xd, _b, Or, Fr, Cd, Ey;
let _x = class {
  constructor(e) {
    as(this, xd), as(this, Or), as(this, Cd), as(this, fs, void 0), as(this, Qs, void 0), as(this, ga, void 0), as(this, or, void 0), Eu(this, fs, e), Eu(this, Qs, Sr(this, xd, _b).call(this)), Sr(this, Or, Fr).call(this);
  }
  async connect(e) {
    const { requiredNamespaces: r, optionalNamespaces: n } = e;
    return new Promise(async (i, s) => {
      await Sr(this, Or, Fr).call(this);
      const a = Ut(this, Qs).subscribeModal((u) => {
        u.open || (a(), s(new Error("Modal closed")));
      }), { uri: o, approval: l } = await Ut(this, or).connect(e);
      if (o) {
        const u = /* @__PURE__ */ new Set();
        r && Object.values(r).forEach(({ chains: h }) => {
          h && h.forEach((f) => u.add(f));
        }), n && Object.values(n).forEach(({ chains: h }) => {
          h && h.forEach((f) => u.add(f));
        }), await Ut(this, Qs).openModal({ uri: o, chains: Array.from(u) });
      }
      try {
        const u = await l();
        i(u);
      } catch (u) {
        s(u);
      } finally {
        a(), Ut(this, Qs).closeModal();
      }
    });
  }
  async disconnect(e) {
    await Sr(this, Or, Fr).call(this), await Ut(this, or).disconnect(e);
  }
  async request(e) {
    return await Sr(this, Or, Fr).call(this), await Ut(this, or).request(e);
  }
  async getSessions() {
    return await Sr(this, Or, Fr).call(this), Ut(this, or).session.getAll();
  }
  async getSession() {
    return await Sr(this, Or, Fr).call(this), Ut(this, or).session.getAll().at(-1);
  }
  async onSessionEvent(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).on("session_event", e);
  }
  async offSessionEvent(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).off("session_event", e);
  }
  async onSessionUpdate(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).on("session_update", e);
  }
  async offSessionUpdate(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).off("session_update", e);
  }
  async onSessionDelete(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).on("session_delete", e);
  }
  async offSessionDelete(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).off("session_delete", e);
  }
  async onSessionExpire(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).on("session_expire", e);
  }
  async offSessionExpire(e) {
    await Sr(this, Or, Fr).call(this), Ut(this, or).off("session_expire", e);
  }
};
fs = /* @__PURE__ */ new WeakMap(), Qs = /* @__PURE__ */ new WeakMap(), ga = /* @__PURE__ */ new WeakMap(), or = /* @__PURE__ */ new WeakMap(), xd = /* @__PURE__ */ new WeakSet(), _b = function() {
  const { modalOptions: t, projectId: e } = Ut(this, fs);
  return new _1(wx(bx({}, t), { projectId: e }));
}, Or = /* @__PURE__ */ new WeakSet(), Fr = async function() {
  return Ut(this, or) ? !0 : (!Ut(this, ga) && typeof window < "u" && Eu(this, ga, Sr(this, Cd, Ey).call(this)), Ut(this, ga));
}, Cd = /* @__PURE__ */ new WeakSet(), Ey = async function() {
  Eu(this, or, await ip.init({ metadata: Ut(this, fs).metadata, projectId: Ut(this, fs).projectId, relayUrl: Ut(this, fs).relayUrl }));
  const t = await Ut(this, or).core.crypto.getClientId();
  try {
    localStorage.setItem("WCM_WALLETCONNECT_CLIENT_ID", t);
  } catch {
    console.info("Unable to set client id");
  }
};
const Eb = [
  "decrypt",
  "disconnect",
  "getSelectedAccount",
  "getBalance",
  "getRecords",
  "requestCreateEvent",
  "getEvent",
  "getEvents",
  "createSharedState",
  "importSharedState",
  "requestSignature"
], op = ["aleo:1"], Sb = ["chainChanged", "accountSelected", "selectedAccountSynced", "sharedAccountSynced"], Ex = "f0aaeffe71b636da453fce042d79d723", Sx = {
  standaloneChains: op,
  enableExplorer: !1,
  enableAccountView: !0,
  enableNetworkView: !0,
  enableStandaloneMode: !0,
  mobileWallets: [
    {
      id: "puzzle",
      name: "Puzzle Wallet",
      links: {
        native: "puzzleapp://",
        universal: ""
      }
    }
  ],
  desktopWallets: [
    {
      id: "puzzle",
      name: "Puzzle Wallet",
      links: {
        native: "",
        universal: "https://walletconnect.puzzle.online/"
      }
    },
    {
      id: "avail",
      name: "Avail Wallet",
      links: {
        native: "avail://",
        universal: "https://avail.global"
      }
    }
  ],
  walletImages: {
    puzzle: "https://i.imgur.com/p9tHaFC.png",
    avail: "https://i.imgur.com/GxNn8BO.png"
  }
}, U9 = {
  requiredNamespaces: {
    aleo: {
      methods: Eb,
      chains: op,
      events: Sb
    }
  }
}, Su = new fc();
let ya;
function $9(t) {
  ya = new _x({
    projectId: Ex,
    metadata: {
      name: t.dAppName,
      description: t.dAppDescription,
      url: t.dAppUrl,
      icons: [t.dAppIconURL]
    },
    modalOptions: { ...Sx }
  }), window.localStorage.removeItem("WALLETCONNECT_DEEPLINK_CHOICE");
}
async function Bt() {
  return new Promise((t) => {
    if (ya)
      t(ya);
    else {
      const e = setInterval(() => {
        ya && (clearInterval(e), t(ya));
      }, 200);
    }
    window.localStorage.removeItem("WALLETCONNECT_DEEPLINK_CHOICE");
  });
}
function Ob(t) {
  pr(() => (Bt().then((e) => {
    e.onSessionDelete(t);
  }), () => {
    Bt().then((e) => {
      e.offSessionDelete(t);
    });
  }), [t]);
}
function Ox(t) {
  pr(() => (Bt().then((e) => {
    e.onSessionExpire(t);
  }), () => {
    Bt().then((e) => {
      e.offSessionExpire(t);
    });
  }), [t]);
}
function Ib(t) {
  pr(() => (Bt().then((e) => {
    e.onSessionUpdate(t);
  }), () => {
    Bt().then((e) => {
      e.offSessionUpdate(t);
    });
  }), [t]);
}
function _n() {
  const [t, e] = Ea(void 0);
  return Ob((r) => {
    r.topic === (t == null ? void 0 : t.topic) && e(void 0);
  }), Ib((r) => {
    if (t && r.topic === (t == null ? void 0 : t.topic)) {
      const { namespaces: n } = r.params, i = { ...t, namespaces: n };
      e(i);
    }
  }), Ox((r) => {
    t && r.topic === (t == null ? void 0 : t.topic) && e(void 0);
  }), pr(() => {
    async function r() {
      const i = await (await Bt()).getSession();
      e(i);
    }
    return r(), Su.on("session_change", r), () => {
      Su.off("session_change", r);
    };
  }, []), t;
}
function Ec(t) {
  pr(() => (Bt().then((e) => {
    e.onSessionEvent(t);
  }), () => {
    Bt().then((e) => {
      e.offSessionEvent(t);
    });
  }), [t]);
}
var Ix = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const Sy = (t) => {
  let e;
  const r = /* @__PURE__ */ new Set(), n = (l, u) => {
    const h = typeof l == "function" ? l(e) : l;
    if (!Object.is(h, e)) {
      const f = e;
      e = u ?? (typeof h != "object" || h === null) ? h : Object.assign({}, e, h), r.forEach((g) => g(e, f));
    }
  }, i = () => e, o = { setState: n, getState: i, subscribe: (l) => (r.add(l), () => r.delete(l)), destroy: () => {
    (Ix ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), r.clear();
  } };
  return e = t(n, i, o), o;
}, xx = (t) => t ? Sy(t) : Sy;
var Dd = { exports: {} }, Lh = {}, Vc = { exports: {} }, Mh = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Oy;
function Cx() {
  return Oy || (Oy = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = Zi, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(I) {
      {
        for (var b = arguments.length, E = new Array(b > 1 ? b - 1 : 0), y = 1; y < b; y++)
          E[y - 1] = arguments[y];
        n("error", I, E);
      }
    }
    function n(I, b, E) {
      {
        var y = e.ReactDebugCurrentFrame, c = y.getStackAddendum();
        c !== "" && (b += "%s", E = E.concat([c]));
        var p = E.map(function(D) {
          return String(D);
        });
        p.unshift("Warning: " + b), Function.prototype.apply.call(console[I], console, p);
      }
    }
    function i(I, b) {
      return I === b && (I !== 0 || 1 / I === 1 / b) || I !== I && b !== b;
    }
    var s = typeof Object.is == "function" ? Object.is : i, a = t.useState, o = t.useEffect, l = t.useLayoutEffect, u = t.useDebugValue, h = !1, f = !1;
    function g(I, b, E) {
      h || t.startTransition !== void 0 && (h = !0, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var y = b();
      if (!f) {
        var c = b();
        s(y, c) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var p = a({
        inst: {
          value: y,
          getSnapshot: b
        }
      }), D = p[0].inst, R = p[1];
      return l(function() {
        D.value = y, D.getSnapshot = b, m(D) && R({
          inst: D
        });
      }, [I, y, b]), o(function() {
        m(D) && R({
          inst: D
        });
        var k = function() {
          m(D) && R({
            inst: D
          });
        };
        return I(k);
      }, [I]), u(y), y;
    }
    function m(I) {
      var b = I.getSnapshot, E = I.value;
      try {
        var y = b();
        return !s(E, y);
      } catch {
        return !0;
      }
    }
    function w(I, b, E) {
      return b();
    }
    var S = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", x = !S, M = x ? w : g, _ = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : M;
    Mh.useSyncExternalStore = _, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Mh;
}
var jh = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Iy;
function Dx() {
  if (Iy)
    return jh;
  Iy = 1;
  var t = Zi;
  function e(f, g) {
    return f === g && (f !== 0 || 1 / f === 1 / g) || f !== f && g !== g;
  }
  var r = typeof Object.is == "function" ? Object.is : e, n = t.useState, i = t.useEffect, s = t.useLayoutEffect, a = t.useDebugValue;
  function o(f, g) {
    var m = g(), w = n({ inst: { value: m, getSnapshot: g } }), S = w[0].inst, x = w[1];
    return s(function() {
      S.value = m, S.getSnapshot = g, l(S) && x({ inst: S });
    }, [f, m, g]), i(function() {
      return l(S) && x({ inst: S }), f(function() {
        l(S) && x({ inst: S });
      });
    }, [f]), a(m), m;
  }
  function l(f) {
    var g = f.getSnapshot;
    f = f.value;
    try {
      var m = g();
      return !r(f, m);
    } catch {
      return !0;
    }
  }
  function u(f, g) {
    return g();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : o;
  return jh.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : h, jh;
}
var xy;
function ap() {
  return xy || (xy = 1, process.env.NODE_ENV === "production" ? Vc.exports = Dx() : Vc.exports = Cx()), Vc.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cy;
function Tx() {
  return Cy || (Cy = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = Zi, e = ap();
    function r(h, f) {
      return h === f && (h !== 0 || 1 / h === 1 / f) || h !== h && f !== f;
    }
    var n = typeof Object.is == "function" ? Object.is : r, i = e.useSyncExternalStore, s = t.useRef, a = t.useEffect, o = t.useMemo, l = t.useDebugValue;
    function u(h, f, g, m, w) {
      var S = s(null), x;
      S.current === null ? (x = {
        hasValue: !1,
        value: null
      }, S.current = x) : x = S.current;
      var M = o(function() {
        var E = !1, y, c, p = function(B) {
          if (!E) {
            E = !0, y = B;
            var W = m(B);
            if (w !== void 0 && x.hasValue) {
              var C = x.value;
              if (w(C, W))
                return c = C, C;
            }
            return c = W, W;
          }
          var N = y, G = c;
          if (n(N, B))
            return G;
          var z = m(B);
          return w !== void 0 && w(G, z) ? G : (y = B, c = z, z);
        }, D = g === void 0 ? null : g, R = function() {
          return p(f());
        }, k = D === null ? void 0 : function() {
          return p(D());
        };
        return [R, k];
      }, [f, g, m, w]), _ = M[0], I = M[1], b = i(h, _, I);
      return a(function() {
        x.hasValue = !0, x.value = b;
      }, [b]), l(b), b;
    }
    Lh.useSyncExternalStoreWithSelector = u, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Lh;
}
var kh = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dy;
function Px() {
  if (Dy)
    return kh;
  Dy = 1;
  var t = Zi, e = ap();
  function r(u, h) {
    return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h;
  }
  var n = typeof Object.is == "function" ? Object.is : r, i = e.useSyncExternalStore, s = t.useRef, a = t.useEffect, o = t.useMemo, l = t.useDebugValue;
  return kh.useSyncExternalStoreWithSelector = function(u, h, f, g, m) {
    var w = s(null);
    if (w.current === null) {
      var S = { hasValue: !1, value: null };
      w.current = S;
    } else
      S = w.current;
    w = o(function() {
      function M(y) {
        if (!_) {
          if (_ = !0, I = y, y = g(y), m !== void 0 && S.hasValue) {
            var c = S.value;
            if (m(c, y))
              return b = c;
          }
          return b = y;
        }
        if (c = b, n(I, y))
          return c;
        var p = g(y);
        return m !== void 0 && m(c, p) ? c : (I = y, b = p);
      }
      var _ = !1, I, b, E = f === void 0 ? null : f;
      return [function() {
        return M(h());
      }, E === null ? void 0 : function() {
        return M(E());
      }];
    }, [h, f, g, m]);
    var x = i(u, w[0], w[1]);
    return a(function() {
      S.hasValue = !0, S.value = x;
    }, [x]), l(x), x;
  }, kh;
}
process.env.NODE_ENV === "production" ? Dd.exports = Px() : Dd.exports = Tx();
var Rx = Dd.exports;
const Nx = /* @__PURE__ */ dc(Rx);
var xb = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const { useDebugValue: Ax } = Zi, { useSyncExternalStoreWithSelector: Lx } = Nx;
let Ty = !1;
function Mx(t, e = t.getState, r) {
  (xb ? "production" : void 0) !== "production" && r && !Ty && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), Ty = !0);
  const n = Lx(
    t.subscribe,
    t.getState,
    t.getServerState || t.getState,
    e,
    r
  );
  return Ax(n), n;
}
const Py = (t) => {
  (xb ? "production" : void 0) !== "production" && typeof t != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const e = typeof t == "function" ? xx(t) : t, r = (n, i) => Mx(e, n, i);
  return Object.assign(r, e), r;
}, jx = (t) => t ? Py(t) : Py;
var kx = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
function Ux(t, e) {
  let r;
  try {
    r = t();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var s;
      const a = (l) => l === null ? null : JSON.parse(l, e == null ? void 0 : e.reviver), o = (s = r.getItem(i)) != null ? s : null;
      return o instanceof Promise ? o.then(a) : a(o);
    },
    setItem: (i, s) => r.setItem(
      i,
      JSON.stringify(s, e == null ? void 0 : e.replacer)
    ),
    removeItem: (i) => r.removeItem(i)
  };
}
const Ta = (t) => (e) => {
  try {
    const r = t(e);
    return r instanceof Promise ? r : {
      then(n) {
        return Ta(n)(r);
      },
      catch(n) {
        return this;
      }
    };
  } catch (r) {
    return {
      then(n) {
        return this;
      },
      catch(n) {
        return Ta(n)(r);
      }
    };
  }
}, $x = (t, e) => (r, n, i) => {
  let s = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (x) => x,
    version: 0,
    merge: (x, M) => ({
      ...M,
      ...x
    }),
    ...e
  }, a = !1;
  const o = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let u;
  try {
    u = s.getStorage();
  } catch {
  }
  if (!u)
    return t(
      (...x) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
        ), r(...x);
      },
      n,
      i
    );
  const h = Ta(s.serialize), f = () => {
    const x = s.partialize({ ...n() });
    let M;
    const _ = h({ state: x, version: s.version }).then(
      (I) => u.setItem(s.name, I)
    ).catch((I) => {
      M = I;
    });
    if (M)
      throw M;
    return _;
  }, g = i.setState;
  i.setState = (x, M) => {
    g(x, M), f();
  };
  const m = t(
    (...x) => {
      r(...x), f();
    },
    n,
    i
  );
  let w;
  const S = () => {
    var x;
    if (!u)
      return;
    a = !1, o.forEach((_) => _(n()));
    const M = ((x = s.onRehydrateStorage) == null ? void 0 : x.call(s, n())) || void 0;
    return Ta(u.getItem.bind(u))(s.name).then((_) => {
      if (_)
        return s.deserialize(_);
    }).then((_) => {
      if (_)
        if (typeof _.version == "number" && _.version !== s.version) {
          if (s.migrate)
            return s.migrate(
              _.state,
              _.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return _.state;
    }).then((_) => {
      var I;
      return w = s.merge(
        _,
        (I = n()) != null ? I : m
      ), r(w, !0), f();
    }).then(() => {
      M == null || M(w, void 0), a = !0, l.forEach((_) => _(w));
    }).catch((_) => {
      M == null || M(void 0, _);
    });
  };
  return i.persist = {
    setOptions: (x) => {
      s = {
        ...s,
        ...x
      }, x.getStorage && (u = x.getStorage());
    },
    clearStorage: () => {
      u == null || u.removeItem(s.name);
    },
    getOptions: () => s,
    rehydrate: () => S(),
    hasHydrated: () => a,
    onHydrate: (x) => (o.add(x), () => {
      o.delete(x);
    }),
    onFinishHydration: (x) => (l.add(x), () => {
      l.delete(x);
    })
  }, S(), w || m;
}, Fx = (t, e) => (r, n, i) => {
  let s = {
    storage: Ux(() => localStorage),
    partialize: (S) => S,
    version: 0,
    merge: (S, x) => ({
      ...x,
      ...S
    }),
    ...e
  }, a = !1;
  const o = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let u = s.storage;
  if (!u)
    return t(
      (...S) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
        ), r(...S);
      },
      n,
      i
    );
  const h = () => {
    const S = s.partialize({ ...n() });
    return u.setItem(s.name, {
      state: S,
      version: s.version
    });
  }, f = i.setState;
  i.setState = (S, x) => {
    f(S, x), h();
  };
  const g = t(
    (...S) => {
      r(...S), h();
    },
    n,
    i
  );
  let m;
  const w = () => {
    var S, x;
    if (!u)
      return;
    a = !1, o.forEach((_) => {
      var I;
      return _((I = n()) != null ? I : g);
    });
    const M = ((x = s.onRehydrateStorage) == null ? void 0 : x.call(s, (S = n()) != null ? S : g)) || void 0;
    return Ta(u.getItem.bind(u))(s.name).then((_) => {
      if (_)
        if (typeof _.version == "number" && _.version !== s.version) {
          if (s.migrate)
            return s.migrate(
              _.state,
              _.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return _.state;
    }).then((_) => {
      var I;
      return m = s.merge(
        _,
        (I = n()) != null ? I : g
      ), r(m, !0), h();
    }).then(() => {
      M == null || M(m, void 0), m = n(), a = !0, l.forEach((_) => _(m));
    }).catch((_) => {
      M == null || M(void 0, _);
    });
  };
  return i.persist = {
    setOptions: (S) => {
      s = {
        ...s,
        ...S
      }, S.storage && (u = S.storage);
    },
    clearStorage: () => {
      u == null || u.removeItem(s.name);
    },
    getOptions: () => s,
    rehydrate: () => w(),
    hasHydrated: () => a,
    onHydrate: (S) => (o.add(S), () => {
      o.delete(S);
    }),
    onFinishHydration: (S) => (l.add(S), () => {
      l.delete(S);
    })
  }, s.skipHydration || w(), m || g;
}, qx = (t, e) => "getStorage" in e || "serialize" in e || "deserialize" in e ? ((kx ? "production" : void 0) !== "production" && console.warn(
  "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
), $x(t, e)) : Fx(t, e), zx = qx, Fi = jx()(
  zx((t, e) => ({
    account: void 0,
    chainId: "aleo:1",
    // todo - figure out how to populate this from useConnect
    setAccount: (r) => {
      t({ account: r });
    },
    setChainId: (r) => {
      t({ chainId: r });
    },
    onDisconnect: () => {
      t({
        account: void 0,
        chainId: void 0
      }), J_.clear(), console.log("onDisconnect called!");
    }
  }), {
    name: "puzzle-wallet-store"
  })
);
class Sc {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    const r = {
      listener: e
    };
    return this.listeners.add(r), this.onSubscribe(), () => {
      this.listeners.delete(r), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}
const Pa = typeof window > "u" || "Deno" in window;
function bn() {
}
function Vx(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Td(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function Cb(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function ma(t, e, r) {
  return yl(t) ? typeof e == "function" ? {
    ...r,
    queryKey: t,
    queryFn: e
  } : {
    ...e,
    queryKey: t
  } : t;
}
function Ni(t, e, r) {
  return yl(t) ? [{
    ...e,
    queryKey: t
  }, r] : [t || {}, e];
}
function Ry(t, e) {
  const {
    type: r = "all",
    exact: n,
    fetchStatus: i,
    predicate: s,
    queryKey: a,
    stale: o
  } = t;
  if (yl(a)) {
    if (n) {
      if (e.queryHash !== cp(a, e.options))
        return !1;
    } else if (!no(e.queryKey, a))
      return !1;
  }
  if (r !== "all") {
    const l = e.isActive();
    if (r === "active" && !l || r === "inactive" && l)
      return !1;
  }
  return !(typeof o == "boolean" && e.isStale() !== o || typeof i < "u" && i !== e.state.fetchStatus || s && !s(e));
}
function Ny(t, e) {
  const {
    exact: r,
    fetching: n,
    predicate: i,
    mutationKey: s
  } = t;
  if (yl(s)) {
    if (!e.options.mutationKey)
      return !1;
    if (r) {
      if (ms(e.options.mutationKey) !== ms(s))
        return !1;
    } else if (!no(e.options.mutationKey, s))
      return !1;
  }
  return !(typeof n == "boolean" && e.state.status === "loading" !== n || i && !i(e));
}
function cp(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || ms)(t);
}
function ms(t) {
  return JSON.stringify(t, (e, r) => Rd(r) ? Object.keys(r).sort().reduce((n, i) => (n[i] = r[i], n), {}) : r);
}
function no(t, e) {
  return Db(t, e);
}
function Db(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? !Object.keys(e).some((r) => !Db(t[r], e[r])) : !1;
}
function Tb(t, e) {
  if (t === e)
    return t;
  const r = Ay(t) && Ay(e);
  if (r || Rd(t) && Rd(e)) {
    const n = r ? t.length : Object.keys(t).length, i = r ? e : Object.keys(e), s = i.length, a = r ? [] : {};
    let o = 0;
    for (let l = 0; l < s; l++) {
      const u = r ? l : i[l];
      a[u] = Tb(t[u], e[u]), a[u] === t[u] && o++;
    }
    return n === s && o === n ? t : a;
  }
  return e;
}
function Pd(t, e) {
  if (t && !e || e && !t)
    return !1;
  for (const r in t)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function Ay(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function Rd(t) {
  if (!Ly(t))
    return !1;
  const e = t.constructor;
  if (typeof e > "u")
    return !0;
  const r = e.prototype;
  return !(!Ly(r) || !r.hasOwnProperty("isPrototypeOf"));
}
function Ly(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function yl(t) {
  return Array.isArray(t);
}
function Pb(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function My(t) {
  Pb(0).then(t);
}
function Kx() {
  if (typeof AbortController == "function")
    return new AbortController();
}
function Nd(t, e, r) {
  return r.isDataEqual != null && r.isDataEqual(t, e) ? t : typeof r.structuralSharing == "function" ? r.structuralSharing(t, e) : r.structuralSharing !== !1 ? Tb(t, e) : e;
}
class Bx extends Sc {
  constructor() {
    super(), this.setup = (e) => {
      if (!Pa && window.addEventListener) {
        const r = () => e();
        return window.addEventListener("visibilitychange", r, !1), window.addEventListener("focus", r, !1), () => {
          window.removeEventListener("visibilitychange", r), window.removeEventListener("focus", r);
        };
      }
    };
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var e;
      (e = this.cleanup) == null || e.call(this), this.cleanup = void 0;
    }
  }
  setEventListener(e) {
    var r;
    this.setup = e, (r = this.cleanup) == null || r.call(this), this.cleanup = e((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    });
  }
  setFocused(e) {
    this.focused !== e && (this.focused = e, this.onFocus());
  }
  onFocus() {
    this.listeners.forEach(({
      listener: e
    }) => {
      e();
    });
  }
  isFocused() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const Ou = new Bx(), jy = ["online", "offline"];
class Hx extends Sc {
  constructor() {
    super(), this.setup = (e) => {
      if (!Pa && window.addEventListener) {
        const r = () => e();
        return jy.forEach((n) => {
          window.addEventListener(n, r, !1);
        }), () => {
          jy.forEach((n) => {
            window.removeEventListener(n, r);
          });
        };
      }
    };
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var e;
      (e = this.cleanup) == null || e.call(this), this.cleanup = void 0;
    }
  }
  setEventListener(e) {
    var r;
    this.setup = e, (r = this.cleanup) == null || r.call(this), this.cleanup = e((n) => {
      typeof n == "boolean" ? this.setOnline(n) : this.onOnline();
    });
  }
  setOnline(e) {
    this.online !== e && (this.online = e, this.onOnline());
  }
  onOnline() {
    this.listeners.forEach(({
      listener: e
    }) => {
      e();
    });
  }
  isOnline() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? !0 : navigator.onLine;
  }
}
const Ra = new Hx();
function Wx(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function ml(t) {
  return (t ?? "online") === "online" ? Ra.isOnline() : !0;
}
class Rb {
  constructor(e) {
    this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent;
  }
}
function ou(t) {
  return t instanceof Rb;
}
function Nb(t) {
  let e = !1, r = 0, n = !1, i, s, a;
  const o = new Promise((x, M) => {
    s = x, a = M;
  }), l = (x) => {
    n || (m(new Rb(x)), t.abort == null || t.abort());
  }, u = () => {
    e = !0;
  }, h = () => {
    e = !1;
  }, f = () => !Ou.isFocused() || t.networkMode !== "always" && !Ra.isOnline(), g = (x) => {
    n || (n = !0, t.onSuccess == null || t.onSuccess(x), i == null || i(), s(x));
  }, m = (x) => {
    n || (n = !0, t.onError == null || t.onError(x), i == null || i(), a(x));
  }, w = () => new Promise((x) => {
    i = (M) => {
      const _ = n || !f();
      return _ && x(M), _;
    }, t.onPause == null || t.onPause();
  }).then(() => {
    i = void 0, n || t.onContinue == null || t.onContinue();
  }), S = () => {
    if (n)
      return;
    let x;
    try {
      x = t.fn();
    } catch (M) {
      x = Promise.reject(M);
    }
    Promise.resolve(x).then(g).catch((M) => {
      var _, I;
      if (n)
        return;
      const b = (_ = t.retry) != null ? _ : 3, E = (I = t.retryDelay) != null ? I : Wx, y = typeof E == "function" ? E(r, M) : E, c = b === !0 || typeof b == "number" && r < b || typeof b == "function" && b(r, M);
      if (e || !c) {
        m(M);
        return;
      }
      r++, t.onFail == null || t.onFail(r, M), Pb(y).then(() => {
        if (f())
          return w();
      }).then(() => {
        e ? m(M) : S();
      });
    });
  };
  return ml(t.networkMode) ? S() : w().then(S), {
    promise: o,
    cancel: l,
    continue: () => (i == null ? void 0 : i()) ? o : Promise.resolve(),
    cancelRetry: u,
    continueRetry: h
  };
}
const up = console;
function Gx() {
  let t = [], e = 0, r = (h) => {
    h();
  }, n = (h) => {
    h();
  };
  const i = (h) => {
    let f;
    e++;
    try {
      f = h();
    } finally {
      e--, e || o();
    }
    return f;
  }, s = (h) => {
    e ? t.push(h) : My(() => {
      r(h);
    });
  }, a = (h) => (...f) => {
    s(() => {
      h(...f);
    });
  }, o = () => {
    const h = t;
    t = [], h.length && My(() => {
      n(() => {
        h.forEach((f) => {
          r(f);
        });
      });
    });
  };
  return {
    batch: i,
    batchCalls: a,
    schedule: s,
    setNotifyFunction: (h) => {
      r = h;
    },
    setBatchNotifyFunction: (h) => {
      n = h;
    }
  };
}
const Yt = Gx();
class Ab {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Td(this.cacheTime) && (this.gcTimeout = setTimeout(() => {
      this.optionalRemove();
    }, this.cacheTime));
  }
  updateCacheTime(e) {
    this.cacheTime = Math.max(this.cacheTime || 0, e ?? (Pa ? 1 / 0 : 5 * 60 * 1e3));
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }
}
class Zx extends Ab {
  constructor(e) {
    super(), this.abortSignalConsumed = !1, this.defaultOptions = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.cache = e.cache, this.logger = e.logger || up, this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.initialState = e.state || Yx(this.options), this.state = this.initialState, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(e) {
    this.options = {
      ...this.defaultOptions,
      ...e
    }, this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.cache.remove(this);
  }
  setData(e, r) {
    const n = Nd(this.state.data, e, this.options);
    return this.dispatch({
      data: n,
      type: "success",
      dataUpdatedAt: r == null ? void 0 : r.updatedAt,
      manual: r == null ? void 0 : r.manual
    }), n;
  }
  setState(e, r) {
    this.dispatch({
      type: "setState",
      state: e,
      setStateOptions: r
    });
  }
  cancel(e) {
    var r;
    const n = this.promise;
    return (r = this.retryer) == null || r.cancel(e), n ? n.then(bn).catch(bn) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({
      silent: !0
    });
  }
  reset() {
    this.destroy(), this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((e) => e.options.enabled !== !1);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((e) => e.getCurrentResult().isStale);
  }
  isStaleByTime(e = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !Cb(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var e;
    const r = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    r && r.refetch({
      cancelRefetch: !1
    }), (e = this.retryer) == null || e.continue();
  }
  onOnline() {
    var e;
    const r = this.observers.find((n) => n.shouldFetchOnReconnect());
    r && r.refetch({
      cancelRefetch: !1
    }), (e = this.retryer) == null || e.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: e
    }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((r) => r !== e), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({
      revert: !0
    }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: e
    }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }
  fetch(e, r) {
    var n, i;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && r != null && r.cancelRefetch)
        this.cancel({
          silent: !0
        });
      else if (this.promise) {
        var s;
        return (s = this.retryer) == null || s.continueRetry(), this.promise;
      }
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const m = this.observers.find((w) => w.options.queryFn);
      m && this.setOptions(m.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"));
    const a = Kx(), o = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    }, l = (m) => {
      Object.defineProperty(m, "signal", {
        enumerable: !0,
        get: () => {
          if (a)
            return this.abortSignalConsumed = !0, a.signal;
        }
      });
    };
    l(o);
    const u = () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(o)) : Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'"), h = {
      fetchOptions: r,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: u
    };
    if (l(h), (n = this.options.behavior) == null || n.onFetch(h), this.revertState = this.state, this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((i = h.fetchOptions) == null ? void 0 : i.meta)) {
      var f;
      this.dispatch({
        type: "fetch",
        meta: (f = h.fetchOptions) == null ? void 0 : f.meta
      });
    }
    const g = (m) => {
      if (ou(m) && m.silent || this.dispatch({
        type: "error",
        error: m
      }), !ou(m)) {
        var w, S, x, M;
        (w = (S = this.cache.config).onError) == null || w.call(S, m, this), (x = (M = this.cache.config).onSettled) == null || x.call(M, this.state.data, m, this), process.env.NODE_ENV !== "production" && this.logger.error(m);
      }
      this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return this.retryer = Nb({
      fn: h.fetchFn,
      abort: a == null ? void 0 : a.abort.bind(a),
      onSuccess: (m) => {
        var w, S, x, M;
        if (typeof m > "u") {
          process.env.NODE_ENV !== "production" && this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash), g(new Error(this.queryHash + " data is undefined"));
          return;
        }
        this.setData(m), (w = (S = this.cache.config).onSuccess) == null || w.call(S, m, this), (x = (M = this.cache.config).onSettled) == null || x.call(M, m, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: g,
      onFail: (m, w) => {
        this.dispatch({
          type: "failed",
          failureCount: m,
          error: w
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: h.options.retry,
      retryDelay: h.options.retryDelay,
      networkMode: h.options.networkMode
    }), this.promise = this.retryer.promise, this.promise;
  }
  dispatch(e) {
    const r = (n) => {
      var i, s;
      switch (e.type) {
        case "failed":
          return {
            ...n,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error
          };
        case "pause":
          return {
            ...n,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...n,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...n,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (i = e.meta) != null ? i : null,
            fetchStatus: ml(this.options.networkMode) ? "fetching" : "paused",
            ...!n.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...n,
            data: e.data,
            dataUpdateCount: n.dataUpdateCount + 1,
            dataUpdatedAt: (s = e.dataUpdatedAt) != null ? s : Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const a = e.error;
          return ou(a) && a.revert && this.revertState ? {
            ...this.revertState,
            fetchStatus: "idle"
          } : {
            ...n,
            error: a,
            errorUpdateCount: n.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: n.fetchFailureCount + 1,
            fetchFailureReason: a,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...n,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...n,
            ...e.state
          };
      }
    };
    this.state = r(this.state), Yt.batch(() => {
      this.observers.forEach((n) => {
        n.onQueryUpdate(e);
      }), this.cache.notify({
        query: this,
        type: "updated",
        action: e
      });
    });
  }
}
function Yx(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, r = typeof e < "u", n = r ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "loading",
    fetchStatus: "idle"
  };
}
class Qx extends Sc {
  constructor(e) {
    super(), this.config = e || {}, this.queries = [], this.queriesMap = {};
  }
  build(e, r, n) {
    var i;
    const s = r.queryKey, a = (i = r.queryHash) != null ? i : cp(s, r);
    let o = this.get(a);
    return o || (o = new Zx({
      cache: this,
      logger: e.getLogger(),
      queryKey: s,
      queryHash: a,
      options: e.defaultQueryOptions(r),
      state: n,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(o)), o;
  }
  add(e) {
    this.queriesMap[e.queryHash] || (this.queriesMap[e.queryHash] = e, this.queries.push(e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const r = this.queriesMap[e.queryHash];
    r && (e.destroy(), this.queries = this.queries.filter((n) => n !== e), r === e && delete this.queriesMap[e.queryHash], this.notify({
      type: "removed",
      query: e
    }));
  }
  clear() {
    Yt.batch(() => {
      this.queries.forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.queriesMap[e];
  }
  getAll() {
    return this.queries;
  }
  find(e, r) {
    const [n] = Ni(e, r);
    return typeof n.exact > "u" && (n.exact = !0), this.queries.find((i) => Ry(n, i));
  }
  findAll(e, r) {
    const [n] = Ni(e, r);
    return Object.keys(n).length > 0 ? this.queries.filter((i) => Ry(n, i)) : this.queries;
  }
  notify(e) {
    Yt.batch(() => {
      this.listeners.forEach(({
        listener: r
      }) => {
        r(e);
      });
    });
  }
  onFocus() {
    Yt.batch(() => {
      this.queries.forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    Yt.batch(() => {
      this.queries.forEach((e) => {
        e.onOnline();
      });
    });
  }
}
class Jx extends Ab {
  constructor(e) {
    super(), this.defaultOptions = e.defaultOptions, this.mutationId = e.mutationId, this.mutationCache = e.mutationCache, this.logger = e.logger || up, this.observers = [], this.state = e.state || Xx(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = {
      ...this.defaultOptions,
      ...e
    }, this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(e) {
    this.dispatch({
      type: "setState",
      state: e
    });
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.mutationCache.notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    this.observers = this.observers.filter((r) => r !== e), this.scheduleGc(), this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    this.observers.length || (this.state.status === "loading" ? this.scheduleGc() : this.mutationCache.remove(this));
  }
  continue() {
    var e, r;
    return (e = (r = this.retryer) == null ? void 0 : r.continue()) != null ? e : this.execute();
  }
  async execute() {
    const e = () => {
      var c;
      return this.retryer = Nb({
        fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject("No mutationFn found"),
        onFail: (p, D) => {
          this.dispatch({
            type: "failed",
            failureCount: p,
            error: D
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (c = this.options.retry) != null ? c : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      }), this.retryer.promise;
    }, r = this.state.status === "loading";
    try {
      var n, i, s, a, o, l, u, h;
      if (!r) {
        var f, g, m, w;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        }), await ((f = (g = this.mutationCache.config).onMutate) == null ? void 0 : f.call(g, this.state.variables, this));
        const p = await ((m = (w = this.options).onMutate) == null ? void 0 : m.call(w, this.state.variables));
        p !== this.state.context && this.dispatch({
          type: "loading",
          context: p,
          variables: this.state.variables
        });
      }
      const c = await e();
      return await ((n = (i = this.mutationCache.config).onSuccess) == null ? void 0 : n.call(i, c, this.state.variables, this.state.context, this)), await ((s = (a = this.options).onSuccess) == null ? void 0 : s.call(a, c, this.state.variables, this.state.context)), await ((o = (l = this.mutationCache.config).onSettled) == null ? void 0 : o.call(l, c, null, this.state.variables, this.state.context, this)), await ((u = (h = this.options).onSettled) == null ? void 0 : u.call(h, c, null, this.state.variables, this.state.context)), this.dispatch({
        type: "success",
        data: c
      }), c;
    } catch (c) {
      try {
        var S, x, M, _, I, b, E, y;
        throw await ((S = (x = this.mutationCache.config).onError) == null ? void 0 : S.call(x, c, this.state.variables, this.state.context, this)), process.env.NODE_ENV !== "production" && this.logger.error(c), await ((M = (_ = this.options).onError) == null ? void 0 : M.call(_, c, this.state.variables, this.state.context)), await ((I = (b = this.mutationCache.config).onSettled) == null ? void 0 : I.call(b, void 0, c, this.state.variables, this.state.context, this)), await ((E = (y = this.options).onSettled) == null ? void 0 : E.call(y, void 0, c, this.state.variables, this.state.context)), c;
      } finally {
        this.dispatch({
          type: "error",
          error: c
        });
      }
    }
  }
  dispatch(e) {
    const r = (n) => {
      switch (e.type) {
        case "failed":
          return {
            ...n,
            failureCount: e.failureCount,
            failureReason: e.error
          };
        case "pause":
          return {
            ...n,
            isPaused: !0
          };
        case "continue":
          return {
            ...n,
            isPaused: !1
          };
        case "loading":
          return {
            ...n,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !ml(this.options.networkMode),
            status: "loading",
            variables: e.variables
          };
        case "success":
          return {
            ...n,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...n,
            data: void 0,
            error: e.error,
            failureCount: n.failureCount + 1,
            failureReason: e.error,
            isPaused: !1,
            status: "error"
          };
        case "setState":
          return {
            ...n,
            ...e.state
          };
      }
    };
    this.state = r(this.state), Yt.batch(() => {
      this.observers.forEach((n) => {
        n.onMutationUpdate(e);
      }), this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action: e
      });
    });
  }
}
function Xx() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0
  };
}
class eC extends Sc {
  constructor(e) {
    super(), this.config = e || {}, this.mutations = [], this.mutationId = 0;
  }
  build(e, r, n) {
    const i = new Jx({
      mutationCache: this,
      logger: e.getLogger(),
      mutationId: ++this.mutationId,
      options: e.defaultMutationOptions(r),
      state: n,
      defaultOptions: r.mutationKey ? e.getMutationDefaults(r.mutationKey) : void 0
    });
    return this.add(i), i;
  }
  add(e) {
    this.mutations.push(e), this.notify({
      type: "added",
      mutation: e
    });
  }
  remove(e) {
    this.mutations = this.mutations.filter((r) => r !== e), this.notify({
      type: "removed",
      mutation: e
    });
  }
  clear() {
    Yt.batch(() => {
      this.mutations.forEach((e) => {
        this.remove(e);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(e) {
    return typeof e.exact > "u" && (e.exact = !0), this.mutations.find((r) => Ny(e, r));
  }
  findAll(e) {
    return this.mutations.filter((r) => Ny(e, r));
  }
  notify(e) {
    Yt.batch(() => {
      this.listeners.forEach(({
        listener: r
      }) => {
        r(e);
      });
    });
  }
  resumePausedMutations() {
    var e;
    return this.resuming = ((e = this.resuming) != null ? e : Promise.resolve()).then(() => {
      const r = this.mutations.filter((n) => n.state.isPaused);
      return Yt.batch(() => r.reduce((n, i) => n.then(() => i.continue().catch(bn)), Promise.resolve()));
    }).then(() => {
      this.resuming = void 0;
    }), this.resuming;
  }
}
function tC() {
  return {
    onFetch: (t) => {
      t.fetchFn = () => {
        var e, r, n, i, s, a;
        const o = (e = t.fetchOptions) == null || (r = e.meta) == null ? void 0 : r.refetchPage, l = (n = t.fetchOptions) == null || (i = n.meta) == null ? void 0 : i.fetchMore, u = l == null ? void 0 : l.pageParam, h = (l == null ? void 0 : l.direction) === "forward", f = (l == null ? void 0 : l.direction) === "backward", g = ((s = t.state.data) == null ? void 0 : s.pages) || [], m = ((a = t.state.data) == null ? void 0 : a.pageParams) || [];
        let w = m, S = !1;
        const x = (y) => {
          Object.defineProperty(y, "signal", {
            enumerable: !0,
            get: () => {
              var c;
              if ((c = t.signal) != null && c.aborted)
                S = !0;
              else {
                var p;
                (p = t.signal) == null || p.addEventListener("abort", () => {
                  S = !0;
                });
              }
              return t.signal;
            }
          });
        }, M = t.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + t.options.queryHash + "'")), _ = (y, c, p, D) => (w = D ? [c, ...w] : [...w, c], D ? [p, ...y] : [...y, p]), I = (y, c, p, D) => {
          if (S)
            return Promise.reject("Cancelled");
          if (typeof p > "u" && !c && y.length)
            return Promise.resolve(y);
          const R = {
            queryKey: t.queryKey,
            pageParam: p,
            meta: t.options.meta
          };
          x(R);
          const k = M(R);
          return Promise.resolve(k).then((W) => _(y, p, W, D));
        };
        let b;
        if (!g.length)
          b = I([]);
        else if (h) {
          const y = typeof u < "u", c = y ? u : ky(t.options, g);
          b = I(g, y, c);
        } else if (f) {
          const y = typeof u < "u", c = y ? u : rC(t.options, g);
          b = I(g, y, c, !0);
        } else {
          w = [];
          const y = typeof t.options.getNextPageParam > "u";
          b = (o && g[0] ? o(g[0], 0, g) : !0) ? I([], y, m[0]) : Promise.resolve(_([], m[0], g[0]));
          for (let p = 1; p < g.length; p++)
            b = b.then((D) => {
              if (o && g[p] ? o(g[p], p, g) : !0) {
                const k = y ? m[p] : ky(t.options, D);
                return I(D, y, k);
              }
              return Promise.resolve(_(D, m[p], g[p]));
            });
        }
        return b.then((y) => ({
          pages: y,
          pageParams: w
        }));
      };
    }
  };
}
function ky(t, e) {
  return t.getNextPageParam == null ? void 0 : t.getNextPageParam(e[e.length - 1], e);
}
function rC(t, e) {
  return t.getPreviousPageParam == null ? void 0 : t.getPreviousPageParam(e[0], e);
}
class nC {
  constructor(e = {}) {
    this.queryCache = e.queryCache || new Qx(), this.mutationCache = e.mutationCache || new eC(), this.logger = e.logger || up, this.defaultOptions = e.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [], this.mountCount = 0, process.env.NODE_ENV !== "production" && e.logger && this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
  }
  mount() {
    this.mountCount++, this.mountCount === 1 && (this.unsubscribeFocus = Ou.subscribe(() => {
      Ou.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus());
    }), this.unsubscribeOnline = Ra.subscribe(() => {
      Ra.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline());
    }));
  }
  unmount() {
    var e, r;
    this.mountCount--, this.mountCount === 0 && ((e = this.unsubscribeFocus) == null || e.call(this), this.unsubscribeFocus = void 0, (r = this.unsubscribeOnline) == null || r.call(this), this.unsubscribeOnline = void 0);
  }
  isFetching(e, r) {
    const [n] = Ni(e, r);
    return n.fetchStatus = "fetching", this.queryCache.findAll(n).length;
  }
  isMutating(e) {
    return this.mutationCache.findAll({
      ...e,
      fetching: !0
    }).length;
  }
  getQueryData(e, r) {
    var n;
    return (n = this.queryCache.find(e, r)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(e, r, n) {
    const i = ma(e, r, n), s = this.getQueryData(i.queryKey);
    return s ? Promise.resolve(s) : this.fetchQuery(i);
  }
  getQueriesData(e) {
    return this.getQueryCache().findAll(e).map(({
      queryKey: r,
      state: n
    }) => {
      const i = n.data;
      return [r, i];
    });
  }
  setQueryData(e, r, n) {
    const i = this.queryCache.find(e), s = i == null ? void 0 : i.state.data, a = Vx(r, s);
    if (typeof a > "u")
      return;
    const o = ma(e), l = this.defaultQueryOptions(o);
    return this.queryCache.build(this, l).setData(a, {
      ...n,
      manual: !0
    });
  }
  setQueriesData(e, r, n) {
    return Yt.batch(() => this.getQueryCache().findAll(e).map(({
      queryKey: i
    }) => [i, this.setQueryData(i, r, n)]));
  }
  getQueryState(e, r) {
    var n;
    return (n = this.queryCache.find(e, r)) == null ? void 0 : n.state;
  }
  removeQueries(e, r) {
    const [n] = Ni(e, r), i = this.queryCache;
    Yt.batch(() => {
      i.findAll(n).forEach((s) => {
        i.remove(s);
      });
    });
  }
  resetQueries(e, r, n) {
    const [i, s] = Ni(e, r, n), a = this.queryCache, o = {
      type: "active",
      ...i
    };
    return Yt.batch(() => (a.findAll(i).forEach((l) => {
      l.reset();
    }), this.refetchQueries(o, s)));
  }
  cancelQueries(e, r, n) {
    const [i, s = {}] = Ni(e, r, n);
    typeof s.revert > "u" && (s.revert = !0);
    const a = Yt.batch(() => this.queryCache.findAll(i).map((o) => o.cancel(s)));
    return Promise.all(a).then(bn).catch(bn);
  }
  invalidateQueries(e, r, n) {
    const [i, s] = Ni(e, r, n);
    return Yt.batch(() => {
      var a, o;
      if (this.queryCache.findAll(i).forEach((u) => {
        u.invalidate();
      }), i.refetchType === "none")
        return Promise.resolve();
      const l = {
        ...i,
        type: (a = (o = i.refetchType) != null ? o : i.type) != null ? a : "active"
      };
      return this.refetchQueries(l, s);
    });
  }
  refetchQueries(e, r, n) {
    const [i, s] = Ni(e, r, n), a = Yt.batch(() => this.queryCache.findAll(i).filter((l) => !l.isDisabled()).map((l) => {
      var u;
      return l.fetch(void 0, {
        ...s,
        cancelRefetch: (u = s == null ? void 0 : s.cancelRefetch) != null ? u : !0,
        meta: {
          refetchPage: i.refetchPage
        }
      });
    }));
    let o = Promise.all(a).then(bn);
    return s != null && s.throwOnError || (o = o.catch(bn)), o;
  }
  fetchQuery(e, r, n) {
    const i = ma(e, r, n), s = this.defaultQueryOptions(i);
    typeof s.retry > "u" && (s.retry = !1);
    const a = this.queryCache.build(this, s);
    return a.isStaleByTime(s.staleTime) ? a.fetch(s) : Promise.resolve(a.state.data);
  }
  prefetchQuery(e, r, n) {
    return this.fetchQuery(e, r, n).then(bn).catch(bn);
  }
  fetchInfiniteQuery(e, r, n) {
    const i = ma(e, r, n);
    return i.behavior = tC(), this.fetchQuery(i);
  }
  prefetchInfiniteQuery(e, r, n) {
    return this.fetchInfiniteQuery(e, r, n).then(bn).catch(bn);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(e) {
    this.defaultOptions = e;
  }
  setQueryDefaults(e, r) {
    const n = this.queryDefaults.find((i) => ms(e) === ms(i.queryKey));
    n ? n.defaultOptions = r : this.queryDefaults.push({
      queryKey: e,
      defaultOptions: r
    });
  }
  getQueryDefaults(e) {
    if (!e)
      return;
    const r = this.queryDefaults.find((n) => no(e, n.queryKey));
    return process.env.NODE_ENV !== "production" && this.queryDefaults.filter((i) => no(e, i.queryKey)).length > 1 && this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(e) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults."), r == null ? void 0 : r.defaultOptions;
  }
  setMutationDefaults(e, r) {
    const n = this.mutationDefaults.find((i) => ms(e) === ms(i.mutationKey));
    n ? n.defaultOptions = r : this.mutationDefaults.push({
      mutationKey: e,
      defaultOptions: r
    });
  }
  getMutationDefaults(e) {
    if (!e)
      return;
    const r = this.mutationDefaults.find((n) => no(e, n.mutationKey));
    return process.env.NODE_ENV !== "production" && this.mutationDefaults.filter((i) => no(e, i.mutationKey)).length > 1 && this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(e) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults."), r == null ? void 0 : r.defaultOptions;
  }
  defaultQueryOptions(e) {
    if (e != null && e._defaulted)
      return e;
    const r = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(e == null ? void 0 : e.queryKey),
      ...e,
      _defaulted: !0
    };
    return !r.queryHash && r.queryKey && (r.queryHash = cp(r.queryKey, r)), typeof r.refetchOnReconnect > "u" && (r.refetchOnReconnect = r.networkMode !== "always"), typeof r.useErrorBoundary > "u" && (r.useErrorBoundary = !!r.suspense), r;
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted ? e : {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(e == null ? void 0 : e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear();
  }
}
class iC extends Sc {
  constructor(e, r) {
    super(), this.client = e, this.options = r, this.trackedProps = /* @__PURE__ */ new Set(), this.selectError = null, this.bindMethods(), this.setOptions(r);
  }
  bindMethods() {
    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (this.currentQuery.addObserver(this), Uy(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Ad(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return Ad(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this);
  }
  setOptions(e, r) {
    const n = this.options, i = this.currentQuery;
    if (this.options = this.client.defaultQueryOptions(e), process.env.NODE_ENV !== "production" && typeof (e == null ? void 0 : e.isDataEqual) < "u" && this.client.getLogger().error("The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option"), Pd(n, this.options) || this.client.getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: this.currentQuery,
      observer: this
    }), typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = n.queryKey), this.updateQuery();
    const s = this.hasListeners();
    s && $y(this.currentQuery, i, this.options, n) && this.executeFetch(), this.updateResult(r), s && (this.currentQuery !== i || this.options.enabled !== n.enabled || this.options.staleTime !== n.staleTime) && this.updateStaleTimeout();
    const a = this.computeRefetchInterval();
    s && (this.currentQuery !== i || this.options.enabled !== n.enabled || a !== this.currentRefetchInterval) && this.updateRefetchInterval(a);
  }
  getOptimisticResult(e) {
    const r = this.client.getQueryCache().build(this.client, e), n = this.createResult(r, e);
    return oC(this, n, e) && (this.currentResult = n, this.currentResultOptions = this.options, this.currentResultState = this.currentQuery.state), n;
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(e) {
    const r = {};
    return Object.keys(e).forEach((n) => {
      Object.defineProperty(r, n, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackedProps.add(n), e[n])
      });
    }), r;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage: e,
    ...r
  } = {}) {
    return this.fetch({
      ...r,
      meta: {
        refetchPage: e
      }
    });
  }
  fetchOptimistic(e) {
    const r = this.client.defaultQueryOptions(e), n = this.client.getQueryCache().build(this.client, r);
    return n.isFetchingOptimistic = !0, n.fetch().then(() => this.createResult(n, r));
  }
  fetch(e) {
    var r;
    return this.executeFetch({
      ...e,
      cancelRefetch: (r = e.cancelRefetch) != null ? r : !0
    }).then(() => (this.updateResult(), this.currentResult));
  }
  executeFetch(e) {
    this.updateQuery();
    let r = this.currentQuery.fetch(this.options, e);
    return e != null && e.throwOnError || (r = r.catch(bn)), r;
  }
  updateStaleTimeout() {
    if (this.clearStaleTimeout(), Pa || this.currentResult.isStale || !Td(this.options.staleTime))
      return;
    const r = Cb(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
    this.staleTimeoutId = setTimeout(() => {
      this.currentResult.isStale || this.updateResult();
    }, r);
  }
  computeRefetchInterval() {
    var e;
    return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (e = this.options.refetchInterval) != null ? e : !1;
  }
  updateRefetchInterval(e) {
    this.clearRefetchInterval(), this.currentRefetchInterval = e, !(Pa || this.options.enabled === !1 || !Td(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(() => {
      (this.options.refetchIntervalInBackground || Ou.isFocused()) && this.executeFetch();
    }, this.currentRefetchInterval));
  }
  updateTimers() {
    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);
  }
  clearRefetchInterval() {
    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);
  }
  createResult(e, r) {
    const n = this.currentQuery, i = this.options, s = this.currentResult, a = this.currentResultState, o = this.currentResultOptions, l = e !== n, u = l ? e.state : this.currentQueryInitialState, h = l ? this.currentResult : this.previousQueryResult, {
      state: f
    } = e;
    let {
      dataUpdatedAt: g,
      error: m,
      errorUpdatedAt: w,
      fetchStatus: S,
      status: x
    } = f, M = !1, _ = !1, I;
    if (r._optimisticResults) {
      const p = this.hasListeners(), D = !p && Uy(e, r), R = p && $y(e, n, r, i);
      (D || R) && (S = ml(e.options.networkMode) ? "fetching" : "paused", g || (x = "loading")), r._optimisticResults === "isRestoring" && (S = "idle");
    }
    if (r.keepPreviousData && !f.dataUpdatedAt && h != null && h.isSuccess && x !== "error")
      I = h.data, g = h.dataUpdatedAt, x = h.status, M = !0;
    else if (r.select && typeof f.data < "u")
      if (s && f.data === (a == null ? void 0 : a.data) && r.select === this.selectFn)
        I = this.selectResult;
      else
        try {
          this.selectFn = r.select, I = r.select(f.data), I = Nd(s == null ? void 0 : s.data, I, r), this.selectResult = I, this.selectError = null;
        } catch (p) {
          process.env.NODE_ENV !== "production" && this.client.getLogger().error(p), this.selectError = p;
        }
    else
      I = f.data;
    if (typeof r.placeholderData < "u" && typeof I > "u" && x === "loading") {
      let p;
      if (s != null && s.isPlaceholderData && r.placeholderData === (o == null ? void 0 : o.placeholderData))
        p = s.data;
      else if (p = typeof r.placeholderData == "function" ? r.placeholderData() : r.placeholderData, r.select && typeof p < "u")
        try {
          p = r.select(p), this.selectError = null;
        } catch (D) {
          process.env.NODE_ENV !== "production" && this.client.getLogger().error(D), this.selectError = D;
        }
      typeof p < "u" && (x = "success", I = Nd(s == null ? void 0 : s.data, p, r), _ = !0);
    }
    this.selectError && (m = this.selectError, I = this.selectResult, w = Date.now(), x = "error");
    const b = S === "fetching", E = x === "loading", y = x === "error";
    return {
      status: x,
      fetchStatus: S,
      isLoading: E,
      isSuccess: x === "success",
      isError: y,
      isInitialLoading: E && b,
      data: I,
      dataUpdatedAt: g,
      error: m,
      errorUpdatedAt: w,
      failureCount: f.fetchFailureCount,
      failureReason: f.fetchFailureReason,
      errorUpdateCount: f.errorUpdateCount,
      isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
      isFetchedAfterMount: f.dataUpdateCount > u.dataUpdateCount || f.errorUpdateCount > u.errorUpdateCount,
      isFetching: b,
      isRefetching: b && !E,
      isLoadingError: y && f.dataUpdatedAt === 0,
      isPaused: S === "paused",
      isPlaceholderData: _,
      isPreviousData: M,
      isRefetchError: y && f.dataUpdatedAt !== 0,
      isStale: lp(e, r),
      refetch: this.refetch,
      remove: this.remove
    };
  }
  updateResult(e) {
    const r = this.currentResult, n = this.createResult(this.currentQuery, this.options);
    if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, Pd(n, r))
      return;
    this.currentResult = n;
    const i = {
      cache: !0
    }, s = () => {
      if (!r)
        return !0;
      const {
        notifyOnChangeProps: a
      } = this.options, o = typeof a == "function" ? a() : a;
      if (o === "all" || !o && !this.trackedProps.size)
        return !0;
      const l = new Set(o ?? this.trackedProps);
      return this.options.useErrorBoundary && l.add("error"), Object.keys(this.currentResult).some((u) => {
        const h = u;
        return this.currentResult[h] !== r[h] && l.has(h);
      });
    };
    (e == null ? void 0 : e.listeners) !== !1 && s() && (i.listeners = !0), this.notify({
      ...i,
      ...e
    });
  }
  updateQuery() {
    const e = this.client.getQueryCache().build(this.client, this.options);
    if (e === this.currentQuery)
      return;
    const r = this.currentQuery;
    this.currentQuery = e, this.currentQueryInitialState = e.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (r == null || r.removeObserver(this), e.addObserver(this));
  }
  onQueryUpdate(e) {
    const r = {};
    e.type === "success" ? r.onSuccess = !e.manual : e.type === "error" && !ou(e.error) && (r.onError = !0), this.updateResult(r), this.hasListeners() && this.updateTimers();
  }
  notify(e) {
    Yt.batch(() => {
      if (e.onSuccess) {
        var r, n, i, s;
        (r = (n = this.options).onSuccess) == null || r.call(n, this.currentResult.data), (i = (s = this.options).onSettled) == null || i.call(s, this.currentResult.data, null);
      } else if (e.onError) {
        var a, o, l, u;
        (a = (o = this.options).onError) == null || a.call(o, this.currentResult.error), (l = (u = this.options).onSettled) == null || l.call(u, void 0, this.currentResult.error);
      }
      e.listeners && this.listeners.forEach(({
        listener: h
      }) => {
        h(this.currentResult);
      }), e.cache && this.client.getQueryCache().notify({
        query: this.currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
}
function sC(t, e) {
  return e.enabled !== !1 && !t.state.dataUpdatedAt && !(t.state.status === "error" && e.retryOnMount === !1);
}
function Uy(t, e) {
  return sC(t, e) || t.state.dataUpdatedAt > 0 && Ad(t, e, e.refetchOnMount);
}
function Ad(t, e, r) {
  if (e.enabled !== !1) {
    const n = typeof r == "function" ? r(t) : r;
    return n === "always" || n !== !1 && lp(t, e);
  }
  return !1;
}
function $y(t, e, r, n) {
  return r.enabled !== !1 && (t !== e || n.enabled === !1) && (!r.suspense || t.state.status !== "error") && lp(t, r);
}
function lp(t, e) {
  return t.isStaleByTime(e.staleTime);
}
function oC(t, e, r) {
  return r.keepPreviousData ? !1 : r.placeholderData !== void 0 ? e.isPlaceholderData : !Pd(t.getCurrentResult(), e);
}
var aC = ap();
const cC = aC.useSyncExternalStore, Fy = /* @__PURE__ */ Br.createContext(void 0), Lb = /* @__PURE__ */ Br.createContext(!1);
function Mb(t, e) {
  return t || (e && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = Fy), window.ReactQueryClientContext) : Fy);
}
const jb = ({
  context: t
} = {}) => {
  const e = Br.useContext(Mb(t, Br.useContext(Lb)));
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, uC = ({
  client: t,
  children: e,
  context: r,
  contextSharing: n = !1
}) => {
  Br.useEffect(() => (t.mount(), () => {
    t.unmount();
  }), [t]), process.env.NODE_ENV !== "production" && n && t.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
  const i = Mb(r, n);
  return /* @__PURE__ */ Br.createElement(Lb.Provider, {
    value: !r && n
  }, /* @__PURE__ */ Br.createElement(i.Provider, {
    value: t
  }, e));
}, kb = /* @__PURE__ */ Br.createContext(!1), lC = () => Br.useContext(kb);
kb.Provider;
function hC() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
const dC = /* @__PURE__ */ Br.createContext(hC()), fC = () => Br.useContext(dC);
function pC(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
const gC = (t, e) => {
  (t.suspense || t.useErrorBoundary) && (e.isReset() || (t.retryOnMount = !1));
}, yC = (t) => {
  Br.useEffect(() => {
    t.clearReset();
  }, [t]);
}, mC = ({
  result: t,
  errorResetBoundary: e,
  useErrorBoundary: r,
  query: n
}) => t.isError && !e.isReset() && !t.isFetching && pC(r, [t.error, n]), vC = (t) => {
  t.suspense && typeof t.staleTime != "number" && (t.staleTime = 1e3);
}, bC = (t, e) => t.isLoading && t.isFetching && !e, wC = (t, e, r) => (t == null ? void 0 : t.suspense) && bC(e, r), _C = (t, e, r) => e.fetchOptimistic(t).then(({
  data: n
}) => {
  t.onSuccess == null || t.onSuccess(n), t.onSettled == null || t.onSettled(n, null);
}).catch((n) => {
  r.clearReset(), t.onError == null || t.onError(n), t.onSettled == null || t.onSettled(void 0, n);
});
function EC(t, e) {
  const r = jb({
    context: t.context
  }), n = lC(), i = fC(), s = r.defaultQueryOptions(t);
  s._optimisticResults = n ? "isRestoring" : "optimistic", s.onError && (s.onError = Yt.batchCalls(s.onError)), s.onSuccess && (s.onSuccess = Yt.batchCalls(s.onSuccess)), s.onSettled && (s.onSettled = Yt.batchCalls(s.onSettled)), vC(s), gC(s, i), yC(i);
  const [a] = Br.useState(() => new e(r, s)), o = a.getOptimisticResult(s);
  if (cC(Br.useCallback((l) => {
    const u = n ? () => {
    } : a.subscribe(Yt.batchCalls(l));
    return a.updateResult(), u;
  }, [a, n]), () => a.getCurrentResult(), () => a.getCurrentResult()), Br.useEffect(() => {
    a.setOptions(s, {
      listeners: !1
    });
  }, [s, a]), wC(s, o, n))
    throw _C(s, a, i);
  if (mC({
    result: o,
    errorResetBoundary: i,
    useErrorBoundary: s.useErrorBoundary,
    query: a.getCurrentQuery()
  }))
    throw o.error;
  return s.notifyOnChangeProps ? o : a.trackResult(o);
}
function SC(t, e, r) {
  const n = ma(t, e, r);
  return EC(n, iC);
}
function hp() {
  const [t, e] = Ea(void 0), [r, n] = Ea(void 0), [i, s] = Ea(!1);
  return { data: t, error: r, loading: i, setData: e, setError: n, setLoading: s };
}
async function Ub(t, e) {
  const n = await (await Bt()).request(t);
  if (n === void 0 && e)
    throw console.error("Result is undefined, retrying..."), new Error("Result is undefined, retrying...");
  return n;
}
function Oc({ queryKey: t, wcParams: e, enabled: r, queryOptions: n }) {
  return SC(
    t,
    async () => Ub(e, t),
    n ?? {
      staleTime: t[0] === "getEvent" ? 7500 : 45e3,
      refetchInterval: t[0] === "getEvent" ? 5e3 : 3e4,
      refetchIntervalInBackground: !0,
      enabled: r,
      retry: !0
    }
  );
}
function Ic(t) {
  const { data: e, error: r, loading: n, setData: i, setError: s, setLoading: a } = hp();
  async function o(l) {
    try {
      a(!0), s(void 0);
      const u = await Ub(t ?? l);
      return i(u), u;
    } catch (u) {
      throw s(u), u;
    } finally {
      a(!1);
    }
  }
  return { data: e, error: r, loading: n, request: o };
}
const Ld = (t, e = !0, r = 4, n = !0) => t ? t.length < r ? t : n ? `(...${t.slice(-r)})` : t.length < r * 2 ? t : `${t.slice(
  0,
  r + (e ? 5 : 0)
)}...${t.slice(t.length - r, t.length)}` : "", F9 = () => {
  const t = _n(), [e, r, n] = Fi((u) => [u.account, u.setAccount, u.onDisconnect]), { refetch: i, data: s, error: a, isLoading: o } = Oc({
    queryKey: ["useAccount", t == null ? void 0 : t.topic],
    enabled: !!t,
    wcParams: {
      topic: t == null ? void 0 : t.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "getSelectedAccount"
      }
    }
  });
  Ec(({ params: u, topic: h }) => {
    if (u.event.name === "accountSelected" && t && t.topic === h) {
      const g = u.event.address ?? u.event.data.address, m = u.chainId.split(":")[0], w = u.chainId.split(":")[1];
      r({
        network: m,
        chainId: w,
        address: g,
        shortenedAddress: Ld(g)
      });
    }
  }), Ib(({ params: u, topic: h }) => {
    const f = u.event.address ?? u.event.data.address, g = u.chainId.split(":")[0], m = u.chainId.split(":")[1];
    r({
      network: g,
      chainId: m,
      address: f,
      shortenedAddress: Ld(f)
    });
  }), Ob(({ params: u, topic: h }) => {
    n();
  }), pr(() => {
    t && !o && i();
  }, [t == null ? void 0 : t.topic]), pr(() => {
    if (s) {
      const u = s, h = u == null ? void 0 : u.account;
      h && r(h);
    }
  }, [s]);
  const l = a ? a.message : s && s.error;
  return {
    account: e,
    error: l,
    loading: o
  };
}, q9 = ({ address: t, multisig: e }) => {
  const r = _n(), [n] = Fi((f) => [f.account]), { refetch: i, data: s, error: a, isLoading: o } = Oc({
    queryKey: ["useBalance", t, (n == null ? void 0 : n.address) ?? "", e, r == null ? void 0 : r.topic],
    enabled: !!r && !!n && (e ? !!t : !0),
    wcParams: {
      topic: r == null ? void 0 : r.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "getBalance",
        params: {
          assetId: void 0,
          address: t
        }
      }
    }
  });
  Ec(({ params: f, topic: g }) => {
    const m = f.event.name, w = f.event.address ?? f.event.data.address;
    (m === "selectedAccountSynced" && !e || m === "sharedAccountSynced" && e && w === t) && i();
  }), pr(() => {
    r && !o && i();
  }, [r == null ? void 0 : r.topic]);
  const l = a ? a.message : s && s.error, u = s;
  return { balances: u == null ? void 0 : u.balances, error: l, loading: o };
}, OC = Symbol(), qy = Object.getPrototypeOf, Md = /* @__PURE__ */ new WeakMap(), IC = (t) => t && (Md.has(t) ? Md.get(t) : qy(t) === Object.prototype || qy(t) === Array.prototype), xC = (t) => IC(t) && t[OC] || null, zy = (t, e = !0) => {
  Md.set(t, e);
};
var Iu = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const Uh = (t) => typeof t == "object" && t !== null, Ai = /* @__PURE__ */ new WeakMap(), Kc = /* @__PURE__ */ new WeakSet(), CC = (t = Object.is, e = (u, h) => new Proxy(u, h), r = (u) => Uh(u) && !Kc.has(u) && (Array.isArray(u) || !(Symbol.iterator in u)) && !(u instanceof WeakMap) && !(u instanceof WeakSet) && !(u instanceof Error) && !(u instanceof Number) && !(u instanceof Date) && !(u instanceof String) && !(u instanceof RegExp) && !(u instanceof ArrayBuffer), n = (u) => {
  switch (u.status) {
    case "fulfilled":
      return u.value;
    case "rejected":
      throw u.reason;
    default:
      throw u;
  }
}, i = /* @__PURE__ */ new WeakMap(), s = (u, h, f = n) => {
  const g = i.get(u);
  if ((g == null ? void 0 : g[0]) === h)
    return g[1];
  const m = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u));
  return zy(m, !0), i.set(u, [h, m]), Reflect.ownKeys(u).forEach((w) => {
    if (Object.getOwnPropertyDescriptor(m, w))
      return;
    const S = Reflect.get(u, w), x = {
      value: S,
      enumerable: !0,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: !0
    };
    if (Kc.has(S))
      zy(S, !1);
    else if (S instanceof Promise)
      delete x.value, x.get = () => f(S);
    else if (Ai.has(S)) {
      const [M, _] = Ai.get(
        S
      );
      x.value = s(
        M,
        _(),
        f
      );
    }
    Object.defineProperty(m, w, x);
  }), Object.preventExtensions(m);
}, a = /* @__PURE__ */ new WeakMap(), o = [1, 1], l = (u) => {
  if (!Uh(u))
    throw new Error("object required");
  const h = a.get(u);
  if (h)
    return h;
  let f = o[0];
  const g = /* @__PURE__ */ new Set(), m = (p, D = ++o[0]) => {
    f !== D && (f = D, g.forEach((R) => R(p, D)));
  };
  let w = o[1];
  const S = (p = ++o[1]) => (w !== p && !g.size && (w = p, M.forEach(([D]) => {
    const R = D[1](p);
    R > f && (f = R);
  })), f), x = (p) => (D, R) => {
    const k = [...D];
    k[1] = [p, ...k[1]], m(k, R);
  }, M = /* @__PURE__ */ new Map(), _ = (p, D) => {
    if ((Iu ? "production" : void 0) !== "production" && M.has(p))
      throw new Error("prop listener already exists");
    if (g.size) {
      const R = D[3](x(p));
      M.set(p, [D, R]);
    } else
      M.set(p, [D]);
  }, I = (p) => {
    var D;
    const R = M.get(p);
    R && (M.delete(p), (D = R[1]) == null || D.call(R));
  }, b = (p) => (g.add(p), g.size === 1 && M.forEach(([D, R], k) => {
    if ((Iu ? "production" : void 0) !== "production" && R)
      throw new Error("remove already exists");
    const B = D[3](x(k));
    M.set(k, [D, B]);
  }), () => {
    g.delete(p), g.size === 0 && M.forEach(([D, R], k) => {
      R && (R(), M.set(k, [D]));
    });
  }), E = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u)), y = e(E, {
    deleteProperty(p, D) {
      const R = Reflect.get(p, D);
      I(D);
      const k = Reflect.deleteProperty(p, D);
      return k && m(["delete", [D], R]), k;
    },
    set(p, D, R, k) {
      const B = Reflect.has(p, D), W = Reflect.get(p, D, k);
      if (B && (t(W, R) || a.has(R) && t(W, a.get(R))))
        return !0;
      I(D), Uh(R) && (R = xC(R) || R);
      let C = R;
      if (R instanceof Promise)
        R.then((N) => {
          R.status = "fulfilled", R.value = N, m(["resolve", [D], N]);
        }).catch((N) => {
          R.status = "rejected", R.reason = N, m(["reject", [D], N]);
        });
      else {
        !Ai.has(R) && r(R) && (C = l(R));
        const N = !Kc.has(C) && Ai.get(C);
        N && _(D, N);
      }
      return Reflect.set(p, D, C, k), m(["set", [D], R, W]), !0;
    }
  });
  a.set(u, y);
  const c = [
    E,
    S,
    s,
    b
  ];
  return Ai.set(y, c), Reflect.ownKeys(u).forEach((p) => {
    const D = Object.getOwnPropertyDescriptor(
      u,
      p
    );
    "value" in D && (y[p] = u[p], delete D.value, delete D.writable), Object.defineProperty(E, p, D);
  }), y;
}) => [
  // public functions
  l,
  // shared state
  Ai,
  Kc,
  // internal things
  t,
  e,
  r,
  n,
  i,
  s,
  a,
  o
], [DC] = CC();
function Ji(t = {}) {
  return DC(t);
}
function Ms(t, e, r) {
  const n = Ai.get(t);
  (Iu ? "production" : void 0) !== "production" && !n && console.warn("Please use proxy object");
  let i;
  const s = [], a = n[3];
  let o = !1;
  const l = a((u) => {
    if (s.push(u), r) {
      e(s.splice(0));
      return;
    }
    i || (i = Promise.resolve().then(() => {
      i = void 0, o && e(s.splice(0));
    }));
  });
  return o = !0, () => {
    o = !1, l();
  };
}
function TC(t, e) {
  const r = Ai.get(t);
  (Iu ? "production" : void 0) !== "production" && !r && console.warn("Please use proxy object");
  const [n, i, s] = r;
  return s(n, i(), e);
}
const nr = Ji({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 }), $b = { state: nr, subscribe(t) {
  return Ms(nr, () => t(nr));
}, push(t, e) {
  t !== nr.view && (nr.view = t, e && (nr.data = e), nr.history.push(t));
}, reset(t) {
  nr.view = t, nr.history = [t];
}, replace(t) {
  nr.history.length > 1 && (nr.history[nr.history.length - 1] = t, nr.view = t);
}, goBack() {
  if (nr.history.length > 1) {
    nr.history.pop();
    const [t] = nr.history.slice(-1);
    nr.view = t;
  }
}, setData(t) {
  nr.data = t;
} }, Dr = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", WCM_VERSION: "WCM_VERSION", RECOMMENDED_WALLET_AMOUNT: 9, isMobile() {
  return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
}, isAndroid() {
  return Dr.isMobile() && navigator.userAgent.toLowerCase().includes("android");
}, isIos() {
  const t = navigator.userAgent.toLowerCase();
  return Dr.isMobile() && (t.includes("iphone") || t.includes("ipad"));
}, isHttpUrl(t) {
  return t.startsWith("http://") || t.startsWith("https://");
}, isArray(t) {
  return Array.isArray(t) && t.length > 0;
}, formatNativeUrl(t, e, r) {
  if (Dr.isHttpUrl(t))
    return this.formatUniversalUrl(t, e, r);
  let n = t;
  n.includes("://") || (n = t.replaceAll("/", "").replaceAll(":", ""), n = `${n}://`), n.endsWith("/") || (n = `${n}/`), this.setWalletConnectDeepLink(n, r);
  const i = encodeURIComponent(e);
  return `${n}wc?uri=${i}`;
}, formatUniversalUrl(t, e, r) {
  if (!Dr.isHttpUrl(t))
    return this.formatNativeUrl(t, e, r);
  let n = t;
  n.endsWith("/") || (n = `${n}/`), this.setWalletConnectDeepLink(n, r);
  const i = encodeURIComponent(e);
  return `${n}wc?uri=${i}`;
}, async wait(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}, openHref(t, e) {
  window.open(t, e, "noreferrer noopener");
}, setWalletConnectDeepLink(t, e) {
  try {
    localStorage.setItem(Dr.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t, name: e }));
  } catch {
    console.info("Unable to set WalletConnect deep link");
  }
}, setWalletConnectAndroidDeepLink(t) {
  try {
    const [e] = t.split("?");
    localStorage.setItem(Dr.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e, name: "Android" }));
  } catch {
    console.info("Unable to set WalletConnect android deep link");
  }
}, removeWalletConnectDeepLink() {
  try {
    localStorage.removeItem(Dr.WALLETCONNECT_DEEPLINK_CHOICE);
  } catch {
    console.info("Unable to remove WalletConnect deep link");
  }
}, setModalVersionInStorage() {
  try {
    typeof localStorage < "u" && localStorage.setItem(Dr.WCM_VERSION, "2.6.2");
  } catch {
    console.info("Unable to set Web3Modal version in storage");
  }
}, getWalletRouterData() {
  var t;
  const e = (t = $b.state.data) == null ? void 0 : t.Wallet;
  if (!e)
    throw new Error('Missing "Wallet" view data');
  return e;
} }, PC = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https")), _r = Ji({ enabled: PC, userSessionId: "", events: [], connectedWalletId: void 0 }), RC = { state: _r, subscribe(t) {
  return Ms(_r.events, () => t(TC(_r.events[_r.events.length - 1])));
}, initialize() {
  _r.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (_r.userSessionId = crypto.randomUUID());
}, setConnectedWalletId(t) {
  _r.connectedWalletId = t;
}, click(t) {
  if (_r.enabled) {
    const e = { type: "CLICK", name: t.name, userSessionId: _r.userSessionId, timestamp: Date.now(), data: t };
    _r.events.push(e);
  }
}, track(t) {
  if (_r.enabled) {
    const e = { type: "TRACK", name: t.name, userSessionId: _r.userSessionId, timestamp: Date.now(), data: t };
    _r.events.push(e);
  }
}, view(t) {
  if (_r.enabled) {
    const e = { type: "VIEW", name: t.name, userSessionId: _r.userSessionId, timestamp: Date.now(), data: t };
    _r.events.push(e);
  }
} }, Hn = Ji({ chains: void 0, walletConnectUri: void 0, isAuth: !1, isCustomDesktop: !1, isCustomMobile: !1, isDataLoaded: !1, isUiLoaded: !1 }), Pn = { state: Hn, subscribe(t) {
  return Ms(Hn, () => t(Hn));
}, setChains(t) {
  Hn.chains = t;
}, setWalletConnectUri(t) {
  Hn.walletConnectUri = t;
}, setIsCustomDesktop(t) {
  Hn.isCustomDesktop = t;
}, setIsCustomMobile(t) {
  Hn.isCustomMobile = t;
}, setIsDataLoaded(t) {
  Hn.isDataLoaded = t;
}, setIsUiLoaded(t) {
  Hn.isUiLoaded = t;
}, setIsAuth(t) {
  Hn.isAuth = t;
} }, Bc = Ji({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chains: void 0, enableAuthMode: !1, enableExplorer: !0, explorerExcludedWalletIds: void 0, explorerRecommendedWalletIds: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 }), Eo = { state: Bc, subscribe(t) {
  return Ms(Bc, () => t(Bc));
}, setConfig(t) {
  var e, r;
  RC.initialize(), Pn.setChains(t.chains), Pn.setIsAuth(!!t.enableAuthMode), Pn.setIsCustomMobile(!!((e = t.mobileWallets) != null && e.length)), Pn.setIsCustomDesktop(!!((r = t.desktopWallets) != null && r.length)), Dr.setModalVersionInStorage(), Object.assign(Bc, t);
} };
var NC = Object.defineProperty, Vy = Object.getOwnPropertySymbols, AC = Object.prototype.hasOwnProperty, LC = Object.prototype.propertyIsEnumerable, Ky = (t, e, r) => e in t ? NC(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, MC = (t, e) => {
  for (var r in e || (e = {}))
    AC.call(e, r) && Ky(t, r, e[r]);
  if (Vy)
    for (var r of Vy(e))
      LC.call(e, r) && Ky(t, r, e[r]);
  return t;
};
const jd = "https://explorer-api.walletconnect.com", kd = "wcm", Ud = "js-2.6.2";
async function Hc(t, e) {
  const r = MC({ sdkType: kd, sdkVersion: Ud }, e), n = new URL(t, jd);
  return n.searchParams.append("projectId", Eo.state.projectId), Object.entries(r).forEach(([i, s]) => {
    s && n.searchParams.append(i, String(s));
  }), (await fetch(n)).json();
}
const cs = { async getDesktopListings(t) {
  return Hc("/w3m/v1/getDesktopListings", t);
}, async getMobileListings(t) {
  return Hc("/w3m/v1/getMobileListings", t);
}, async getInjectedListings(t) {
  return Hc("/w3m/v1/getInjectedListings", t);
}, async getAllListings(t) {
  return Hc("/w3m/v1/getAllListings", t);
}, getWalletImageUrl(t) {
  return `${jd}/w3m/v1/getWalletImage/${t}?projectId=${Eo.state.projectId}&sdkType=${kd}&sdkVersion=${Ud}`;
}, getAssetImageUrl(t) {
  return `${jd}/w3m/v1/getAssetImage/${t}?projectId=${Eo.state.projectId}&sdkType=${kd}&sdkVersion=${Ud}`;
} };
var jC = Object.defineProperty, By = Object.getOwnPropertySymbols, kC = Object.prototype.hasOwnProperty, UC = Object.prototype.propertyIsEnumerable, Hy = (t, e, r) => e in t ? jC(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, $C = (t, e) => {
  for (var r in e || (e = {}))
    kC.call(e, r) && Hy(t, r, e[r]);
  if (By)
    for (var r of By(e))
      UC.call(e, r) && Hy(t, r, e[r]);
  return t;
};
const Wy = Dr.isMobile(), Wn = Ji({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, recomendedWallets: [] }), z9 = { state: Wn, async getRecomendedWallets() {
  const { explorerRecommendedWalletIds: t, explorerExcludedWalletIds: e } = Eo.state;
  if (t === "NONE" || e === "ALL" && !t)
    return Wn.recomendedWallets;
  if (Dr.isArray(t)) {
    const r = { recommendedIds: t.join(",") }, { listings: n } = await cs.getAllListings(r), i = Object.values(n);
    i.sort((s, a) => {
      const o = t.indexOf(s.id), l = t.indexOf(a.id);
      return o - l;
    }), Wn.recomendedWallets = i;
  } else {
    const { chains: r, isAuth: n } = Pn.state, i = r == null ? void 0 : r.join(","), s = Dr.isArray(e), a = { page: 1, sdks: n ? "auth_v1" : void 0, entries: Dr.RECOMMENDED_WALLET_AMOUNT, chains: i, version: 2, excludedIds: s ? e.join(",") : void 0 }, { listings: o } = Wy ? await cs.getMobileListings(a) : await cs.getDesktopListings(a);
    Wn.recomendedWallets = Object.values(o);
  }
  return Wn.recomendedWallets;
}, async getWallets(t) {
  const e = $C({}, t), { explorerRecommendedWalletIds: r, explorerExcludedWalletIds: n } = Eo.state, { recomendedWallets: i } = Wn;
  if (n === "ALL")
    return Wn.wallets;
  i.length ? e.excludedIds = i.map((f) => f.id).join(",") : Dr.isArray(r) && (e.excludedIds = r.join(",")), Dr.isArray(n) && (e.excludedIds = [e.excludedIds, n].filter(Boolean).join(",")), Pn.state.isAuth && (e.sdks = "auth_v1");
  const { page: s, search: a } = t, { listings: o, total: l } = Wy ? await cs.getMobileListings(e) : await cs.getDesktopListings(e), u = Object.values(o), h = a ? "search" : "wallets";
  return Wn[h] = { listings: [...Wn[h].listings, ...u], total: l, page: s ?? 1 }, { listings: u, total: l };
}, getWalletImageUrl(t) {
  return cs.getWalletImageUrl(t);
}, getAssetImageUrl(t) {
  return cs.getAssetImageUrl(t);
}, resetSearch() {
  Wn.search = { listings: [], total: 0, page: 1 };
} }, Ks = Ji({ open: !1 }), $h = { state: Ks, subscribe(t) {
  return Ms(Ks, () => t(Ks));
}, async open(t) {
  return new Promise((e) => {
    const { isUiLoaded: r, isDataLoaded: n } = Pn.state;
    if (Dr.removeWalletConnectDeepLink(), Pn.setWalletConnectUri(t == null ? void 0 : t.uri), Pn.setChains(t == null ? void 0 : t.chains), $b.reset("ConnectWallet"), r && n)
      Ks.open = !0, e();
    else {
      const i = setInterval(() => {
        const s = Pn.state;
        s.isUiLoaded && s.isDataLoaded && (clearInterval(i), Ks.open = !0, e());
      }, 200);
    }
  });
}, close() {
  Ks.open = !1;
} };
var FC = Object.defineProperty, Gy = Object.getOwnPropertySymbols, qC = Object.prototype.hasOwnProperty, zC = Object.prototype.propertyIsEnumerable, Zy = (t, e, r) => e in t ? FC(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, VC = (t, e) => {
  for (var r in e || (e = {}))
    qC.call(e, r) && Zy(t, r, e[r]);
  if (Gy)
    for (var r of Gy(e))
      zC.call(e, r) && Zy(t, r, e[r]);
  return t;
};
function KC() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
const sa = Ji({ themeMode: KC() ? "dark" : "light" }), Yy = { state: sa, subscribe(t) {
  return Ms(sa, () => t(sa));
}, setThemeConfig(t) {
  const { themeMode: e, themeVariables: r } = t;
  e && (sa.themeMode = e), r && (sa.themeVariables = VC({}, r));
} }, us = Ji({ open: !1, message: "", variant: "success" }), V9 = { state: us, subscribe(t) {
  return Ms(us, () => t(us));
}, openToast(t, e) {
  us.open = !0, us.message = t, us.variant = e;
}, closeToast() {
  us.open = !1;
} };
let BC = class {
  constructor(t) {
    this.openModal = $h.open, this.closeModal = $h.close, this.subscribeModal = $h.subscribe, this.setTheme = Yy.setThemeConfig, Yy.setThemeConfig(t), Eo.setConfig(t), this.initUi();
  }
  async initUi() {
    if (typeof window < "u") {
      await import("./index-TCIuvnDh-F_hbXbfh.js");
      const t = document.createElement("wcm-modal");
      document.body.insertAdjacentElement("beforeend", t), Pn.setIsUiLoaded(!0);
    }
  }
};
var ki = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vl(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function bl(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var dp = { exports: {} }, uo = typeof Reflect == "object" ? Reflect : null, Qy = uo && typeof uo.apply == "function" ? uo.apply : function(t, e, r) {
  return Function.prototype.apply.call(t, e, r);
}, au;
uo && typeof uo.ownKeys == "function" ? au = uo.ownKeys : Object.getOwnPropertySymbols ? au = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : au = function(t) {
  return Object.getOwnPropertyNames(t);
};
function HC(t) {
  console && console.warn && console.warn(t);
}
var Fb = Number.isNaN || function(t) {
  return t !== t;
};
function Tt() {
  Tt.init.call(this);
}
dp.exports = Tt;
dp.exports.once = YC;
Tt.EventEmitter = Tt;
Tt.prototype._events = void 0;
Tt.prototype._eventsCount = 0;
Tt.prototype._maxListeners = void 0;
var Jy = 10;
function wl(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(Tt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Jy;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || Fb(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    Jy = t;
  }
});
Tt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Tt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || Fb(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function qb(t) {
  return t._maxListeners === void 0 ? Tt.defaultMaxListeners : t._maxListeners;
}
Tt.prototype.getMaxListeners = function() {
  return qb(this);
};
Tt.prototype.emit = function(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e.push(arguments[r]);
  var n = t === "error", i = this._events;
  if (i !== void 0)
    n = n && i.error === void 0;
  else if (!n)
    return !1;
  if (n) {
    var s;
    if (e.length > 0 && (s = e[0]), s instanceof Error)
      throw s;
    var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
    throw a.context = s, a;
  }
  var o = i[t];
  if (o === void 0)
    return !1;
  if (typeof o == "function")
    Qy(o, this, e);
  else
    for (var l = o.length, u = Hb(o, l), r = 0; r < l; ++r)
      Qy(u[r], this, e);
  return !0;
};
function zb(t, e, r, n) {
  var i, s, a;
  if (wl(r), s = t._events, s === void 0 ? (s = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), s = t._events), a = s[e]), a === void 0)
    a = s[e] = r, ++t._eventsCount;
  else if (typeof a == "function" ? a = s[e] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), i = qb(t), i > 0 && a.length > i && !a.warned) {
    a.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = t, o.type = e, o.count = a.length, HC(o);
  }
  return t;
}
Tt.prototype.addListener = function(t, e) {
  return zb(this, t, e, !1);
};
Tt.prototype.on = Tt.prototype.addListener;
Tt.prototype.prependListener = function(t, e) {
  return zb(this, t, e, !0);
};
function WC() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Vb(t, e, r) {
  var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = WC.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
Tt.prototype.once = function(t, e) {
  return wl(e), this.on(t, Vb(this, t, e)), this;
};
Tt.prototype.prependOnceListener = function(t, e) {
  return wl(e), this.prependListener(t, Vb(this, t, e)), this;
};
Tt.prototype.removeListener = function(t, e) {
  var r, n, i, s, a;
  if (wl(e), n = this._events, n === void 0)
    return this;
  if (r = n[t], r === void 0)
    return this;
  if (r === e || r.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[t], n.removeListener && this.emit("removeListener", t, r.listener || e));
  else if (typeof r != "function") {
    for (i = -1, s = r.length - 1; s >= 0; s--)
      if (r[s] === e || r[s].listener === e) {
        a = r[s].listener, i = s;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? r.shift() : GC(r, i), r.length === 1 && (n[t] = r[0]), n.removeListener !== void 0 && this.emit("removeListener", t, a || e);
  }
  return this;
};
Tt.prototype.off = Tt.prototype.removeListener;
Tt.prototype.removeAllListeners = function(t) {
  var e, r, n;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var i = Object.keys(r), s;
    for (n = 0; n < i.length; ++n)
      s = i[n], s !== "removeListener" && this.removeAllListeners(s);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = r[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (n = e.length - 1; n >= 0; n--)
      this.removeListener(t, e[n]);
  return this;
};
function Kb(t, e, r) {
  var n = t._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? ZC(i) : Hb(i, i.length);
}
Tt.prototype.listeners = function(t) {
  return Kb(this, t, !0);
};
Tt.prototype.rawListeners = function(t) {
  return Kb(this, t, !1);
};
Tt.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : Bb.call(t, e);
};
Tt.prototype.listenerCount = Bb;
function Bb(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Tt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? au(this._events) : [];
};
function Hb(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n)
    r[n] = t[n];
  return r;
}
function GC(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function ZC(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function YC(t, e) {
  return new Promise(function(r, n) {
    function i(a) {
      t.removeListener(e, s), n(a);
    }
    function s() {
      typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments));
    }
    Wb(t, e, s, { once: !0 }), e !== "error" && QC(t, i, { once: !0 });
  });
}
function QC(t, e, r) {
  typeof t.on == "function" && Wb(t, "error", e, r);
}
function Wb(t, e, r, n) {
  if (typeof t.on == "function")
    n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(s) {
      n.once && t.removeEventListener(e, i), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var En = dp.exports;
const fp = /* @__PURE__ */ vl(En), JC = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, XC = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, eD = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function tD(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    rD(t);
    return;
  }
  return e;
}
function rD(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function Wc(t, e = {}) {
  if (typeof t != "string")
    return t;
  const r = t.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t[0] === '"' && t.at(-1) === '"' && !t.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const n = r.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!eD.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (JC.test(t) || XC.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, tD);
    }
    return JSON.parse(t);
  } catch (n) {
    if (e.strict)
      throw n;
    return t;
  }
}
function nD(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function sr(t, ...e) {
  try {
    return nD(t(...e));
  } catch (r) {
    return Promise.reject(r);
  }
}
function iD(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function sD(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function cu(t) {
  if (iD(t))
    return String(t);
  if (sD(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return cu(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function Gb() {
  if (typeof Buffer === void 0)
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const $d = "base64:";
function oD(t) {
  if (typeof t == "string")
    return t;
  Gb();
  const e = Buffer.from(t).toString("base64");
  return $d + e;
}
function aD(t) {
  return typeof t != "string" || !t.startsWith($d) ? t : (Gb(), Buffer.from(t.slice($d.length), "base64"));
}
function en(t) {
  return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function cD(...t) {
  return en(t.join(":"));
}
function Gc(t) {
  return t = en(t), t ? t + ":" : "";
}
const uD = "memory", lD = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: uD,
    options: {},
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, r) {
      t.set(e, r);
    },
    setItemRaw(e, r) {
      t.set(e, r);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return Array.from(t.keys());
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function hD(t = {}) {
  const e = {
    mounts: { "": t.driver || lD() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (u) => {
    for (const h of e.mountpoints)
      if (u.startsWith(h))
        return {
          base: h,
          relativeKey: u.slice(h.length),
          driver: e.mounts[h]
        };
    return {
      base: "",
      relativeKey: u,
      driver: e.mounts[""]
    };
  }, n = (u, h) => e.mountpoints.filter(
    (f) => f.startsWith(u) || h && u.startsWith(f)
  ).map((f) => ({
    relativeBase: u.length > f.length ? u.slice(f.length) : void 0,
    mountpoint: f,
    driver: e.mounts[f]
  })), i = (u, h) => {
    if (e.watching) {
      h = en(h);
      for (const f of e.watchListeners)
        f(u, h);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const u in e.mounts)
        e.unwatch[u] = await Xy(
          e.mounts[u],
          i,
          u
        );
    }
  }, a = async () => {
    if (e.watching) {
      for (const u in e.unwatch)
        await e.unwatch[u]();
      e.unwatch = {}, e.watching = !1;
    }
  }, o = (u, h, f) => {
    const g = /* @__PURE__ */ new Map(), m = (w) => {
      let S = g.get(w.base);
      return S || (S = {
        driver: w.driver,
        base: w.base,
        items: []
      }, g.set(w.base, S)), S;
    };
    for (const w of u) {
      const S = typeof w == "string", x = en(S ? w : w.key), M = S ? void 0 : w.value, _ = S || !w.options ? h : { ...h, ...w.options }, I = r(x);
      m(I).items.push({
        key: x,
        value: M,
        relativeKey: I.relativeKey,
        options: _
      });
    }
    return Promise.all([...g.values()].map((w) => f(w))).then(
      (w) => w.flat()
    );
  }, l = {
    // Item
    hasItem(u, h = {}) {
      u = en(u);
      const { relativeKey: f, driver: g } = r(u);
      return sr(g.hasItem, f, h);
    },
    getItem(u, h = {}) {
      u = en(u);
      const { relativeKey: f, driver: g } = r(u);
      return sr(g.getItem, f, h).then(
        (m) => Wc(m)
      );
    },
    getItems(u, h) {
      return o(u, h, (f) => f.driver.getItems ? sr(
        f.driver.getItems,
        f.items.map((g) => ({
          key: g.relativeKey,
          options: g.options
        })),
        h
      ).then(
        (g) => g.map((m) => ({
          key: cD(f.base, m.key),
          value: Wc(m.value)
        }))
      ) : Promise.all(
        f.items.map((g) => sr(
          f.driver.getItem,
          g.relativeKey,
          g.options
        ).then((m) => ({
          key: g.key,
          value: Wc(m)
        })))
      ));
    },
    getItemRaw(u, h = {}) {
      u = en(u);
      const { relativeKey: f, driver: g } = r(u);
      return g.getItemRaw ? sr(g.getItemRaw, f, h) : sr(g.getItem, f, h).then(
        (m) => aD(m)
      );
    },
    async setItem(u, h, f = {}) {
      if (h === void 0)
        return l.removeItem(u);
      u = en(u);
      const { relativeKey: g, driver: m } = r(u);
      m.setItem && (await sr(m.setItem, g, cu(h), f), m.watch || i("update", u));
    },
    async setItems(u, h) {
      await o(u, h, async (f) => {
        f.driver.setItems && await sr(
          f.driver.setItems,
          f.items.map((g) => ({
            key: g.relativeKey,
            value: cu(g.value),
            options: g.options
          })),
          h
        ), f.driver.setItem && await Promise.all(
          f.items.map((g) => sr(
            f.driver.setItem,
            g.relativeKey,
            cu(g.value),
            g.options
          ))
        );
      });
    },
    async setItemRaw(u, h, f = {}) {
      if (h === void 0)
        return l.removeItem(u, f);
      u = en(u);
      const { relativeKey: g, driver: m } = r(u);
      if (m.setItemRaw)
        await sr(m.setItemRaw, g, h, f);
      else if (m.setItem)
        await sr(m.setItem, g, oD(h), f);
      else
        return;
      m.watch || i("update", u);
    },
    async removeItem(u, h = {}) {
      typeof h == "boolean" && (h = { removeMeta: h }), u = en(u);
      const { relativeKey: f, driver: g } = r(u);
      g.removeItem && (await sr(g.removeItem, f, h), (h.removeMeta || h.removeMata) && await sr(g.removeItem, f + "$", h), g.watch || i("remove", u));
    },
    // Meta
    async getMeta(u, h = {}) {
      typeof h == "boolean" && (h = { nativeOnly: h }), u = en(u);
      const { relativeKey: f, driver: g } = r(u), m = /* @__PURE__ */ Object.create(null);
      if (g.getMeta && Object.assign(m, await sr(g.getMeta, f, h)), !h.nativeOnly) {
        const w = await sr(
          g.getItem,
          f + "$",
          h
        ).then((S) => Wc(S));
        w && typeof w == "object" && (typeof w.atime == "string" && (w.atime = new Date(w.atime)), typeof w.mtime == "string" && (w.mtime = new Date(w.mtime)), Object.assign(m, w));
      }
      return m;
    },
    setMeta(u, h, f = {}) {
      return this.setItem(u + "$", h, f);
    },
    removeMeta(u, h = {}) {
      return this.removeItem(u + "$", h);
    },
    // Keys
    async getKeys(u, h = {}) {
      u = Gc(u);
      const f = n(u, !0);
      let g = [];
      const m = [];
      for (const w of f) {
        const S = (await sr(
          w.driver.getKeys,
          w.relativeBase,
          h
        )).map((x) => w.mountpoint + en(x)).filter((x) => !g.some((M) => x.startsWith(M)));
        m.push(...S), g = [
          w.mountpoint,
          ...g.filter((x) => !x.startsWith(w.mountpoint))
        ];
      }
      return u ? m.filter((w) => w.startsWith(u) && !w.endsWith("$")) : m.filter((w) => !w.endsWith("$"));
    },
    // Utils
    async clear(u, h = {}) {
      u = Gc(u), await Promise.all(
        n(u, !1).map(async (f) => {
          if (f.driver.clear)
            return sr(f.driver.clear, f.relativeBase, h);
          if (f.driver.removeItem) {
            const g = await f.driver.getKeys(f.relativeBase || "", h);
            return Promise.all(
              g.map((m) => f.driver.removeItem(m, h))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((u) => em(u))
      );
    },
    async watch(u) {
      return await s(), e.watchListeners.push(u), async () => {
        e.watchListeners = e.watchListeners.filter(
          (h) => h !== u
        ), e.watchListeners.length === 0 && await a();
      };
    },
    async unwatch() {
      e.watchListeners = [], await a();
    },
    // Mount
    mount(u, h) {
      if (u = Gc(u), u && e.mounts[u])
        throw new Error(`already mounted at ${u}`);
      return u && (e.mountpoints.push(u), e.mountpoints.sort((f, g) => g.length - f.length)), e.mounts[u] = h, e.watching && Promise.resolve(Xy(h, i, u)).then((f) => {
        e.unwatch[u] = f;
      }).catch(console.error), l;
    },
    async unmount(u, h = !0) {
      u = Gc(u), !(!u || !e.mounts[u]) && (e.watching && u in e.unwatch && (e.unwatch[u](), delete e.unwatch[u]), h && await em(e.mounts[u]), e.mountpoints = e.mountpoints.filter((f) => f !== u), delete e.mounts[u]);
    },
    getMount(u = "") {
      u = en(u) + ":";
      const h = r(u);
      return {
        driver: h.driver,
        base: h.base
      };
    },
    getMounts(u = "", h = {}) {
      return u = en(u), n(u, h.parents).map((f) => ({
        driver: f.driver,
        base: f.mountpoint
      }));
    }
  };
  return l;
}
function Xy(t, e, r) {
  return t.watch ? t.watch((n, i) => e(n, r + i)) : () => {
  };
}
async function em(t) {
  typeof t.dispose == "function" && await sr(t.dispose);
}
function js(t) {
  return new Promise((e, r) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error);
  });
}
function Zb(t, e) {
  const r = indexedDB.open(t);
  r.onupgradeneeded = () => r.result.createObjectStore(e);
  const n = js(r);
  return (i, s) => n.then((a) => s(a.transaction(e, i).objectStore(e)));
}
let Fh;
function xc() {
  return Fh || (Fh = Zb("keyval-store", "keyval")), Fh;
}
function tm(t, e = xc()) {
  return e("readonly", (r) => js(r.get(t)));
}
function dD(t, e, r = xc()) {
  return r("readwrite", (n) => (n.put(e, t), js(n.transaction)));
}
function fD(t, e = xc()) {
  return e("readwrite", (r) => (r.delete(t), js(r.transaction)));
}
function pD(t = xc()) {
  return t("readwrite", (e) => (e.clear(), js(e.transaction)));
}
function gD(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, js(t.transaction);
}
function yD(t = xc()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return js(e.getAllKeys());
    const r = [];
    return gD(e, (n) => r.push(n.key)).then(() => r);
  });
}
const mD = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), vD = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function _l(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return vD(t);
  } catch {
    return t;
  }
}
function Cc(t) {
  return typeof t == "string" ? t : mD(t) || "";
}
const bD = "idb-keyval";
var wD = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", r = (i) => e + i;
  let n;
  return t.dbName && t.storeName && (n = Zb(t.dbName, t.storeName)), { name: bD, options: t, async hasItem(i) {
    return !(typeof await tm(r(i), n) > "u");
  }, async getItem(i) {
    return await tm(r(i), n) ?? null;
  }, setItem(i, s) {
    return dD(r(i), s, n);
  }, removeItem(i) {
    return fD(r(i), n);
  }, getKeys() {
    return yD(n);
  }, clear() {
    return pD(n);
  } };
};
const _D = "WALLET_CONNECT_V2_INDEXED_DB", ED = "keyvaluestorage";
let SD = class {
  constructor() {
    this.indexedDb = hD({ driver: wD({ dbName: _D, storeName: ED }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null)
      return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, Cc(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var qh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, uu = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, t.prototype.setItem = function(r, n) {
    this[r] = String(n);
  }, t.prototype.removeItem = function(r) {
    delete this[r];
  }, t.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(n) {
      r[n] = void 0, delete r[n];
    });
  }, t.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof qh < "u" && qh.localStorage ? uu.exports = qh.localStorage : typeof window < "u" && window.localStorage ? uu.exports = window.localStorage : uu.exports = new e();
})();
function OD(t) {
  var e;
  return [t[0], _l((e = t[1]) != null ? e : "")];
}
class ID {
  constructor() {
    this.localStorage = uu.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(OD);
  }
  async getItem(e) {
    const r = this.localStorage.getItem(e);
    if (r !== null)
      return _l(r);
  }
  async setItem(e, r) {
    this.localStorage.setItem(e, Cc(r));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
}
const xD = "wc_storage_version", rm = 1, CD = async (t, e, r) => {
  const n = xD, i = await e.getItem(n);
  if (i && i >= rm) {
    r(e);
    return;
  }
  const s = await t.getKeys();
  if (!s.length) {
    r(e);
    return;
  }
  const a = [];
  for (; s.length; ) {
    const o = s.shift();
    if (!o)
      continue;
    const l = o.toLowerCase();
    if (l.includes("wc@") || l.includes("walletconnect") || l.includes("wc_") || l.includes("wallet_connect")) {
      const u = await t.getItem(o);
      await e.setItem(o, u), a.push(o);
    }
  }
  await e.setItem(n, rm), r(e), DD(t, a);
}, DD = async (t, e) => {
  e.length && e.forEach(async (r) => {
    await t.removeItem(r);
  });
};
let TD = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (e) => {
      this.storage = e, this.initialized = !0;
    };
    const t = new ID();
    this.storage = t;
    try {
      const e = new SD();
      CD(t, e, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};
var Mo = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Fd = function(t, e) {
  return Fd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n)
      n.hasOwnProperty(i) && (r[i] = n[i]);
  }, Fd(t, e);
};
function PD(t, e) {
  Fd(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var qd = function() {
  return qd = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, qd.apply(this, arguments);
};
function RD(t, e) {
  var r = {};
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function ND(t, e, r, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, r, n);
  else
    for (var o = t.length - 1; o >= 0; o--)
      (a = t[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, r, s) : a(e, r)) || s);
  return i > 3 && s && Object.defineProperty(e, r, s), s;
}
function AD(t, e) {
  return function(r, n) {
    e(r, n, t);
  };
}
function LD(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function MD(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(a) {
      a(s);
    });
  }
  return new (r || (r = Promise))(function(s, a) {
    function o(h) {
      try {
        u(n.next(h));
      } catch (f) {
        a(f);
      }
    }
    function l(h) {
      try {
        u(n.throw(h));
      } catch (f) {
        a(f);
      }
    }
    function u(h) {
      h.done ? s(h.value) : i(h.value).then(o, l);
    }
    u((n = n.apply(t, e || [])).next());
  });
}
function jD(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(u) {
    return function(h) {
      return l([u, h]);
    };
  }
  function l(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done)
          return s;
        switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: !1 };
          case 5:
            r.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < s[1]) {
              r.label = s[1], s = u;
              break;
            }
            if (s && r.label < s[2]) {
              r.label = s[2], r.ops.push(u);
              break;
            }
            s[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (h) {
        u = [6, h], i = 0;
      } finally {
        n = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function kD(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}
function UD(t, e) {
  for (var r in t)
    r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function zd(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Yb(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}
function $D() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(Yb(arguments[e]));
  return t;
}
function FD() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++)
    t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var s = arguments[e], a = 0, o = s.length; a < o; a++, i++)
      n[i] = s[a];
  return n;
}
function Na(t) {
  return this instanceof Na ? (this.v = t, this) : new Na(t);
}
function qD(t, e, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), i, s = [];
  return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function a(g) {
    n[g] && (i[g] = function(m) {
      return new Promise(function(w, S) {
        s.push([g, m, w, S]) > 1 || o(g, m);
      });
    });
  }
  function o(g, m) {
    try {
      l(n[g](m));
    } catch (w) {
      f(s[0][3], w);
    }
  }
  function l(g) {
    g.value instanceof Na ? Promise.resolve(g.value.v).then(u, h) : f(s[0][2], g);
  }
  function u(g) {
    o("next", g);
  }
  function h(g) {
    o("throw", g);
  }
  function f(g, m) {
    g(m), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function zD(t) {
  var e, r;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = t[i] ? function(a) {
      return (r = !r) ? { value: Na(t[i](a)), done: i === "return" } : s ? s(a) : a;
    } : s;
  }
}
function VD(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof zd == "function" ? zd(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(s) {
    r[s] = t[s] && function(a) {
      return new Promise(function(o, l) {
        a = t[s](a), i(o, l, a.done, a.value);
      });
    };
  }
  function i(s, a, o, l) {
    Promise.resolve(l).then(function(u) {
      s({ value: u, done: o });
    }, a);
  }
}
function KD(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function BD(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function HD(t) {
  return t && t.__esModule ? t : { default: t };
}
function WD(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function GD(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const ZD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return qd;
  },
  __asyncDelegator: zD,
  __asyncGenerator: qD,
  __asyncValues: VD,
  __await: Na,
  __awaiter: MD,
  __classPrivateFieldGet: WD,
  __classPrivateFieldSet: GD,
  __createBinding: kD,
  __decorate: ND,
  __exportStar: UD,
  __extends: PD,
  __generator: jD,
  __importDefault: HD,
  __importStar: BD,
  __makeTemplateObject: KD,
  __metadata: LD,
  __param: AD,
  __read: Yb,
  __rest: RD,
  __spread: $D,
  __spreadArrays: FD,
  __values: zd
}, Symbol.toStringTag, { value: "Module" })), ii = /* @__PURE__ */ bl(ZD);
var oa = {}, Ae = {}, nm = {}, aa = {}, im;
function YD() {
  if (im)
    return aa;
  im = 1, Object.defineProperty(aa, "__esModule", { value: !0 }), aa.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return aa.delay = t, aa;
}
var ls = {}, sm = {}, Bs = {}, om;
function QD() {
  return om || (om = 1, Object.defineProperty(Bs, "__esModule", { value: !0 }), Bs.ONE_THOUSAND = Bs.ONE_HUNDRED = void 0, Bs.ONE_HUNDRED = 100, Bs.ONE_THOUSAND = 1e3), Bs;
}
var am = {}, cm;
function JD() {
  return cm || (cm = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(am)), am;
}
var um;
function Qb() {
  return um || (um = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = ii;
    e.__exportStar(QD(), t), e.__exportStar(JD(), t);
  }(sm)), sm;
}
var lm;
function XD() {
  if (lm)
    return ls;
  lm = 1, Object.defineProperty(ls, "__esModule", { value: !0 }), ls.fromMiliseconds = ls.toMiliseconds = void 0;
  const t = Qb();
  function e(n) {
    return n * t.ONE_THOUSAND;
  }
  ls.toMiliseconds = e;
  function r(n) {
    return Math.floor(n / t.ONE_THOUSAND);
  }
  return ls.fromMiliseconds = r, ls;
}
var hm;
function eT() {
  return hm || (hm = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = ii;
    e.__exportStar(YD(), t), e.__exportStar(XD(), t);
  }(nm)), nm;
}
var Hs = {}, dm;
function tT() {
  if (dm)
    return Hs;
  dm = 1, Object.defineProperty(Hs, "__esModule", { value: !0 }), Hs.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const n = this.get(r);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const i = Date.now() - n.started;
      this.timestamps.set(r, { started: n.started, elapsed: i });
    }
    get(r) {
      const n = this.timestamps.get(r);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return n;
    }
    elapsed(r) {
      const n = this.get(r);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return Hs.Watch = t, Hs.default = t, Hs;
}
var fm = {}, ca = {}, pm;
function rT() {
  if (pm)
    return ca;
  pm = 1, Object.defineProperty(ca, "__esModule", { value: !0 }), ca.IWatch = void 0;
  class t {
  }
  return ca.IWatch = t, ca;
}
var gm;
function nT() {
  return gm || (gm = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), ii.__exportStar(rT(), t);
  }(fm)), fm;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = ii;
  e.__exportStar(eT(), t), e.__exportStar(tT(), t), e.__exportStar(nT(), t), e.__exportStar(Qb(), t);
})(Ae);
var ym = {}, ua = {};
let ks = class {
};
const iT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: ks
}, Symbol.toStringTag, { value: "Module" })), sT = /* @__PURE__ */ bl(iT);
var mm;
function oT() {
  if (mm)
    return ua;
  mm = 1, Object.defineProperty(ua, "__esModule", { value: !0 }), ua.IHeartBeat = void 0;
  const t = sT;
  class e extends t.IEvents {
    constructor(n) {
      super();
    }
  }
  return ua.IHeartBeat = e, ua;
}
var vm;
function Jb() {
  return vm || (vm = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), ii.__exportStar(oT(), t);
  }(ym)), ym;
}
var bm = {}, hs = {}, wm;
function aT() {
  if (wm)
    return hs;
  wm = 1, Object.defineProperty(hs, "__esModule", { value: !0 }), hs.HEARTBEAT_EVENTS = hs.HEARTBEAT_INTERVAL = void 0;
  const t = Ae;
  return hs.HEARTBEAT_INTERVAL = t.FIVE_SECONDS, hs.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, hs;
}
var _m;
function Xb() {
  return _m || (_m = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), ii.__exportStar(aT(), t);
  }(bm)), bm;
}
var Em;
function cT() {
  if (Em)
    return oa;
  Em = 1, Object.defineProperty(oa, "__esModule", { value: !0 }), oa.HeartBeat = void 0;
  const t = ii, e = En, r = Ae, n = Jb(), i = Xb();
  class s extends n.IHeartBeat {
    constructor(o) {
      super(o), this.events = new e.EventEmitter(), this.interval = i.HEARTBEAT_INTERVAL, this.interval = (o == null ? void 0 : o.interval) || i.HEARTBEAT_INTERVAL;
    }
    static init(o) {
      return t.__awaiter(this, void 0, void 0, function* () {
        const l = new s(o);
        return yield l.init(), l;
      });
    }
    init() {
      return t.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(o, l) {
      this.events.on(o, l);
    }
    once(o, l) {
      this.events.once(o, l);
    }
    off(o, l) {
      this.events.off(o, l);
    }
    removeListener(o, l) {
      this.events.removeListener(o, l);
    }
    initialize() {
      return t.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), r.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(i.HEARTBEAT_EVENTS.pulse);
    }
  }
  return oa.HeartBeat = s, oa;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = ii;
  e.__exportStar(cT(), t), e.__exportStar(Jb(), t), e.__exportStar(Xb(), t);
})(Mo);
var wt = {}, zh, Sm;
function uT() {
  if (Sm)
    return zh;
  Sm = 1;
  function t(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
  zh = e;
  function e(r, n, i) {
    var s = i && i.stringify || t, a = 1;
    if (typeof r == "object" && r !== null) {
      var o = n.length + a;
      if (o === 1)
        return r;
      var l = new Array(o);
      l[0] = s(r);
      for (var u = 1; u < o; u++)
        l[u] = s(n[u]);
      return l.join(" ");
    }
    if (typeof r != "string")
      return r;
    var h = n.length;
    if (h === 0)
      return r;
    for (var f = "", g = 1 - a, m = -1, w = r && r.length || 0, S = 0; S < w; ) {
      if (r.charCodeAt(S) === 37 && S + 1 < w) {
        switch (m = m > -1 ? m : 0, r.charCodeAt(S + 1)) {
          case 100:
          case 102:
            if (g >= h || n[g] == null)
              break;
            m < S && (f += r.slice(m, S)), f += Number(n[g]), m = S + 2, S++;
            break;
          case 105:
            if (g >= h || n[g] == null)
              break;
            m < S && (f += r.slice(m, S)), f += Math.floor(Number(n[g])), m = S + 2, S++;
            break;
          case 79:
          case 111:
          case 106:
            if (g >= h || n[g] === void 0)
              break;
            m < S && (f += r.slice(m, S));
            var x = typeof n[g];
            if (x === "string") {
              f += "'" + n[g] + "'", m = S + 2, S++;
              break;
            }
            if (x === "function") {
              f += n[g].name || "<anonymous>", m = S + 2, S++;
              break;
            }
            f += s(n[g]), m = S + 2, S++;
            break;
          case 115:
            if (g >= h)
              break;
            m < S && (f += r.slice(m, S)), f += String(n[g]), m = S + 2, S++;
            break;
          case 37:
            m < S && (f += r.slice(m, S)), f += "%", m = S + 2, S++, g--;
            break;
        }
        ++g;
      }
      ++S;
    }
    return m === -1 ? r : (m < w && (f += r.slice(m)), f);
  }
  return zh;
}
var Vh, Om;
function lT() {
  if (Om)
    return Vh;
  Om = 1;
  const t = uT();
  Vh = i;
  const e = E().console || {}, r = {
    mapHttpRequest: w,
    mapHttpResponse: w,
    wrapRequestSerializer: S,
    wrapResponseSerializer: S,
    wrapErrorSerializer: S,
    req: w,
    res: w,
    err: g
  };
  function n(y, c) {
    return Array.isArray(y) ? y.filter(function(p) {
      return p !== "!stdSerializers.err";
    }) : y === !0 ? Object.keys(c) : !1;
  }
  function i(y) {
    y = y || {}, y.browser = y.browser || {};
    const c = y.browser.transmit;
    if (c && typeof c.send != "function")
      throw Error("pino: transmit option must have a send function");
    const p = y.browser.write || e;
    y.browser.write && (y.browser.asObject = !0);
    const D = y.serializers || {}, R = n(y.browser.serialize, D);
    let k = y.browser.serialize;
    Array.isArray(y.browser.serialize) && y.browser.serialize.indexOf("!stdSerializers.err") > -1 && (k = !1);
    const B = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof p == "function" && (p.error = p.fatal = p.warn = p.info = p.debug = p.trace = p), y.enabled === !1 && (y.level = "silent");
    const W = y.level || "info", C = Object.create(p);
    C.log || (C.log = x), Object.defineProperty(C, "levelVal", {
      get: G
    }), Object.defineProperty(C, "level", {
      get: z,
      set: $
    });
    const N = {
      transmit: c,
      serialize: R,
      asObject: y.browser.asObject,
      levels: B,
      timestamp: m(y)
    };
    C.levels = i.levels, C.level = W, C.setMaxListeners = C.getMaxListeners = C.emit = C.addListener = C.on = C.prependListener = C.once = C.prependOnceListener = C.removeListener = C.removeAllListeners = C.listeners = C.listenerCount = C.eventNames = C.write = C.flush = x, C.serializers = D, C._serialize = R, C._stdErrSerialize = k, C.child = q, c && (C._logEvent = f());
    function G() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function z() {
      return this._level;
    }
    function $(U) {
      if (U !== "silent" && !this.levels.values[U])
        throw Error("unknown level " + U);
      this._level = U, s(N, C, "error", "log"), s(N, C, "fatal", "error"), s(N, C, "warn", "error"), s(N, C, "info", "log"), s(N, C, "debug", "log"), s(N, C, "trace", "log");
    }
    function q(U, V) {
      if (!U)
        throw new Error("missing bindings for child Pino");
      V = V || {}, R && U.serializers && (V.serializers = U.serializers);
      const re = V.serializers;
      if (R && re) {
        var K = Object.assign({}, D, re), X = y.browser.serialize === !0 ? Object.keys(K) : R;
        delete U.serializers, l([U], X, K, this._stdErrSerialize);
      }
      function Y(ee) {
        this._childLevel = (ee._childLevel | 0) + 1, this.error = u(ee, U, "error"), this.fatal = u(ee, U, "fatal"), this.warn = u(ee, U, "warn"), this.info = u(ee, U, "info"), this.debug = u(ee, U, "debug"), this.trace = u(ee, U, "trace"), K && (this.serializers = K, this._serialize = X), c && (this._logEvent = f(
          [].concat(ee._logEvent.bindings, U)
        ));
      }
      return Y.prototype = this, new Y(this);
    }
    return C;
  }
  i.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, i.stdSerializers = r, i.stdTimeFunctions = Object.assign({}, { nullTime: M, epochTime: _, unixTime: I, isoTime: b });
  function s(y, c, p, D) {
    const R = Object.getPrototypeOf(c);
    c[p] = c.levelVal > c.levels.values[p] ? x : R[p] ? R[p] : e[p] || e[D] || x, a(y, c, p);
  }
  function a(y, c, p) {
    !y.transmit && c[p] === x || (c[p] = /* @__PURE__ */ function(D) {
      return function() {
        const R = y.timestamp(), k = new Array(arguments.length), B = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
        for (var W = 0; W < k.length; W++)
          k[W] = arguments[W];
        if (y.serialize && !y.asObject && l(k, this._serialize, this.serializers, this._stdErrSerialize), y.asObject ? D.call(B, o(this, p, k, R)) : D.apply(B, k), y.transmit) {
          const C = y.transmit.level || c.level, N = i.levels.values[C], G = i.levels.values[p];
          if (G < N)
            return;
          h(this, {
            ts: R,
            methodLevel: p,
            methodValue: G,
            transmitLevel: C,
            transmitValue: i.levels.values[y.transmit.level || c.level],
            send: y.transmit.send,
            val: c.levelVal
          }, k);
        }
      };
    }(c[p]));
  }
  function o(y, c, p, D) {
    y._serialize && l(p, y._serialize, y.serializers, y._stdErrSerialize);
    const R = p.slice();
    let k = R[0];
    const B = {};
    D && (B.time = D), B.level = i.levels.values[c];
    let W = (y._childLevel | 0) + 1;
    if (W < 1 && (W = 1), k !== null && typeof k == "object") {
      for (; W-- && typeof R[0] == "object"; )
        Object.assign(B, R.shift());
      k = R.length ? t(R.shift(), R) : void 0;
    } else
      typeof k == "string" && (k = t(R.shift(), R));
    return k !== void 0 && (B.msg = k), B;
  }
  function l(y, c, p, D) {
    for (const R in y)
      if (D && y[R] instanceof Error)
        y[R] = i.stdSerializers.err(y[R]);
      else if (typeof y[R] == "object" && !Array.isArray(y[R]))
        for (const k in y[R])
          c && c.indexOf(k) > -1 && k in p && (y[R][k] = p[k](y[R][k]));
  }
  function u(y, c, p) {
    return function() {
      const D = new Array(1 + arguments.length);
      D[0] = c;
      for (var R = 1; R < D.length; R++)
        D[R] = arguments[R - 1];
      return y[p].apply(this, D);
    };
  }
  function h(y, c, p) {
    const D = c.send, R = c.ts, k = c.methodLevel, B = c.methodValue, W = c.val, C = y._logEvent.bindings;
    l(
      p,
      y._serialize || Object.keys(y.serializers),
      y.serializers,
      y._stdErrSerialize === void 0 ? !0 : y._stdErrSerialize
    ), y._logEvent.ts = R, y._logEvent.messages = p.filter(function(N) {
      return C.indexOf(N) === -1;
    }), y._logEvent.level.label = k, y._logEvent.level.value = B, D(k, y._logEvent, W), y._logEvent = f(C);
  }
  function f(y) {
    return {
      ts: 0,
      messages: [],
      bindings: y || [],
      level: { label: "", value: 0 }
    };
  }
  function g(y) {
    const c = {
      type: y.constructor.name,
      msg: y.message,
      stack: y.stack
    };
    for (const p in y)
      c[p] === void 0 && (c[p] = y[p]);
    return c;
  }
  function m(y) {
    return typeof y.timestamp == "function" ? y.timestamp : y.timestamp === !1 ? M : _;
  }
  function w() {
    return {};
  }
  function S(y) {
    return y;
  }
  function x() {
  }
  function M() {
    return !1;
  }
  function _() {
    return Date.now();
  }
  function I() {
    return Math.round(Date.now() / 1e3);
  }
  function b() {
    return new Date(Date.now()).toISOString();
  }
  function E() {
    function y(c) {
      return typeof c < "u" && c;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return y(self) || y(window) || y(this) || {};
    }
  }
  return Vh;
}
var Ws = {}, Im;
function ew() {
  return Im || (Im = 1, Object.defineProperty(Ws, "__esModule", { value: !0 }), Ws.PINO_CUSTOM_CONTEXT_KEY = Ws.PINO_LOGGER_DEFAULTS = void 0, Ws.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, Ws.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), Ws;
}
var Ur = {}, xm;
function hT() {
  if (xm)
    return Ur;
  xm = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.generateChildLogger = Ur.formatChildLoggerContext = Ur.getLoggerContext = Ur.setBrowserLoggerContext = Ur.getBrowserLoggerContext = Ur.getDefaultLoggerOptions = void 0;
  const t = ew();
  function e(o) {
    return Object.assign(Object.assign({}, o), { level: (o == null ? void 0 : o.level) || t.PINO_LOGGER_DEFAULTS.level });
  }
  Ur.getDefaultLoggerOptions = e;
  function r(o, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    return o[l] || "";
  }
  Ur.getBrowserLoggerContext = r;
  function n(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    return o[u] = l, o;
  }
  Ur.setBrowserLoggerContext = n;
  function i(o, l = t.PINO_CUSTOM_CONTEXT_KEY) {
    let u = "";
    return typeof o.bindings > "u" ? u = r(o, l) : u = o.bindings().context || "", u;
  }
  Ur.getLoggerContext = i;
  function s(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    const h = i(o, u);
    return h.trim() ? `${h}/${l}` : l;
  }
  Ur.formatChildLoggerContext = s;
  function a(o, l, u = t.PINO_CUSTOM_CONTEXT_KEY) {
    const h = s(o, l, u), f = o.child({ context: h });
    return n(f, h, u);
  }
  return Ur.generateChildLogger = a, Ur;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.pino = void 0;
  const e = ii, r = e.__importDefault(lT());
  Object.defineProperty(t, "pino", { enumerable: !0, get: function() {
    return r.default;
  } }), e.__exportStar(ew(), t), e.__exportStar(hT(), t);
})(wt);
let dT = class extends ks {
  constructor(t) {
    super(), this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, fT = class extends ks {
  constructor(t, e) {
    super(), this.core = t, this.logger = e, this.records = /* @__PURE__ */ new Map();
  }
}, pT = class {
  constructor(t, e) {
    this.logger = t, this.core = e;
  }
}, gT = class extends ks {
  constructor(t, e) {
    super(), this.relayer = t, this.logger = e;
  }
}, yT = class extends ks {
  constructor(t) {
    super();
  }
}, mT = class {
  constructor(t, e, r, n) {
    this.core = t, this.logger = e, this.name = r;
  }
};
class vT extends ks {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}
class bT extends ks {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}
let wT = class {
  constructor(t, e) {
    this.projectId = t, this.logger = e;
  }
}, _T = class {
  constructor(t, e) {
    this.projectId = t, this.logger = e;
  }
}, ET = class {
  constructor(t) {
    this.opts = t, this.protocol = "wc", this.version = 2;
  }
};
(class extends En.EventEmitter {
  constructor() {
    super();
  }
});
let ST = class {
  constructor(t) {
    this.client = t;
  }
};
var pp = {}, jo = {}, El = {}, Sl = {};
Object.defineProperty(Sl, "__esModule", { value: !0 });
Sl.BrowserRandomSource = void 0;
const Cm = 65536;
class OT {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let n = 0; n < r.length; n += Cm)
      this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, Cm)));
    return r;
  }
}
Sl.BrowserRandomSource = OT;
function IT(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Ol = {}, yn = {};
Object.defineProperty(yn, "__esModule", { value: !0 });
function xT(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
yn.wipe = xT;
const CT = {}, DT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: CT
}, Symbol.toStringTag, { value: "Module" })), TT = /* @__PURE__ */ bl(DT);
Object.defineProperty(Ol, "__esModule", { value: !0 });
Ol.NodeRandomSource = void 0;
const PT = yn;
class RT {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof IT < "u") {
      const e = TT;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(e);
    for (let i = 0; i < n.length; i++)
      n[i] = r[i];
    return (0, PT.wipe)(r), n;
  }
}
Ol.NodeRandomSource = RT;
Object.defineProperty(El, "__esModule", { value: !0 });
El.SystemRandomSource = void 0;
const NT = Sl, AT = Ol;
class LT {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new NT.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new AT.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
El.SystemRandomSource = LT;
var nt = {}, tw = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(o, l) {
    var u = o >>> 16 & 65535, h = o & 65535, f = l >>> 16 & 65535, g = l & 65535;
    return h * g + (u * g + h * f << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(o, l) {
    return o + l | 0;
  }
  t.add = r;
  function n(o, l) {
    return o - l | 0;
  }
  t.sub = n;
  function i(o, l) {
    return o << l | o >>> 32 - l;
  }
  t.rotl = i;
  function s(o, l) {
    return o << 32 - l | o >>> l;
  }
  t.rotr = s;
  function a(o) {
    return typeof o == "number" && isFinite(o) && Math.floor(o) === o;
  }
  t.isInteger = Number.isInteger || a, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(o) {
    return t.isInteger(o) && o >= -t.MAX_SAFE_INTEGER && o <= t.MAX_SAFE_INTEGER;
  };
})(tw);
Object.defineProperty(nt, "__esModule", { value: !0 });
var rw = tw;
function MT(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
nt.readInt16BE = MT;
function jT(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
nt.readUint16BE = jT;
function kT(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
nt.readInt16LE = kT;
function UT(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
nt.readUint16LE = UT;
function nw(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
nt.writeUint16BE = nw;
nt.writeInt16BE = nw;
function iw(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
nt.writeUint16LE = iw;
nt.writeInt16LE = iw;
function Vd(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
nt.readInt32BE = Vd;
function Kd(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
nt.readUint32BE = Kd;
function Bd(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
nt.readInt32LE = Bd;
function Hd(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
nt.readUint32LE = Hd;
function xu(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
nt.writeUint32BE = xu;
nt.writeInt32BE = xu;
function Cu(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
nt.writeUint32LE = Cu;
nt.writeInt32LE = Cu;
function $T(t, e) {
  e === void 0 && (e = 0);
  var r = Vd(t, e), n = Vd(t, e + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
nt.readInt64BE = $T;
function FT(t, e) {
  e === void 0 && (e = 0);
  var r = Kd(t, e), n = Kd(t, e + 4);
  return r * 4294967296 + n;
}
nt.readUint64BE = FT;
function qT(t, e) {
  e === void 0 && (e = 0);
  var r = Bd(t, e), n = Bd(t, e + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
nt.readInt64LE = qT;
function zT(t, e) {
  e === void 0 && (e = 0);
  var r = Hd(t, e), n = Hd(t, e + 4);
  return n * 4294967296 + r;
}
nt.readUint64LE = zT;
function sw(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), xu(t / 4294967296 >>> 0, e, r), xu(t >>> 0, e, r + 4), e;
}
nt.writeUint64BE = sw;
nt.writeInt64BE = sw;
function ow(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Cu(t >>> 0, e, r), Cu(t / 4294967296 >>> 0, e, r + 4), e;
}
nt.writeUint64LE = ow;
nt.writeInt64LE = ow;
function VT(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = t / 8 + r - 1; s >= r; s--)
    n += e[s] * i, i *= 256;
  return n;
}
nt.readUintBE = VT;
function KT(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = r; s < r + t / 8; s++)
    n += e[s] * i, i *= 256;
  return n;
}
nt.readUintLE = KT;
function BT(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!rw.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = t / 8 + n - 1; s >= n; s--)
    r[s] = e / i & 255, i *= 256;
  return r;
}
nt.writeUintBE = BT;
function HT(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!rw.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = n; s < n + t / 8; s++)
    r[s] = e / i & 255, i *= 256;
  return r;
}
nt.writeUintLE = HT;
function WT(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
nt.readFloat32BE = WT;
function GT(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
nt.readFloat32LE = GT;
function ZT(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
nt.readFloat64BE = ZT;
function YT(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
nt.readFloat64LE = YT;
function QT(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t), e;
}
nt.writeFloat32BE = QT;
function JT(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t, !0), e;
}
nt.writeFloat32LE = JT;
function XT(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t), e;
}
nt.writeFloat64BE = XT;
function eP(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t, !0), e;
}
nt.writeFloat64LE = eP;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = El, r = nt, n = yn;
  t.defaultRandomSource = new e.SystemRandomSource();
  function i(u, h = t.defaultRandomSource) {
    return h.randomBytes(u);
  }
  t.randomBytes = i;
  function s(u = t.defaultRandomSource) {
    const h = i(4, u), f = (0, r.readUint32LE)(h);
    return (0, n.wipe)(h), f;
  }
  t.randomUint32 = s;
  const a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function o(u, h = a, f = t.defaultRandomSource) {
    if (h.length < 2)
      throw new Error("randomString charset is too short");
    if (h.length > 256)
      throw new Error("randomString charset is too long");
    let g = "";
    const m = h.length, w = 256 - 256 % m;
    for (; u > 0; ) {
      const S = i(Math.ceil(u * 256 / w), f);
      for (let x = 0; x < S.length && u > 0; x++) {
        const M = S[x];
        M < w && (g += h.charAt(M % m), u--);
      }
      (0, n.wipe)(S);
    }
    return g;
  }
  t.randomString = o;
  function l(u, h = a, f = t.defaultRandomSource) {
    const g = Math.ceil(u / (Math.log(h.length) / Math.LN2));
    return o(g, h, f);
  }
  t.randomStringForEntropy = l;
})(jo);
var aw = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = nt, r = yn;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function o() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return o.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, o.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, o.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, o.prototype.update = function(l, u) {
        if (u === void 0 && (u = l.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var h = 0;
        if (this._bytesHashed += u, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && u > 0; )
            this._buffer[this._bufferLength++] = l[h++], u--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (u >= this.blockSize && (h = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, l, h, u), u %= this.blockSize); u > 0; )
          this._buffer[this._bufferLength++] = l[h++], u--;
        return this;
      }, o.prototype.finish = function(l) {
        if (!this._finished) {
          var u = this._bytesHashed, h = this._bufferLength, f = u / 536870912 | 0, g = u << 3, m = u % 128 < 112 ? 128 : 256;
          this._buffer[h] = 128;
          for (var w = h + 1; w < m - 8; w++)
            this._buffer[w] = 0;
          e.writeUint32BE(f, this._buffer, m - 8), e.writeUint32BE(g, this._buffer, m - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, m), this._finished = !0;
        }
        for (var w = 0; w < this.digestLength / 8; w++)
          e.writeUint32BE(this._stateHi[w], l, w * 8), e.writeUint32BE(this._stateLo[w], l, w * 8 + 4);
        return this;
      }, o.prototype.digest = function() {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }, o.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, o.prototype.restoreState = function(l) {
        return this._stateHi.set(l.stateHi), this._stateLo.set(l.stateLo), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this;
      }, o.prototype.cleanSavedState = function(l) {
        r.wipe(l.stateHi), r.wipe(l.stateLo), l.buffer && r.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0;
      }, o;
    }()
  );
  t.SHA512 = n;
  var i = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(o, l, u, h, f, g, m) {
    for (var w = u[0], S = u[1], x = u[2], M = u[3], _ = u[4], I = u[5], b = u[6], E = u[7], y = h[0], c = h[1], p = h[2], D = h[3], R = h[4], k = h[5], B = h[6], W = h[7], C, N, G, z, $, q, U, V; m >= 128; ) {
      for (var re = 0; re < 16; re++) {
        var K = 8 * re + g;
        o[re] = e.readUint32BE(f, K), l[re] = e.readUint32BE(f, K + 4);
      }
      for (var re = 0; re < 80; re++) {
        var X = w, Y = S, ee = x, L = M, A = _, T = I, d = b, O = E, H = y, Z = c, me = p, we = D, ye = R, De = k, He = B, Ue = W;
        if (C = E, N = W, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = (_ >>> 14 | R << 18) ^ (_ >>> 18 | R << 14) ^ (R >>> 9 | _ << 23), N = (R >>> 14 | _ << 18) ^ (R >>> 18 | _ << 14) ^ (_ >>> 9 | R << 23), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = _ & I ^ ~_ & b, N = R & k ^ ~R & B, $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = i[re * 2], N = i[re * 2 + 1], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = o[re % 16], N = l[re % 16], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, G = U & 65535 | V << 16, z = $ & 65535 | q << 16, C = G, N = z, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = (w >>> 28 | y << 4) ^ (y >>> 2 | w << 30) ^ (y >>> 7 | w << 25), N = (y >>> 28 | w << 4) ^ (w >>> 2 | y << 30) ^ (w >>> 7 | y << 25), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, C = w & S ^ w & x ^ S & x, N = y & c ^ y & p ^ c & p, $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, O = U & 65535 | V << 16, Ue = $ & 65535 | q << 16, C = L, N = we, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = G, N = z, $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, L = U & 65535 | V << 16, we = $ & 65535 | q << 16, S = X, x = Y, M = ee, _ = L, I = A, b = T, E = d, w = O, c = H, p = Z, D = me, R = we, k = ye, B = De, W = He, y = Ue, re % 16 === 15)
          for (var K = 0; K < 16; K++)
            C = o[K], N = l[K], $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = o[(K + 9) % 16], N = l[(K + 9) % 16], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, G = o[(K + 1) % 16], z = l[(K + 1) % 16], C = (G >>> 1 | z << 31) ^ (G >>> 8 | z << 24) ^ G >>> 7, N = (z >>> 1 | G << 31) ^ (z >>> 8 | G << 24) ^ (z >>> 7 | G << 25), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, G = o[(K + 14) % 16], z = l[(K + 14) % 16], C = (G >>> 19 | z << 13) ^ (z >>> 29 | G << 3) ^ G >>> 6, N = (z >>> 19 | G << 13) ^ (G >>> 29 | z << 3) ^ (z >>> 6 | G << 26), $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, o[K] = U & 65535 | V << 16, l[K] = $ & 65535 | q << 16;
      }
      C = w, N = y, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[0], N = h[0], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[0] = w = U & 65535 | V << 16, h[0] = y = $ & 65535 | q << 16, C = S, N = c, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[1], N = h[1], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[1] = S = U & 65535 | V << 16, h[1] = c = $ & 65535 | q << 16, C = x, N = p, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[2], N = h[2], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[2] = x = U & 65535 | V << 16, h[2] = p = $ & 65535 | q << 16, C = M, N = D, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[3], N = h[3], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[3] = M = U & 65535 | V << 16, h[3] = D = $ & 65535 | q << 16, C = _, N = R, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[4], N = h[4], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[4] = _ = U & 65535 | V << 16, h[4] = R = $ & 65535 | q << 16, C = I, N = k, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[5], N = h[5], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[5] = I = U & 65535 | V << 16, h[5] = k = $ & 65535 | q << 16, C = b, N = B, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[6], N = h[6], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[6] = b = U & 65535 | V << 16, h[6] = B = $ & 65535 | q << 16, C = E, N = W, $ = N & 65535, q = N >>> 16, U = C & 65535, V = C >>> 16, C = u[7], N = h[7], $ += N & 65535, q += N >>> 16, U += C & 65535, V += C >>> 16, q += $ >>> 16, U += q >>> 16, V += U >>> 16, u[7] = E = U & 65535 | V << 16, h[7] = W = $ & 65535 | q << 16, g += 128, m -= 128;
    }
    return g;
  }
  function a(o) {
    var l = new n();
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.hash = a;
})(aw);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = jo, r = aw, n = yn;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function i(L) {
    const A = new Float64Array(16);
    if (L)
      for (let T = 0; T < L.length; T++)
        A[T] = L[T];
    return A;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const a = i(), o = i([1]), l = i([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), u = i([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), h = i([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), f = i([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), g = i([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function m(L, A) {
    for (let T = 0; T < 16; T++)
      L[T] = A[T] | 0;
  }
  function w(L) {
    let A = 1;
    for (let T = 0; T < 16; T++) {
      let d = L[T] + A + 65535;
      A = Math.floor(d / 65536), L[T] = d - A * 65536;
    }
    L[0] += A - 1 + 37 * (A - 1);
  }
  function S(L, A, T) {
    const d = ~(T - 1);
    for (let O = 0; O < 16; O++) {
      const H = d & (L[O] ^ A[O]);
      L[O] ^= H, A[O] ^= H;
    }
  }
  function x(L, A) {
    const T = i(), d = i();
    for (let O = 0; O < 16; O++)
      d[O] = A[O];
    w(d), w(d), w(d);
    for (let O = 0; O < 2; O++) {
      T[0] = d[0] - 65517;
      for (let Z = 1; Z < 15; Z++)
        T[Z] = d[Z] - 65535 - (T[Z - 1] >> 16 & 1), T[Z - 1] &= 65535;
      T[15] = d[15] - 32767 - (T[14] >> 16 & 1);
      const H = T[15] >> 16 & 1;
      T[14] &= 65535, S(d, T, 1 - H);
    }
    for (let O = 0; O < 16; O++)
      L[2 * O] = d[O] & 255, L[2 * O + 1] = d[O] >> 8;
  }
  function M(L, A) {
    let T = 0;
    for (let d = 0; d < 32; d++)
      T |= L[d] ^ A[d];
    return (1 & T - 1 >>> 8) - 1;
  }
  function _(L, A) {
    const T = new Uint8Array(32), d = new Uint8Array(32);
    return x(T, L), x(d, A), M(T, d);
  }
  function I(L) {
    const A = new Uint8Array(32);
    return x(A, L), A[0] & 1;
  }
  function b(L, A) {
    for (let T = 0; T < 16; T++)
      L[T] = A[2 * T] + (A[2 * T + 1] << 8);
    L[15] &= 32767;
  }
  function E(L, A, T) {
    for (let d = 0; d < 16; d++)
      L[d] = A[d] + T[d];
  }
  function y(L, A, T) {
    for (let d = 0; d < 16; d++)
      L[d] = A[d] - T[d];
  }
  function c(L, A, T) {
    let d, O, H = 0, Z = 0, me = 0, we = 0, ye = 0, De = 0, He = 0, Ue = 0, _e = 0, be = 0, de = 0, fe = 0, ue = 0, ae = 0, oe = 0, te = 0, pe = 0, ve = 0, ne = 0, Ee = 0, Ie = 0, Pe = 0, Re = 0, Te = 0, At = 0, Ft = 0, Qt = 0, It = 0, er = 0, tr = 0, an = 0, We = T[0], Fe = T[1], Qe = T[2], Ze = T[3], Je = T[4], qe = T[5], at = T[6], lt = T[7], ht = T[8], ct = T[9], dt = T[10], it = T[11], Xe = T[12], je = T[13], j = T[14], Q = T[15];
    d = A[0], H += d * We, Z += d * Fe, me += d * Qe, we += d * Ze, ye += d * Je, De += d * qe, He += d * at, Ue += d * lt, _e += d * ht, be += d * ct, de += d * dt, fe += d * it, ue += d * Xe, ae += d * je, oe += d * j, te += d * Q, d = A[1], Z += d * We, me += d * Fe, we += d * Qe, ye += d * Ze, De += d * Je, He += d * qe, Ue += d * at, _e += d * lt, be += d * ht, de += d * ct, fe += d * dt, ue += d * it, ae += d * Xe, oe += d * je, te += d * j, pe += d * Q, d = A[2], me += d * We, we += d * Fe, ye += d * Qe, De += d * Ze, He += d * Je, Ue += d * qe, _e += d * at, be += d * lt, de += d * ht, fe += d * ct, ue += d * dt, ae += d * it, oe += d * Xe, te += d * je, pe += d * j, ve += d * Q, d = A[3], we += d * We, ye += d * Fe, De += d * Qe, He += d * Ze, Ue += d * Je, _e += d * qe, be += d * at, de += d * lt, fe += d * ht, ue += d * ct, ae += d * dt, oe += d * it, te += d * Xe, pe += d * je, ve += d * j, ne += d * Q, d = A[4], ye += d * We, De += d * Fe, He += d * Qe, Ue += d * Ze, _e += d * Je, be += d * qe, de += d * at, fe += d * lt, ue += d * ht, ae += d * ct, oe += d * dt, te += d * it, pe += d * Xe, ve += d * je, ne += d * j, Ee += d * Q, d = A[5], De += d * We, He += d * Fe, Ue += d * Qe, _e += d * Ze, be += d * Je, de += d * qe, fe += d * at, ue += d * lt, ae += d * ht, oe += d * ct, te += d * dt, pe += d * it, ve += d * Xe, ne += d * je, Ee += d * j, Ie += d * Q, d = A[6], He += d * We, Ue += d * Fe, _e += d * Qe, be += d * Ze, de += d * Je, fe += d * qe, ue += d * at, ae += d * lt, oe += d * ht, te += d * ct, pe += d * dt, ve += d * it, ne += d * Xe, Ee += d * je, Ie += d * j, Pe += d * Q, d = A[7], Ue += d * We, _e += d * Fe, be += d * Qe, de += d * Ze, fe += d * Je, ue += d * qe, ae += d * at, oe += d * lt, te += d * ht, pe += d * ct, ve += d * dt, ne += d * it, Ee += d * Xe, Ie += d * je, Pe += d * j, Re += d * Q, d = A[8], _e += d * We, be += d * Fe, de += d * Qe, fe += d * Ze, ue += d * Je, ae += d * qe, oe += d * at, te += d * lt, pe += d * ht, ve += d * ct, ne += d * dt, Ee += d * it, Ie += d * Xe, Pe += d * je, Re += d * j, Te += d * Q, d = A[9], be += d * We, de += d * Fe, fe += d * Qe, ue += d * Ze, ae += d * Je, oe += d * qe, te += d * at, pe += d * lt, ve += d * ht, ne += d * ct, Ee += d * dt, Ie += d * it, Pe += d * Xe, Re += d * je, Te += d * j, At += d * Q, d = A[10], de += d * We, fe += d * Fe, ue += d * Qe, ae += d * Ze, oe += d * Je, te += d * qe, pe += d * at, ve += d * lt, ne += d * ht, Ee += d * ct, Ie += d * dt, Pe += d * it, Re += d * Xe, Te += d * je, At += d * j, Ft += d * Q, d = A[11], fe += d * We, ue += d * Fe, ae += d * Qe, oe += d * Ze, te += d * Je, pe += d * qe, ve += d * at, ne += d * lt, Ee += d * ht, Ie += d * ct, Pe += d * dt, Re += d * it, Te += d * Xe, At += d * je, Ft += d * j, Qt += d * Q, d = A[12], ue += d * We, ae += d * Fe, oe += d * Qe, te += d * Ze, pe += d * Je, ve += d * qe, ne += d * at, Ee += d * lt, Ie += d * ht, Pe += d * ct, Re += d * dt, Te += d * it, At += d * Xe, Ft += d * je, Qt += d * j, It += d * Q, d = A[13], ae += d * We, oe += d * Fe, te += d * Qe, pe += d * Ze, ve += d * Je, ne += d * qe, Ee += d * at, Ie += d * lt, Pe += d * ht, Re += d * ct, Te += d * dt, At += d * it, Ft += d * Xe, Qt += d * je, It += d * j, er += d * Q, d = A[14], oe += d * We, te += d * Fe, pe += d * Qe, ve += d * Ze, ne += d * Je, Ee += d * qe, Ie += d * at, Pe += d * lt, Re += d * ht, Te += d * ct, At += d * dt, Ft += d * it, Qt += d * Xe, It += d * je, er += d * j, tr += d * Q, d = A[15], te += d * We, pe += d * Fe, ve += d * Qe, ne += d * Ze, Ee += d * Je, Ie += d * qe, Pe += d * at, Re += d * lt, Te += d * ht, At += d * ct, Ft += d * dt, Qt += d * it, It += d * Xe, er += d * je, tr += d * j, an += d * Q, H += 38 * pe, Z += 38 * ve, me += 38 * ne, we += 38 * Ee, ye += 38 * Ie, De += 38 * Pe, He += 38 * Re, Ue += 38 * Te, _e += 38 * At, be += 38 * Ft, de += 38 * Qt, fe += 38 * It, ue += 38 * er, ae += 38 * tr, oe += 38 * an, O = 1, d = H + O + 65535, O = Math.floor(d / 65536), H = d - O * 65536, d = Z + O + 65535, O = Math.floor(d / 65536), Z = d - O * 65536, d = me + O + 65535, O = Math.floor(d / 65536), me = d - O * 65536, d = we + O + 65535, O = Math.floor(d / 65536), we = d - O * 65536, d = ye + O + 65535, O = Math.floor(d / 65536), ye = d - O * 65536, d = De + O + 65535, O = Math.floor(d / 65536), De = d - O * 65536, d = He + O + 65535, O = Math.floor(d / 65536), He = d - O * 65536, d = Ue + O + 65535, O = Math.floor(d / 65536), Ue = d - O * 65536, d = _e + O + 65535, O = Math.floor(d / 65536), _e = d - O * 65536, d = be + O + 65535, O = Math.floor(d / 65536), be = d - O * 65536, d = de + O + 65535, O = Math.floor(d / 65536), de = d - O * 65536, d = fe + O + 65535, O = Math.floor(d / 65536), fe = d - O * 65536, d = ue + O + 65535, O = Math.floor(d / 65536), ue = d - O * 65536, d = ae + O + 65535, O = Math.floor(d / 65536), ae = d - O * 65536, d = oe + O + 65535, O = Math.floor(d / 65536), oe = d - O * 65536, d = te + O + 65535, O = Math.floor(d / 65536), te = d - O * 65536, H += O - 1 + 37 * (O - 1), O = 1, d = H + O + 65535, O = Math.floor(d / 65536), H = d - O * 65536, d = Z + O + 65535, O = Math.floor(d / 65536), Z = d - O * 65536, d = me + O + 65535, O = Math.floor(d / 65536), me = d - O * 65536, d = we + O + 65535, O = Math.floor(d / 65536), we = d - O * 65536, d = ye + O + 65535, O = Math.floor(d / 65536), ye = d - O * 65536, d = De + O + 65535, O = Math.floor(d / 65536), De = d - O * 65536, d = He + O + 65535, O = Math.floor(d / 65536), He = d - O * 65536, d = Ue + O + 65535, O = Math.floor(d / 65536), Ue = d - O * 65536, d = _e + O + 65535, O = Math.floor(d / 65536), _e = d - O * 65536, d = be + O + 65535, O = Math.floor(d / 65536), be = d - O * 65536, d = de + O + 65535, O = Math.floor(d / 65536), de = d - O * 65536, d = fe + O + 65535, O = Math.floor(d / 65536), fe = d - O * 65536, d = ue + O + 65535, O = Math.floor(d / 65536), ue = d - O * 65536, d = ae + O + 65535, O = Math.floor(d / 65536), ae = d - O * 65536, d = oe + O + 65535, O = Math.floor(d / 65536), oe = d - O * 65536, d = te + O + 65535, O = Math.floor(d / 65536), te = d - O * 65536, H += O - 1 + 37 * (O - 1), L[0] = H, L[1] = Z, L[2] = me, L[3] = we, L[4] = ye, L[5] = De, L[6] = He, L[7] = Ue, L[8] = _e, L[9] = be, L[10] = de, L[11] = fe, L[12] = ue, L[13] = ae, L[14] = oe, L[15] = te;
  }
  function p(L, A) {
    c(L, A, A);
  }
  function D(L, A) {
    const T = i();
    let d;
    for (d = 0; d < 16; d++)
      T[d] = A[d];
    for (d = 253; d >= 0; d--)
      p(T, T), d !== 2 && d !== 4 && c(T, T, A);
    for (d = 0; d < 16; d++)
      L[d] = T[d];
  }
  function R(L, A) {
    const T = i();
    let d;
    for (d = 0; d < 16; d++)
      T[d] = A[d];
    for (d = 250; d >= 0; d--)
      p(T, T), d !== 1 && c(T, T, A);
    for (d = 0; d < 16; d++)
      L[d] = T[d];
  }
  function k(L, A) {
    const T = i(), d = i(), O = i(), H = i(), Z = i(), me = i(), we = i(), ye = i(), De = i();
    y(T, L[1], L[0]), y(De, A[1], A[0]), c(T, T, De), E(d, L[0], L[1]), E(De, A[0], A[1]), c(d, d, De), c(O, L[3], A[3]), c(O, O, u), c(H, L[2], A[2]), E(H, H, H), y(Z, d, T), y(me, H, O), E(we, H, O), E(ye, d, T), c(L[0], Z, me), c(L[1], ye, we), c(L[2], we, me), c(L[3], Z, ye);
  }
  function B(L, A, T) {
    for (let d = 0; d < 4; d++)
      S(L[d], A[d], T);
  }
  function W(L, A) {
    const T = i(), d = i(), O = i();
    D(O, A[2]), c(T, A[0], O), c(d, A[1], O), x(L, d), L[31] ^= I(T) << 7;
  }
  function C(L, A, T) {
    m(L[0], a), m(L[1], o), m(L[2], o), m(L[3], a);
    for (let d = 255; d >= 0; --d) {
      const O = T[d / 8 | 0] >> (d & 7) & 1;
      B(L, A, O), k(A, L), k(L, L), B(L, A, O);
    }
  }
  function N(L, A) {
    const T = [i(), i(), i(), i()];
    m(T[0], h), m(T[1], f), m(T[2], o), c(T[3], h, f), C(L, T, A);
  }
  function G(L) {
    if (L.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const A = (0, r.hash)(L);
    A[0] &= 248, A[31] &= 127, A[31] |= 64;
    const T = new Uint8Array(32), d = [i(), i(), i(), i()];
    N(d, A), W(T, d);
    const O = new Uint8Array(64);
    return O.set(L), O.set(T, 32), {
      publicKey: T,
      secretKey: O
    };
  }
  t.generateKeyPairFromSeed = G;
  function z(L) {
    const A = (0, e.randomBytes)(32, L), T = G(A);
    return (0, n.wipe)(A), T;
  }
  t.generateKeyPair = z;
  function $(L) {
    if (L.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(L.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = $;
  const q = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function U(L, A) {
    let T, d, O, H;
    for (d = 63; d >= 32; --d) {
      for (T = 0, O = d - 32, H = d - 12; O < H; ++O)
        A[O] += T - 16 * A[d] * q[O - (d - 32)], T = Math.floor((A[O] + 128) / 256), A[O] -= T * 256;
      A[O] += T, A[d] = 0;
    }
    for (T = 0, O = 0; O < 32; O++)
      A[O] += T - (A[31] >> 4) * q[O], T = A[O] >> 8, A[O] &= 255;
    for (O = 0; O < 32; O++)
      A[O] -= T * q[O];
    for (d = 0; d < 32; d++)
      A[d + 1] += A[d] >> 8, L[d] = A[d] & 255;
  }
  function V(L) {
    const A = new Float64Array(64);
    for (let T = 0; T < 64; T++)
      A[T] = L[T];
    for (let T = 0; T < 64; T++)
      L[T] = 0;
    U(L, A);
  }
  function re(L, A) {
    const T = new Float64Array(64), d = [i(), i(), i(), i()], O = (0, r.hash)(L.subarray(0, 32));
    O[0] &= 248, O[31] &= 127, O[31] |= 64;
    const H = new Uint8Array(64);
    H.set(O.subarray(32), 32);
    const Z = new r.SHA512();
    Z.update(H.subarray(32)), Z.update(A);
    const me = Z.digest();
    Z.clean(), V(me), N(d, me), W(H, d), Z.reset(), Z.update(H.subarray(0, 32)), Z.update(L.subarray(32)), Z.update(A);
    const we = Z.digest();
    V(we);
    for (let ye = 0; ye < 32; ye++)
      T[ye] = me[ye];
    for (let ye = 0; ye < 32; ye++)
      for (let De = 0; De < 32; De++)
        T[ye + De] += we[ye] * O[De];
    return U(H.subarray(32), T), H;
  }
  t.sign = re;
  function K(L, A) {
    const T = i(), d = i(), O = i(), H = i(), Z = i(), me = i(), we = i();
    return m(L[2], o), b(L[1], A), p(O, L[1]), c(H, O, l), y(O, O, L[2]), E(H, L[2], H), p(Z, H), p(me, Z), c(we, me, Z), c(T, we, O), c(T, T, H), R(T, T), c(T, T, O), c(T, T, H), c(T, T, H), c(L[0], T, H), p(d, L[0]), c(d, d, H), _(d, O) && c(L[0], L[0], g), p(d, L[0]), c(d, d, H), _(d, O) ? -1 : (I(L[0]) === A[31] >> 7 && y(L[0], a, L[0]), c(L[3], L[0], L[1]), 0);
  }
  function X(L, A, T) {
    const d = new Uint8Array(32), O = [i(), i(), i(), i()], H = [i(), i(), i(), i()];
    if (T.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (K(H, L))
      return !1;
    const Z = new r.SHA512();
    Z.update(T.subarray(0, 32)), Z.update(L), Z.update(A);
    const me = Z.digest();
    return V(me), C(O, H, me), N(H, T.subarray(32)), k(O, H), W(d, O), !M(T, d);
  }
  t.verify = X;
  function Y(L) {
    let A = [i(), i(), i(), i()];
    if (K(A, L))
      throw new Error("Ed25519: invalid public key");
    let T = i(), d = i(), O = A[1];
    E(T, o, O), y(d, o, O), D(d, d), c(T, T, d);
    let H = new Uint8Array(32);
    return x(H, T), H;
  }
  t.convertPublicKeyToX25519 = Y;
  function ee(L) {
    const A = (0, r.hash)(L.subarray(0, 32));
    A[0] &= 248, A[31] &= 127, A[31] |= 64;
    const T = new Uint8Array(A.subarray(0, 32));
    return (0, n.wipe)(A), T;
  }
  t.convertSecretKeyToX25519 = ee;
})(pp);
const tP = "EdDSA", rP = "JWT", cw = ".", uw = "base64url", nP = "utf8", iP = "utf8", sP = ":", oP = "did", aP = "key", Dm = "base58btc", cP = "z", uP = "K36", lP = 32;
function gp(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function lw(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? gp(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Wd(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const r = lw(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return gp(r);
}
function hP(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), a = s.charCodeAt(0);
    if (r[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[a] = i;
  }
  var o = t.length, l = t.charAt(0), u = Math.log(o) / Math.log(256), h = Math.log(256) / Math.log(o);
  function f(w) {
    if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer, w.byteOffset, w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))), !(w instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (w.length === 0)
      return "";
    for (var S = 0, x = 0, M = 0, _ = w.length; M !== _ && w[M] === 0; )
      M++, S++;
    for (var I = (_ - M) * h + 1 >>> 0, b = new Uint8Array(I); M !== _; ) {
      for (var E = w[M], y = 0, c = I - 1; (E !== 0 || y < x) && c !== -1; c--, y++)
        E += 256 * b[c] >>> 0, b[c] = E % o >>> 0, E = E / o >>> 0;
      if (E !== 0)
        throw new Error("Non-zero carry");
      x = y, M++;
    }
    for (var p = I - x; p !== I && b[p] === 0; )
      p++;
    for (var D = l.repeat(S); p < I; ++p)
      D += t.charAt(b[p]);
    return D;
  }
  function g(w) {
    if (typeof w != "string")
      throw new TypeError("Expected String");
    if (w.length === 0)
      return new Uint8Array();
    var S = 0;
    if (w[S] !== " ") {
      for (var x = 0, M = 0; w[S] === l; )
        x++, S++;
      for (var _ = (w.length - S) * u + 1 >>> 0, I = new Uint8Array(_); w[S]; ) {
        var b = r[w.charCodeAt(S)];
        if (b === 255)
          return;
        for (var E = 0, y = _ - 1; (b !== 0 || E < M) && y !== -1; y--, E++)
          b += o * I[y] >>> 0, I[y] = b % 256 >>> 0, b = b / 256 >>> 0;
        if (b !== 0)
          throw new Error("Non-zero carry");
        M = E, S++;
      }
      if (w[S] !== " ") {
        for (var c = _ - M; c !== _ && I[c] === 0; )
          c++;
        for (var p = new Uint8Array(x + (_ - c)), D = x; c !== _; )
          p[D++] = I[c++];
        return p;
      }
    }
  }
  function m(w) {
    var S = g(w);
    if (S)
      return S;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: f,
    decodeUnsafe: g,
    decode: m
  };
}
var dP = hP, fP = dP;
const pP = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, gP = (t) => new TextEncoder().encode(t), yP = (t) => new TextDecoder().decode(t);
class mP {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class vP {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return hw(this, e);
  }
}
class bP {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return hw(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const hw = (t, e) => new bP({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class wP {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new mP(e, r, n), this.decoder = new vP(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Il = ({ name: t, prefix: e, encode: r, decode: n }) => new wP(t, e, r, n), Dc = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = fP(r, e);
  return Il({
    prefix: t,
    name: e,
    encode: n,
    decode: (s) => pP(i(s))
  });
}, _P = (t, e, r, n) => {
  const i = {};
  for (let h = 0; h < e.length; ++h)
    i[e[h]] = h;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * r / 8 | 0);
  let o = 0, l = 0, u = 0;
  for (let h = 0; h < s; ++h) {
    const f = i[t[h]];
    if (f === void 0)
      throw new SyntaxError(`Non-${n} character`);
    l = l << r | f, o += r, o >= 8 && (o -= 8, a[u++] = 255 & l >> o);
  }
  if (o >= r || 255 & l << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, EP = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", a = 0, o = 0;
  for (let l = 0; l < t.length; ++l)
    for (o = o << 8 | t[l], a += 8; a > r; )
      a -= r, s += e[i & o >> a];
  if (a && (s += e[i & o << r - a]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, mr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => Il({
  prefix: e,
  name: t,
  encode(i) {
    return EP(i, n, r);
  },
  decode(i) {
    return _P(i, n, r, t);
  }
}), SP = Il({
  prefix: "\0",
  name: "identity",
  encode: (t) => yP(t),
  decode: (t) => gP(t)
}), OP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: SP
}, Symbol.toStringTag, { value: "Module" })), IP = mr({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), xP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: IP
}, Symbol.toStringTag, { value: "Module" })), CP = mr({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), DP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: CP
}, Symbol.toStringTag, { value: "Module" })), TP = Dc({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), PP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: TP
}, Symbol.toStringTag, { value: "Module" })), RP = mr({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), NP = mr({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), AP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: RP,
  base16upper: NP
}, Symbol.toStringTag, { value: "Module" })), LP = mr({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), MP = mr({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), jP = mr({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), kP = mr({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), UP = mr({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), $P = mr({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), FP = mr({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), qP = mr({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), zP = mr({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), VP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: LP,
  base32hex: UP,
  base32hexpad: FP,
  base32hexpadupper: qP,
  base32hexupper: $P,
  base32pad: jP,
  base32padupper: kP,
  base32upper: MP,
  base32z: zP
}, Symbol.toStringTag, { value: "Module" })), KP = Dc({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), BP = Dc({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), HP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: KP,
  base36upper: BP
}, Symbol.toStringTag, { value: "Module" })), WP = Dc({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), GP = Dc({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), ZP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: WP,
  base58flickr: GP
}, Symbol.toStringTag, { value: "Module" })), YP = mr({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), QP = mr({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), JP = mr({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), XP = mr({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), eR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: YP,
  base64pad: QP,
  base64url: JP,
  base64urlpad: XP
}, Symbol.toStringTag, { value: "Module" })), dw = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), tR = dw.reduce((t, e, r) => (t[r] = e, t), []), rR = dw.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function nR(t) {
  return t.reduce((e, r) => (e += tR[r], e), "");
}
function iR(t) {
  const e = [];
  for (const r of t) {
    const n = rR[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const sR = Il({
  prefix: "🚀",
  name: "base256emoji",
  encode: nR,
  decode: iR
}), oR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: sR
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Tm = {
  ...OP,
  ...xP,
  ...DP,
  ...PP,
  ...AP,
  ...VP,
  ...HP,
  ...ZP,
  ...eR,
  ...oR
};
function fw(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const Pm = fw("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Kh = fw("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = lw(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), pw = {
  utf8: Pm,
  "utf-8": Pm,
  hex: Tm.base16,
  latin1: Kh,
  ascii: Kh,
  binary: Kh,
  ...Tm
};
function Zr(t, e = "utf8") {
  const r = pw[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function sn(t, e = "utf8") {
  const r = pw[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? gp(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
function Du(t) {
  return Zr(sn(Cc(t), nP), uw);
}
function gw(t) {
  const e = sn(uP, Dm), r = cP + Zr(Wd([e, t]), Dm);
  return [oP, aP, r].join(sP);
}
function aR(t) {
  return Zr(t, uw);
}
function cR(t) {
  return sn([Du(t.header), Du(t.payload)].join(cw), iP);
}
function uR(t) {
  return [
    Du(t.header),
    Du(t.payload),
    aR(t.signature)
  ].join(cw);
}
function Rm(t = jo.randomBytes(lP)) {
  return pp.generateKeyPairFromSeed(t);
}
async function lR(t, e, r, n, i = Ae.fromMiliseconds(Date.now())) {
  const s = { alg: tP, typ: rP }, a = gw(n.publicKey), o = i + r, l = { iss: a, sub: t, aud: e, iat: i, exp: o }, u = cR({ header: s, payload: l }), h = pp.sign(n.secretKey, u);
  return uR({ header: s, payload: l, signature: h });
}
var yp = {}, xl = {};
Object.defineProperty(xl, "__esModule", { value: !0 });
var Er = nt, Gd = yn, hR = 20;
function dR(t, e, r) {
  for (var n = 1634760805, i = 857760878, s = 2036477234, a = 1797285236, o = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], l = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], u = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], h = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], f = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], g = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], m = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], w = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], S = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], x = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], M = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], _ = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], I = n, b = i, E = s, y = a, c = o, p = l, D = u, R = h, k = f, B = g, W = m, C = w, N = S, G = x, z = M, $ = _, q = 0; q < hR; q += 2)
    I = I + c | 0, N ^= I, N = N >>> 16 | N << 16, k = k + N | 0, c ^= k, c = c >>> 20 | c << 12, b = b + p | 0, G ^= b, G = G >>> 16 | G << 16, B = B + G | 0, p ^= B, p = p >>> 20 | p << 12, E = E + D | 0, z ^= E, z = z >>> 16 | z << 16, W = W + z | 0, D ^= W, D = D >>> 20 | D << 12, y = y + R | 0, $ ^= y, $ = $ >>> 16 | $ << 16, C = C + $ | 0, R ^= C, R = R >>> 20 | R << 12, E = E + D | 0, z ^= E, z = z >>> 24 | z << 8, W = W + z | 0, D ^= W, D = D >>> 25 | D << 7, y = y + R | 0, $ ^= y, $ = $ >>> 24 | $ << 8, C = C + $ | 0, R ^= C, R = R >>> 25 | R << 7, b = b + p | 0, G ^= b, G = G >>> 24 | G << 8, B = B + G | 0, p ^= B, p = p >>> 25 | p << 7, I = I + c | 0, N ^= I, N = N >>> 24 | N << 8, k = k + N | 0, c ^= k, c = c >>> 25 | c << 7, I = I + p | 0, $ ^= I, $ = $ >>> 16 | $ << 16, W = W + $ | 0, p ^= W, p = p >>> 20 | p << 12, b = b + D | 0, N ^= b, N = N >>> 16 | N << 16, C = C + N | 0, D ^= C, D = D >>> 20 | D << 12, E = E + R | 0, G ^= E, G = G >>> 16 | G << 16, k = k + G | 0, R ^= k, R = R >>> 20 | R << 12, y = y + c | 0, z ^= y, z = z >>> 16 | z << 16, B = B + z | 0, c ^= B, c = c >>> 20 | c << 12, E = E + R | 0, G ^= E, G = G >>> 24 | G << 8, k = k + G | 0, R ^= k, R = R >>> 25 | R << 7, y = y + c | 0, z ^= y, z = z >>> 24 | z << 8, B = B + z | 0, c ^= B, c = c >>> 25 | c << 7, b = b + D | 0, N ^= b, N = N >>> 24 | N << 8, C = C + N | 0, D ^= C, D = D >>> 25 | D << 7, I = I + p | 0, $ ^= I, $ = $ >>> 24 | $ << 8, W = W + $ | 0, p ^= W, p = p >>> 25 | p << 7;
  Er.writeUint32LE(I + n | 0, t, 0), Er.writeUint32LE(b + i | 0, t, 4), Er.writeUint32LE(E + s | 0, t, 8), Er.writeUint32LE(y + a | 0, t, 12), Er.writeUint32LE(c + o | 0, t, 16), Er.writeUint32LE(p + l | 0, t, 20), Er.writeUint32LE(D + u | 0, t, 24), Er.writeUint32LE(R + h | 0, t, 28), Er.writeUint32LE(k + f | 0, t, 32), Er.writeUint32LE(B + g | 0, t, 36), Er.writeUint32LE(W + m | 0, t, 40), Er.writeUint32LE(C + w | 0, t, 44), Er.writeUint32LE(N + S | 0, t, 48), Er.writeUint32LE(G + x | 0, t, 52), Er.writeUint32LE(z + M | 0, t, 56), Er.writeUint32LE($ + _ | 0, t, 60);
}
function yw(t, e, r, n, i) {
  if (i === void 0 && (i = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, a;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), a = s.length - e.length, s.set(e, a);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, a = i;
  }
  for (var o = new Uint8Array(64), l = 0; l < r.length; l += 64) {
    dR(o, s, t);
    for (var u = l; u < l + 64 && u < r.length; u++)
      n[u] = r[u] ^ o[u - l];
    pR(s, 0, a);
  }
  return Gd.wipe(o), i === 0 && Gd.wipe(s), n;
}
xl.streamXOR = yw;
function fR(t, e, r, n) {
  return n === void 0 && (n = 0), Gd.wipe(r), yw(t, e, r, r, n);
}
xl.stream = fR;
function pR(t, e, r) {
  for (var n = 1; r--; )
    n = n + (t[e] & 255) | 0, t[e] = n & 255, n >>>= 8, e++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var mw = {}, Xi = {};
Object.defineProperty(Xi, "__esModule", { value: !0 });
function gR(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Xi.select = gR;
function yR(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Xi.lessOrEqual = yR;
function vw(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, n = 0; n < t.length; n++)
    r |= t[n] ^ e[n];
  return 1 & r - 1 >>> 8;
}
Xi.compare = vw;
function mR(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : vw(t, e) !== 0;
}
Xi.equal = mR;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Xi, r = yn;
  t.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function a(o) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var l = o[0] | o[1] << 8;
        this._r[0] = l & 8191;
        var u = o[2] | o[3] << 8;
        this._r[1] = (l >>> 13 | u << 3) & 8191;
        var h = o[4] | o[5] << 8;
        this._r[2] = (u >>> 10 | h << 6) & 7939;
        var f = o[6] | o[7] << 8;
        this._r[3] = (h >>> 7 | f << 9) & 8191;
        var g = o[8] | o[9] << 8;
        this._r[4] = (f >>> 4 | g << 12) & 255, this._r[5] = g >>> 1 & 8190;
        var m = o[10] | o[11] << 8;
        this._r[6] = (g >>> 14 | m << 2) & 8191;
        var w = o[12] | o[13] << 8;
        this._r[7] = (m >>> 11 | w << 5) & 8065;
        var S = o[14] | o[15] << 8;
        this._r[8] = (w >>> 8 | S << 8) & 8191, this._r[9] = S >>> 5 & 127, this._pad[0] = o[16] | o[17] << 8, this._pad[1] = o[18] | o[19] << 8, this._pad[2] = o[20] | o[21] << 8, this._pad[3] = o[22] | o[23] << 8, this._pad[4] = o[24] | o[25] << 8, this._pad[5] = o[26] | o[27] << 8, this._pad[6] = o[28] | o[29] << 8, this._pad[7] = o[30] | o[31] << 8;
      }
      return a.prototype._blocks = function(o, l, u) {
        for (var h = this._fin ? 0 : 2048, f = this._h[0], g = this._h[1], m = this._h[2], w = this._h[3], S = this._h[4], x = this._h[5], M = this._h[6], _ = this._h[7], I = this._h[8], b = this._h[9], E = this._r[0], y = this._r[1], c = this._r[2], p = this._r[3], D = this._r[4], R = this._r[5], k = this._r[6], B = this._r[7], W = this._r[8], C = this._r[9]; u >= 16; ) {
          var N = o[l + 0] | o[l + 1] << 8;
          f += N & 8191;
          var G = o[l + 2] | o[l + 3] << 8;
          g += (N >>> 13 | G << 3) & 8191;
          var z = o[l + 4] | o[l + 5] << 8;
          m += (G >>> 10 | z << 6) & 8191;
          var $ = o[l + 6] | o[l + 7] << 8;
          w += (z >>> 7 | $ << 9) & 8191;
          var q = o[l + 8] | o[l + 9] << 8;
          S += ($ >>> 4 | q << 12) & 8191, x += q >>> 1 & 8191;
          var U = o[l + 10] | o[l + 11] << 8;
          M += (q >>> 14 | U << 2) & 8191;
          var V = o[l + 12] | o[l + 13] << 8;
          _ += (U >>> 11 | V << 5) & 8191;
          var re = o[l + 14] | o[l + 15] << 8;
          I += (V >>> 8 | re << 8) & 8191, b += re >>> 5 | h;
          var K = 0, X = K;
          X += f * E, X += g * (5 * C), X += m * (5 * W), X += w * (5 * B), X += S * (5 * k), K = X >>> 13, X &= 8191, X += x * (5 * R), X += M * (5 * D), X += _ * (5 * p), X += I * (5 * c), X += b * (5 * y), K += X >>> 13, X &= 8191;
          var Y = K;
          Y += f * y, Y += g * E, Y += m * (5 * C), Y += w * (5 * W), Y += S * (5 * B), K = Y >>> 13, Y &= 8191, Y += x * (5 * k), Y += M * (5 * R), Y += _ * (5 * D), Y += I * (5 * p), Y += b * (5 * c), K += Y >>> 13, Y &= 8191;
          var ee = K;
          ee += f * c, ee += g * y, ee += m * E, ee += w * (5 * C), ee += S * (5 * W), K = ee >>> 13, ee &= 8191, ee += x * (5 * B), ee += M * (5 * k), ee += _ * (5 * R), ee += I * (5 * D), ee += b * (5 * p), K += ee >>> 13, ee &= 8191;
          var L = K;
          L += f * p, L += g * c, L += m * y, L += w * E, L += S * (5 * C), K = L >>> 13, L &= 8191, L += x * (5 * W), L += M * (5 * B), L += _ * (5 * k), L += I * (5 * R), L += b * (5 * D), K += L >>> 13, L &= 8191;
          var A = K;
          A += f * D, A += g * p, A += m * c, A += w * y, A += S * E, K = A >>> 13, A &= 8191, A += x * (5 * C), A += M * (5 * W), A += _ * (5 * B), A += I * (5 * k), A += b * (5 * R), K += A >>> 13, A &= 8191;
          var T = K;
          T += f * R, T += g * D, T += m * p, T += w * c, T += S * y, K = T >>> 13, T &= 8191, T += x * E, T += M * (5 * C), T += _ * (5 * W), T += I * (5 * B), T += b * (5 * k), K += T >>> 13, T &= 8191;
          var d = K;
          d += f * k, d += g * R, d += m * D, d += w * p, d += S * c, K = d >>> 13, d &= 8191, d += x * y, d += M * E, d += _ * (5 * C), d += I * (5 * W), d += b * (5 * B), K += d >>> 13, d &= 8191;
          var O = K;
          O += f * B, O += g * k, O += m * R, O += w * D, O += S * p, K = O >>> 13, O &= 8191, O += x * c, O += M * y, O += _ * E, O += I * (5 * C), O += b * (5 * W), K += O >>> 13, O &= 8191;
          var H = K;
          H += f * W, H += g * B, H += m * k, H += w * R, H += S * D, K = H >>> 13, H &= 8191, H += x * p, H += M * c, H += _ * y, H += I * E, H += b * (5 * C), K += H >>> 13, H &= 8191;
          var Z = K;
          Z += f * C, Z += g * W, Z += m * B, Z += w * k, Z += S * R, K = Z >>> 13, Z &= 8191, Z += x * D, Z += M * p, Z += _ * c, Z += I * y, Z += b * E, K += Z >>> 13, Z &= 8191, K = (K << 2) + K | 0, K = K + X | 0, X = K & 8191, K = K >>> 13, Y += K, f = X, g = Y, m = ee, w = L, S = A, x = T, M = d, _ = O, I = H, b = Z, l += 16, u -= 16;
        }
        this._h[0] = f, this._h[1] = g, this._h[2] = m, this._h[3] = w, this._h[4] = S, this._h[5] = x, this._h[6] = M, this._h[7] = _, this._h[8] = I, this._h[9] = b;
      }, a.prototype.finish = function(o, l) {
        l === void 0 && (l = 0);
        var u = new Uint16Array(10), h, f, g, m;
        if (this._leftover) {
          for (m = this._leftover, this._buffer[m++] = 1; m < 16; m++)
            this._buffer[m] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (h = this._h[1] >>> 13, this._h[1] &= 8191, m = 2; m < 10; m++)
          this._h[m] += h, h = this._h[m] >>> 13, this._h[m] &= 8191;
        for (this._h[0] += h * 5, h = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += h, h = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += h, u[0] = this._h[0] + 5, h = u[0] >>> 13, u[0] &= 8191, m = 1; m < 10; m++)
          u[m] = this._h[m] + h, h = u[m] >>> 13, u[m] &= 8191;
        for (u[9] -= 8192, f = (h ^ 1) - 1, m = 0; m < 10; m++)
          u[m] &= f;
        for (f = ~f, m = 0; m < 10; m++)
          this._h[m] = this._h[m] & f | u[m];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, g = this._h[0] + this._pad[0], this._h[0] = g & 65535, m = 1; m < 8; m++)
          g = (this._h[m] + this._pad[m] | 0) + (g >>> 16) | 0, this._h[m] = g & 65535;
        return o[l + 0] = this._h[0] >>> 0, o[l + 1] = this._h[0] >>> 8, o[l + 2] = this._h[1] >>> 0, o[l + 3] = this._h[1] >>> 8, o[l + 4] = this._h[2] >>> 0, o[l + 5] = this._h[2] >>> 8, o[l + 6] = this._h[3] >>> 0, o[l + 7] = this._h[3] >>> 8, o[l + 8] = this._h[4] >>> 0, o[l + 9] = this._h[4] >>> 8, o[l + 10] = this._h[5] >>> 0, o[l + 11] = this._h[5] >>> 8, o[l + 12] = this._h[6] >>> 0, o[l + 13] = this._h[6] >>> 8, o[l + 14] = this._h[7] >>> 0, o[l + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, a.prototype.update = function(o) {
        var l = 0, u = o.length, h;
        if (this._leftover) {
          h = 16 - this._leftover, h > u && (h = u);
          for (var f = 0; f < h; f++)
            this._buffer[this._leftover + f] = o[l + f];
          if (u -= h, l += h, this._leftover += h, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (u >= 16 && (h = u - u % 16, this._blocks(o, l, h), l += h, u -= h), u) {
          for (var f = 0; f < u; f++)
            this._buffer[this._leftover + f] = o[l + f];
          this._leftover += u;
        }
        return this;
      }, a.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var o = new Uint8Array(16);
        return this.finish(o), o;
      }, a.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, a;
    }()
  );
  t.Poly1305 = n;
  function i(a, o) {
    var l = new n(a);
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.oneTimeAuth = i;
  function s(a, o) {
    return a.length !== t.DIGEST_LENGTH || o.length !== t.DIGEST_LENGTH ? !1 : e.equal(a, o);
  }
  t.equal = s;
})(mw);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = xl, r = mw, n = yn, i = nt, s = Xi;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var a = new Uint8Array(16), o = (
    /** @class */
    function() {
      function l(u) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, u.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(u);
      }
      return l.prototype.seal = function(u, h, f, g) {
        if (u.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var m = new Uint8Array(16);
        m.set(u, m.length - u.length);
        var w = new Uint8Array(32);
        e.stream(this._key, m, w, 4);
        var S = h.length + this.tagLength, x;
        if (g) {
          if (g.length !== S)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          x = g;
        } else
          x = new Uint8Array(S);
        return e.streamXOR(this._key, m, h, x, 4), this._authenticate(x.subarray(x.length - this.tagLength, x.length), w, x.subarray(0, x.length - this.tagLength), f), n.wipe(m), x;
      }, l.prototype.open = function(u, h, f, g) {
        if (u.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (h.length < this.tagLength)
          return null;
        var m = new Uint8Array(16);
        m.set(u, m.length - u.length);
        var w = new Uint8Array(32);
        e.stream(this._key, m, w, 4);
        var S = new Uint8Array(this.tagLength);
        if (this._authenticate(S, w, h.subarray(0, h.length - this.tagLength), f), !s.equal(S, h.subarray(h.length - this.tagLength, h.length)))
          return null;
        var x = h.length - this.tagLength, M;
        if (g) {
          if (g.length !== x)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          M = g;
        } else
          M = new Uint8Array(x);
        return e.streamXOR(this._key, m, h.subarray(0, h.length - this.tagLength), M, 4), n.wipe(m), M;
      }, l.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, l.prototype._authenticate = function(u, h, f, g) {
        var m = new r.Poly1305(h);
        g && (m.update(g), g.length % 16 > 0 && m.update(a.subarray(g.length % 16))), m.update(f), f.length % 16 > 0 && m.update(a.subarray(f.length % 16));
        var w = new Uint8Array(8);
        g && i.writeUint64LE(g.length, w), m.update(w), i.writeUint64LE(f.length, w), m.update(w);
        for (var S = m.digest(), x = 0; x < S.length; x++)
          u[x] = S[x];
        m.clean(), n.wipe(S), n.wipe(w);
      }, l;
    }()
  );
  t.ChaCha20Poly1305 = o;
})(yp);
var bw = {}, Tc = {}, mp = {};
Object.defineProperty(mp, "__esModule", { value: !0 });
function vR(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
mp.isSerializableHash = vR;
Object.defineProperty(Tc, "__esModule", { value: !0 });
var Gn = mp, bR = Xi, wR = yn, ww = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 54;
      this._inner.update(n);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 106;
      this._outer.update(n), Gn.isSerializableHash(this._inner) && Gn.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wR.wipe(n);
    }
    return t.prototype.reset = function() {
      if (!Gn.isSerializableHash(this._inner) || !Gn.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Gn.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Gn.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Gn.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Gn.isSerializableHash(this._inner) || !Gn.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Gn.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
Tc.HMAC = ww;
function _R(t, e, r) {
  var n = new ww(t, e);
  n.update(r);
  var i = n.digest();
  return n.clean(), i;
}
Tc.hmac = _R;
Tc.equal = bR.equal;
Object.defineProperty(bw, "__esModule", { value: !0 });
var Nm = Tc, Am = yn, ER = (
  /** @class */
  function() {
    function t(e, r, n, i) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
      var s = Nm.hmac(this._hash, n, r);
      this._hmac = new Nm.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), Am.wipe(this._buffer), Am.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), SR = bw.HKDF = ER, Cl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = nt, r = yn;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function o() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return o.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, o.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, o.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, o.prototype.update = function(l, u) {
        if (u === void 0 && (u = l.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var h = 0;
        if (this._bytesHashed += u, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && u > 0; )
            this._buffer[this._bufferLength++] = l[h++], u--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (u >= this.blockSize && (h = s(this._temp, this._state, l, h, u), u %= this.blockSize); u > 0; )
          this._buffer[this._bufferLength++] = l[h++], u--;
        return this;
      }, o.prototype.finish = function(l) {
        if (!this._finished) {
          var u = this._bytesHashed, h = this._bufferLength, f = u / 536870912 | 0, g = u << 3, m = u % 64 < 56 ? 64 : 128;
          this._buffer[h] = 128;
          for (var w = h + 1; w < m - 8; w++)
            this._buffer[w] = 0;
          e.writeUint32BE(f, this._buffer, m - 8), e.writeUint32BE(g, this._buffer, m - 4), s(this._temp, this._state, this._buffer, 0, m), this._finished = !0;
        }
        for (var w = 0; w < this.digestLength / 4; w++)
          e.writeUint32BE(this._state[w], l, w * 4);
        return this;
      }, o.prototype.digest = function() {
        var l = new Uint8Array(this.digestLength);
        return this.finish(l), l;
      }, o.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, o.prototype.restoreState = function(l) {
        return this._state.set(l.state), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this;
      }, o.prototype.cleanSavedState = function(l) {
        r.wipe(l.state), l.buffer && r.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0;
      }, o;
    }()
  );
  t.SHA256 = n;
  var i = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(o, l, u, h, f) {
    for (; f >= 64; ) {
      for (var g = l[0], m = l[1], w = l[2], S = l[3], x = l[4], M = l[5], _ = l[6], I = l[7], b = 0; b < 16; b++) {
        var E = h + b * 4;
        o[b] = e.readUint32BE(u, E);
      }
      for (var b = 16; b < 64; b++) {
        var y = o[b - 2], c = (y >>> 17 | y << 15) ^ (y >>> 19 | y << 13) ^ y >>> 10;
        y = o[b - 15];
        var p = (y >>> 7 | y << 25) ^ (y >>> 18 | y << 14) ^ y >>> 3;
        o[b] = (c + o[b - 7] | 0) + (p + o[b - 16] | 0);
      }
      for (var b = 0; b < 64; b++) {
        var c = (((x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)) + (x & M ^ ~x & _) | 0) + (I + (i[b] + o[b] | 0) | 0) | 0, p = ((g >>> 2 | g << 30) ^ (g >>> 13 | g << 19) ^ (g >>> 22 | g << 10)) + (g & m ^ g & w ^ m & w) | 0;
        I = _, _ = M, M = x, x = S + c | 0, S = w, w = m, m = g, g = c + p | 0;
      }
      l[0] += g, l[1] += m, l[2] += w, l[3] += S, l[4] += x, l[5] += M, l[6] += _, l[7] += I, h += 64, f -= 64;
    }
    return h;
  }
  function a(o) {
    var l = new n();
    l.update(o);
    var u = l.digest();
    return l.clean(), u;
  }
  t.hash = a;
})(Cl);
var vp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = jo, r = yn;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function n(b) {
    const E = new Float64Array(16);
    if (b)
      for (let y = 0; y < b.length; y++)
        E[y] = b[y];
    return E;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = n([56129, 1]);
  function a(b) {
    let E = 1;
    for (let y = 0; y < 16; y++) {
      let c = b[y] + E + 65535;
      E = Math.floor(c / 65536), b[y] = c - E * 65536;
    }
    b[0] += E - 1 + 37 * (E - 1);
  }
  function o(b, E, y) {
    const c = ~(y - 1);
    for (let p = 0; p < 16; p++) {
      const D = c & (b[p] ^ E[p]);
      b[p] ^= D, E[p] ^= D;
    }
  }
  function l(b, E) {
    const y = n(), c = n();
    for (let p = 0; p < 16; p++)
      c[p] = E[p];
    a(c), a(c), a(c);
    for (let p = 0; p < 2; p++) {
      y[0] = c[0] - 65517;
      for (let R = 1; R < 15; R++)
        y[R] = c[R] - 65535 - (y[R - 1] >> 16 & 1), y[R - 1] &= 65535;
      y[15] = c[15] - 32767 - (y[14] >> 16 & 1);
      const D = y[15] >> 16 & 1;
      y[14] &= 65535, o(c, y, 1 - D);
    }
    for (let p = 0; p < 16; p++)
      b[2 * p] = c[p] & 255, b[2 * p + 1] = c[p] >> 8;
  }
  function u(b, E) {
    for (let y = 0; y < 16; y++)
      b[y] = E[2 * y] + (E[2 * y + 1] << 8);
    b[15] &= 32767;
  }
  function h(b, E, y) {
    for (let c = 0; c < 16; c++)
      b[c] = E[c] + y[c];
  }
  function f(b, E, y) {
    for (let c = 0; c < 16; c++)
      b[c] = E[c] - y[c];
  }
  function g(b, E, y) {
    let c, p, D = 0, R = 0, k = 0, B = 0, W = 0, C = 0, N = 0, G = 0, z = 0, $ = 0, q = 0, U = 0, V = 0, re = 0, K = 0, X = 0, Y = 0, ee = 0, L = 0, A = 0, T = 0, d = 0, O = 0, H = 0, Z = 0, me = 0, we = 0, ye = 0, De = 0, He = 0, Ue = 0, _e = y[0], be = y[1], de = y[2], fe = y[3], ue = y[4], ae = y[5], oe = y[6], te = y[7], pe = y[8], ve = y[9], ne = y[10], Ee = y[11], Ie = y[12], Pe = y[13], Re = y[14], Te = y[15];
    c = E[0], D += c * _e, R += c * be, k += c * de, B += c * fe, W += c * ue, C += c * ae, N += c * oe, G += c * te, z += c * pe, $ += c * ve, q += c * ne, U += c * Ee, V += c * Ie, re += c * Pe, K += c * Re, X += c * Te, c = E[1], R += c * _e, k += c * be, B += c * de, W += c * fe, C += c * ue, N += c * ae, G += c * oe, z += c * te, $ += c * pe, q += c * ve, U += c * ne, V += c * Ee, re += c * Ie, K += c * Pe, X += c * Re, Y += c * Te, c = E[2], k += c * _e, B += c * be, W += c * de, C += c * fe, N += c * ue, G += c * ae, z += c * oe, $ += c * te, q += c * pe, U += c * ve, V += c * ne, re += c * Ee, K += c * Ie, X += c * Pe, Y += c * Re, ee += c * Te, c = E[3], B += c * _e, W += c * be, C += c * de, N += c * fe, G += c * ue, z += c * ae, $ += c * oe, q += c * te, U += c * pe, V += c * ve, re += c * ne, K += c * Ee, X += c * Ie, Y += c * Pe, ee += c * Re, L += c * Te, c = E[4], W += c * _e, C += c * be, N += c * de, G += c * fe, z += c * ue, $ += c * ae, q += c * oe, U += c * te, V += c * pe, re += c * ve, K += c * ne, X += c * Ee, Y += c * Ie, ee += c * Pe, L += c * Re, A += c * Te, c = E[5], C += c * _e, N += c * be, G += c * de, z += c * fe, $ += c * ue, q += c * ae, U += c * oe, V += c * te, re += c * pe, K += c * ve, X += c * ne, Y += c * Ee, ee += c * Ie, L += c * Pe, A += c * Re, T += c * Te, c = E[6], N += c * _e, G += c * be, z += c * de, $ += c * fe, q += c * ue, U += c * ae, V += c * oe, re += c * te, K += c * pe, X += c * ve, Y += c * ne, ee += c * Ee, L += c * Ie, A += c * Pe, T += c * Re, d += c * Te, c = E[7], G += c * _e, z += c * be, $ += c * de, q += c * fe, U += c * ue, V += c * ae, re += c * oe, K += c * te, X += c * pe, Y += c * ve, ee += c * ne, L += c * Ee, A += c * Ie, T += c * Pe, d += c * Re, O += c * Te, c = E[8], z += c * _e, $ += c * be, q += c * de, U += c * fe, V += c * ue, re += c * ae, K += c * oe, X += c * te, Y += c * pe, ee += c * ve, L += c * ne, A += c * Ee, T += c * Ie, d += c * Pe, O += c * Re, H += c * Te, c = E[9], $ += c * _e, q += c * be, U += c * de, V += c * fe, re += c * ue, K += c * ae, X += c * oe, Y += c * te, ee += c * pe, L += c * ve, A += c * ne, T += c * Ee, d += c * Ie, O += c * Pe, H += c * Re, Z += c * Te, c = E[10], q += c * _e, U += c * be, V += c * de, re += c * fe, K += c * ue, X += c * ae, Y += c * oe, ee += c * te, L += c * pe, A += c * ve, T += c * ne, d += c * Ee, O += c * Ie, H += c * Pe, Z += c * Re, me += c * Te, c = E[11], U += c * _e, V += c * be, re += c * de, K += c * fe, X += c * ue, Y += c * ae, ee += c * oe, L += c * te, A += c * pe, T += c * ve, d += c * ne, O += c * Ee, H += c * Ie, Z += c * Pe, me += c * Re, we += c * Te, c = E[12], V += c * _e, re += c * be, K += c * de, X += c * fe, Y += c * ue, ee += c * ae, L += c * oe, A += c * te, T += c * pe, d += c * ve, O += c * ne, H += c * Ee, Z += c * Ie, me += c * Pe, we += c * Re, ye += c * Te, c = E[13], re += c * _e, K += c * be, X += c * de, Y += c * fe, ee += c * ue, L += c * ae, A += c * oe, T += c * te, d += c * pe, O += c * ve, H += c * ne, Z += c * Ee, me += c * Ie, we += c * Pe, ye += c * Re, De += c * Te, c = E[14], K += c * _e, X += c * be, Y += c * de, ee += c * fe, L += c * ue, A += c * ae, T += c * oe, d += c * te, O += c * pe, H += c * ve, Z += c * ne, me += c * Ee, we += c * Ie, ye += c * Pe, De += c * Re, He += c * Te, c = E[15], X += c * _e, Y += c * be, ee += c * de, L += c * fe, A += c * ue, T += c * ae, d += c * oe, O += c * te, H += c * pe, Z += c * ve, me += c * ne, we += c * Ee, ye += c * Ie, De += c * Pe, He += c * Re, Ue += c * Te, D += 38 * Y, R += 38 * ee, k += 38 * L, B += 38 * A, W += 38 * T, C += 38 * d, N += 38 * O, G += 38 * H, z += 38 * Z, $ += 38 * me, q += 38 * we, U += 38 * ye, V += 38 * De, re += 38 * He, K += 38 * Ue, p = 1, c = D + p + 65535, p = Math.floor(c / 65536), D = c - p * 65536, c = R + p + 65535, p = Math.floor(c / 65536), R = c - p * 65536, c = k + p + 65535, p = Math.floor(c / 65536), k = c - p * 65536, c = B + p + 65535, p = Math.floor(c / 65536), B = c - p * 65536, c = W + p + 65535, p = Math.floor(c / 65536), W = c - p * 65536, c = C + p + 65535, p = Math.floor(c / 65536), C = c - p * 65536, c = N + p + 65535, p = Math.floor(c / 65536), N = c - p * 65536, c = G + p + 65535, p = Math.floor(c / 65536), G = c - p * 65536, c = z + p + 65535, p = Math.floor(c / 65536), z = c - p * 65536, c = $ + p + 65535, p = Math.floor(c / 65536), $ = c - p * 65536, c = q + p + 65535, p = Math.floor(c / 65536), q = c - p * 65536, c = U + p + 65535, p = Math.floor(c / 65536), U = c - p * 65536, c = V + p + 65535, p = Math.floor(c / 65536), V = c - p * 65536, c = re + p + 65535, p = Math.floor(c / 65536), re = c - p * 65536, c = K + p + 65535, p = Math.floor(c / 65536), K = c - p * 65536, c = X + p + 65535, p = Math.floor(c / 65536), X = c - p * 65536, D += p - 1 + 37 * (p - 1), p = 1, c = D + p + 65535, p = Math.floor(c / 65536), D = c - p * 65536, c = R + p + 65535, p = Math.floor(c / 65536), R = c - p * 65536, c = k + p + 65535, p = Math.floor(c / 65536), k = c - p * 65536, c = B + p + 65535, p = Math.floor(c / 65536), B = c - p * 65536, c = W + p + 65535, p = Math.floor(c / 65536), W = c - p * 65536, c = C + p + 65535, p = Math.floor(c / 65536), C = c - p * 65536, c = N + p + 65535, p = Math.floor(c / 65536), N = c - p * 65536, c = G + p + 65535, p = Math.floor(c / 65536), G = c - p * 65536, c = z + p + 65535, p = Math.floor(c / 65536), z = c - p * 65536, c = $ + p + 65535, p = Math.floor(c / 65536), $ = c - p * 65536, c = q + p + 65535, p = Math.floor(c / 65536), q = c - p * 65536, c = U + p + 65535, p = Math.floor(c / 65536), U = c - p * 65536, c = V + p + 65535, p = Math.floor(c / 65536), V = c - p * 65536, c = re + p + 65535, p = Math.floor(c / 65536), re = c - p * 65536, c = K + p + 65535, p = Math.floor(c / 65536), K = c - p * 65536, c = X + p + 65535, p = Math.floor(c / 65536), X = c - p * 65536, D += p - 1 + 37 * (p - 1), b[0] = D, b[1] = R, b[2] = k, b[3] = B, b[4] = W, b[5] = C, b[6] = N, b[7] = G, b[8] = z, b[9] = $, b[10] = q, b[11] = U, b[12] = V, b[13] = re, b[14] = K, b[15] = X;
  }
  function m(b, E) {
    g(b, E, E);
  }
  function w(b, E) {
    const y = n();
    for (let c = 0; c < 16; c++)
      y[c] = E[c];
    for (let c = 253; c >= 0; c--)
      m(y, y), c !== 2 && c !== 4 && g(y, y, E);
    for (let c = 0; c < 16; c++)
      b[c] = y[c];
  }
  function S(b, E) {
    const y = new Uint8Array(32), c = new Float64Array(80), p = n(), D = n(), R = n(), k = n(), B = n(), W = n();
    for (let z = 0; z < 31; z++)
      y[z] = b[z];
    y[31] = b[31] & 127 | 64, y[0] &= 248, u(c, E);
    for (let z = 0; z < 16; z++)
      D[z] = c[z];
    p[0] = k[0] = 1;
    for (let z = 254; z >= 0; --z) {
      const $ = y[z >>> 3] >>> (z & 7) & 1;
      o(p, D, $), o(R, k, $), h(B, p, R), f(p, p, R), h(R, D, k), f(D, D, k), m(k, B), m(W, p), g(p, R, p), g(R, D, B), h(B, p, R), f(p, p, R), m(D, p), f(R, k, W), g(p, R, s), h(p, p, k), g(R, R, p), g(p, k, W), g(k, D, c), m(D, B), o(p, D, $), o(R, k, $);
    }
    for (let z = 0; z < 16; z++)
      c[z + 16] = p[z], c[z + 32] = R[z], c[z + 48] = D[z], c[z + 64] = k[z];
    const C = c.subarray(32), N = c.subarray(16);
    w(C, C), g(N, N, C);
    const G = new Uint8Array(32);
    return l(G, N), G;
  }
  t.scalarMult = S;
  function x(b) {
    return S(b, i);
  }
  t.scalarMultBase = x;
  function M(b) {
    if (b.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const E = new Uint8Array(b);
    return {
      publicKey: x(E),
      secretKey: E
    };
  }
  t.generateKeyPairFromSeed = M;
  function _(b) {
    const E = (0, e.randomBytes)(32, b), y = M(E);
    return (0, r.wipe)(E), y;
  }
  t.generateKeyPair = _;
  function I(b, E, y = !1) {
    if (b.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (E.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const c = S(b, E);
    if (y) {
      let p = 0;
      for (let D = 0; D < c.length; D++)
        p |= c[D];
      if (p === 0)
        throw new Error("X25519: invalid shared key");
    }
    return c;
  }
  t.sharedKey = I;
})(vp);
var Lm = function(t, e, r) {
  if (r || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return t.concat(s || Array.prototype.slice.call(e));
}, OR = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n) {
      this.name = e, this.version = r, this.os = n, this.type = "browser";
    }
    return t;
  }()
), IR = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t;
  }()
), xR = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n, i) {
      this.name = e, this.version = r, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return t;
  }()
), CR = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), DR = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), TR = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, PR = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Mm = 3, RR = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", TR]
], jm = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function NR(t) {
  return t ? km(t) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new DR() : typeof navigator < "u" ? km(navigator.userAgent) : MR();
}
function AR(t) {
  return t !== "" && RR.reduce(function(e, r) {
    var n = r[0], i = r[1];
    if (e)
      return e;
    var s = i.exec(t);
    return !!s && [n, s];
  }, !1);
}
function km(t) {
  var e = AR(t);
  if (!e)
    return null;
  var r = e[0], n = e[1];
  if (r === "searchbot")
    return new CR();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < Mm && (i = Lm(Lm([], i, !0), jR(Mm - i.length), !0)) : i = [];
  var s = i.join("."), a = LR(t), o = PR.exec(t);
  return o && o[1] ? new xR(r, s, a, o[1]) : new OR(r, s, a);
}
function LR(t) {
  for (var e = 0, r = jm.length; e < r; e++) {
    var n = jm[e], i = n[0], s = n[1], a = s.exec(t);
    if (a)
      return i;
  }
  return null;
}
function MR() {
  var t = typeof process < "u" && process.version;
  return t ? new IR(process.version.slice(1)) : null;
}
function jR(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Nt = {};
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.getLocalStorage = Nt.getLocalStorageOrThrow = Nt.getCrypto = Nt.getCryptoOrThrow = _w = Nt.getLocation = Nt.getLocationOrThrow = wp = Nt.getNavigator = Nt.getNavigatorOrThrow = bp = Nt.getDocument = Nt.getDocumentOrThrow = Nt.getFromWindowOrThrow = Nt.getFromWindow = void 0;
function Us(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Nt.getFromWindow = Us;
function ko(t) {
  const e = Us(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Nt.getFromWindowOrThrow = ko;
function kR() {
  return ko("document");
}
Nt.getDocumentOrThrow = kR;
function UR() {
  return Us("document");
}
var bp = Nt.getDocument = UR;
function $R() {
  return ko("navigator");
}
Nt.getNavigatorOrThrow = $R;
function FR() {
  return Us("navigator");
}
var wp = Nt.getNavigator = FR;
function qR() {
  return ko("location");
}
Nt.getLocationOrThrow = qR;
function zR() {
  return Us("location");
}
var _w = Nt.getLocation = zR;
function VR() {
  return ko("crypto");
}
Nt.getCryptoOrThrow = VR;
function KR() {
  return Us("crypto");
}
Nt.getCrypto = KR;
function BR() {
  return ko("localStorage");
}
Nt.getLocalStorageOrThrow = BR;
function HR() {
  return Us("localStorage");
}
Nt.getLocalStorage = HR;
var _p = {};
Object.defineProperty(_p, "__esModule", { value: !0 });
var Ew = _p.getWindowMetadata = void 0;
const Um = Nt;
function WR() {
  let t, e;
  try {
    t = Um.getDocumentOrThrow(), e = Um.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const h = t.getElementsByTagName("link"), f = [];
    for (let g = 0; g < h.length; g++) {
      const m = h[g], w = m.getAttribute("rel");
      if (w && w.toLowerCase().indexOf("icon") > -1) {
        const S = m.getAttribute("href");
        if (S)
          if (S.toLowerCase().indexOf("https:") === -1 && S.toLowerCase().indexOf("http:") === -1 && S.indexOf("//") !== 0) {
            let x = e.protocol + "//" + e.host;
            if (S.indexOf("/") === 0)
              x += S;
            else {
              const M = e.pathname.split("/");
              M.pop();
              const _ = M.join("/");
              x += _ + "/" + S;
            }
            f.push(x);
          } else if (S.indexOf("//") === 0) {
            const x = e.protocol + S;
            f.push(x);
          } else
            f.push(S);
      }
    }
    return f;
  }
  function n(...h) {
    const f = t.getElementsByTagName("meta");
    for (let g = 0; g < f.length; g++) {
      const m = f[g], w = ["itemprop", "property", "name"].map((S) => m.getAttribute(S)).filter((S) => S ? h.includes(S) : !1);
      if (w.length && w) {
        const S = m.getAttribute("content");
        if (S)
          return S;
      }
    }
    return "";
  }
  function i() {
    let h = n("name", "og:site_name", "og:title", "twitter:title");
    return h || (h = t.title), h;
  }
  function s() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const a = i(), o = s(), l = e.origin, u = r();
  return {
    description: o,
    url: l,
    icons: u,
    name: a
  };
}
Ew = _p.getWindowMetadata = WR;
var Aa = {}, GR = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), Sw = "%[a-f0-9]{2}", $m = new RegExp("(" + Sw + ")|([^%]+?)", "gi"), Fm = new RegExp("(" + Sw + ")+", "gi");
function Zd(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), n = t.slice(e);
  return Array.prototype.concat.call([], Zd(r), Zd(n));
}
function ZR(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match($m) || [], r = 1; r < e.length; r++)
      t = Zd(e, r).join(""), e = t.match($m) || [];
    return t;
  }
}
function YR(t) {
  for (var e = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, r = Fm.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = ZR(r[0]);
      n !== r[0] && (e[r[0]] = n);
    }
    r = Fm.exec(t);
  }
  e["%C2"] = "�";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var a = i[s];
    t = t.replace(new RegExp(a, "g"), e[a]);
  }
  return t;
}
var QR = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return YR(t);
  }
}, JR = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, XR = function(t, e) {
  for (var r = {}, n = Object.keys(t), i = Array.isArray(e), s = 0; s < n.length; s++) {
    var a = n[s], o = t[a];
    (i ? e.indexOf(a) !== -1 : e(a, o, t)) && (r[a] = o);
  }
  return r;
};
(function(t) {
  const e = GR, r = QR, n = JR, i = XR, s = (_) => _ == null, a = Symbol("encodeFragmentIdentifier");
  function o(_) {
    switch (_.arrayFormat) {
      case "index":
        return (I) => (b, E) => {
          const y = b.length;
          return E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, [h(I, _), "[", y, "]"].join("")] : [
            ...b,
            [h(I, _), "[", h(y, _), "]=", h(E, _)].join("")
          ];
        };
      case "bracket":
        return (I) => (b, E) => E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, [h(I, _), "[]"].join("")] : [...b, [h(I, _), "[]=", h(E, _)].join("")];
      case "colon-list-separator":
        return (I) => (b, E) => E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, [h(I, _), ":list="].join("")] : [...b, [h(I, _), ":list=", h(E, _)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const I = _.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (b) => (E, y) => y === void 0 || _.skipNull && y === null || _.skipEmptyString && y === "" ? E : (y = y === null ? "" : y, E.length === 0 ? [[h(b, _), I, h(y, _)].join("")] : [[E, h(y, _)].join(_.arrayFormatSeparator)]);
      }
      default:
        return (I) => (b, E) => E === void 0 || _.skipNull && E === null || _.skipEmptyString && E === "" ? b : E === null ? [...b, h(I, _)] : [...b, [h(I, _), "=", h(E, _)].join("")];
    }
  }
  function l(_) {
    let I;
    switch (_.arrayFormat) {
      case "index":
        return (b, E, y) => {
          if (I = /\[(\d*)\]$/.exec(b), b = b.replace(/\[\d*\]$/, ""), !I) {
            y[b] = E;
            return;
          }
          y[b] === void 0 && (y[b] = {}), y[b][I[1]] = E;
        };
      case "bracket":
        return (b, E, y) => {
          if (I = /(\[\])$/.exec(b), b = b.replace(/\[\]$/, ""), !I) {
            y[b] = E;
            return;
          }
          if (y[b] === void 0) {
            y[b] = [E];
            return;
          }
          y[b] = [].concat(y[b], E);
        };
      case "colon-list-separator":
        return (b, E, y) => {
          if (I = /(:list)$/.exec(b), b = b.replace(/:list$/, ""), !I) {
            y[b] = E;
            return;
          }
          if (y[b] === void 0) {
            y[b] = [E];
            return;
          }
          y[b] = [].concat(y[b], E);
        };
      case "comma":
      case "separator":
        return (b, E, y) => {
          const c = typeof E == "string" && E.includes(_.arrayFormatSeparator), p = typeof E == "string" && !c && f(E, _).includes(_.arrayFormatSeparator);
          E = p ? f(E, _) : E;
          const D = c || p ? E.split(_.arrayFormatSeparator).map((R) => f(R, _)) : E === null ? E : f(E, _);
          y[b] = D;
        };
      case "bracket-separator":
        return (b, E, y) => {
          const c = /(\[\])$/.test(b);
          if (b = b.replace(/\[\]$/, ""), !c) {
            y[b] = E && f(E, _);
            return;
          }
          const p = E === null ? [] : E.split(_.arrayFormatSeparator).map((D) => f(D, _));
          if (y[b] === void 0) {
            y[b] = p;
            return;
          }
          y[b] = [].concat(y[b], p);
        };
      default:
        return (b, E, y) => {
          if (y[b] === void 0) {
            y[b] = E;
            return;
          }
          y[b] = [].concat(y[b], E);
        };
    }
  }
  function u(_) {
    if (typeof _ != "string" || _.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function h(_, I) {
    return I.encode ? I.strict ? e(_) : encodeURIComponent(_) : _;
  }
  function f(_, I) {
    return I.decode ? r(_) : _;
  }
  function g(_) {
    return Array.isArray(_) ? _.sort() : typeof _ == "object" ? g(Object.keys(_)).sort((I, b) => Number(I) - Number(b)).map((I) => _[I]) : _;
  }
  function m(_) {
    const I = _.indexOf("#");
    return I !== -1 && (_ = _.slice(0, I)), _;
  }
  function w(_) {
    let I = "";
    const b = _.indexOf("#");
    return b !== -1 && (I = _.slice(b)), I;
  }
  function S(_) {
    _ = m(_);
    const I = _.indexOf("?");
    return I === -1 ? "" : _.slice(I + 1);
  }
  function x(_, I) {
    return I.parseNumbers && !Number.isNaN(Number(_)) && typeof _ == "string" && _.trim() !== "" ? _ = Number(_) : I.parseBooleans && _ !== null && (_.toLowerCase() === "true" || _.toLowerCase() === "false") && (_ = _.toLowerCase() === "true"), _;
  }
  function M(_, I) {
    I = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, I), u(I.arrayFormatSeparator);
    const b = l(I), E = /* @__PURE__ */ Object.create(null);
    if (typeof _ != "string" || (_ = _.trim().replace(/^[?#&]/, ""), !_))
      return E;
    for (const y of _.split("&")) {
      if (y === "")
        continue;
      let [c, p] = n(I.decode ? y.replace(/\+/g, " ") : y, "=");
      p = p === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(I.arrayFormat) ? p : f(p, I), b(f(c, I), p, E);
    }
    for (const y of Object.keys(E)) {
      const c = E[y];
      if (typeof c == "object" && c !== null)
        for (const p of Object.keys(c))
          c[p] = x(c[p], I);
      else
        E[y] = x(c, I);
    }
    return I.sort === !1 ? E : (I.sort === !0 ? Object.keys(E).sort() : Object.keys(E).sort(I.sort)).reduce((y, c) => {
      const p = E[c];
      return p && typeof p == "object" && !Array.isArray(p) ? y[c] = g(p) : y[c] = p, y;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = S, t.parse = M, t.stringify = (_, I) => {
    if (!_)
      return "";
    I = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, I), u(I.arrayFormatSeparator);
    const b = (p) => I.skipNull && s(_[p]) || I.skipEmptyString && _[p] === "", E = o(I), y = {};
    for (const p of Object.keys(_))
      b(p) || (y[p] = _[p]);
    const c = Object.keys(y);
    return I.sort !== !1 && c.sort(I.sort), c.map((p) => {
      const D = _[p];
      return D === void 0 ? "" : D === null ? h(p, I) : Array.isArray(D) ? D.length === 0 && I.arrayFormat === "bracket-separator" ? h(p, I) + "[]" : D.reduce(E(p), []).join("&") : h(p, I) + "=" + h(D, I);
    }).filter((p) => p.length > 0).join("&");
  }, t.parseUrl = (_, I) => {
    I = Object.assign({
      decode: !0
    }, I);
    const [b, E] = n(_, "#");
    return Object.assign(
      {
        url: b.split("?")[0] || "",
        query: M(S(_), I)
      },
      I && I.parseFragmentIdentifier && E ? { fragmentIdentifier: f(E, I) } : {}
    );
  }, t.stringifyUrl = (_, I) => {
    I = Object.assign({
      encode: !0,
      strict: !0,
      [a]: !0
    }, I);
    const b = m(_.url).split("?")[0] || "", E = t.extract(_.url), y = t.parse(E, { sort: !1 }), c = Object.assign(y, _.query);
    let p = t.stringify(c, I);
    p && (p = `?${p}`);
    let D = w(_.url);
    return _.fragmentIdentifier && (D = `#${I[a] ? h(_.fragmentIdentifier, I) : _.fragmentIdentifier}`), `${b}${p}${D}`;
  }, t.pick = (_, I, b) => {
    b = Object.assign({
      parseFragmentIdentifier: !0,
      [a]: !1
    }, b);
    const { url: E, query: y, fragmentIdentifier: c } = t.parseUrl(_, b);
    return t.stringifyUrl({
      url: E,
      query: i(y, I),
      fragmentIdentifier: c
    }, b);
  }, t.exclude = (_, I, b) => {
    const E = Array.isArray(I) ? (y) => !I.includes(y) : (y, c) => !I(y, c);
    return t.pick(_, E, b);
  };
})(Aa);
const eN = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function Ow(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
const Iw = "base10", Wr = "base16", Yd = "base64pad", Ep = "utf8", xw = 0, $s = 1, tN = 0, qm = 1, Qd = 12, Sp = 32;
function rN() {
  const t = vp.generateKeyPair();
  return { privateKey: Zr(t.secretKey, Wr), publicKey: Zr(t.publicKey, Wr) };
}
function Jd() {
  const t = jo.randomBytes(Sp);
  return Zr(t, Wr);
}
function nN(t, e) {
  const r = vp.sharedKey(sn(t, Wr), sn(e, Wr), !0), n = new SR(Cl.SHA256, r).expand(Sp);
  return Zr(n, Wr);
}
function iN(t) {
  const e = Cl.hash(sn(t, Wr));
  return Zr(e, Wr);
}
function lo(t) {
  const e = Cl.hash(sn(t, Ep));
  return Zr(e, Wr);
}
function sN(t) {
  return sn(`${t}`, Iw);
}
function Pc(t) {
  return Number(Zr(t, Iw));
}
function oN(t) {
  const e = sN(typeof t.type < "u" ? t.type : xw);
  if (Pc(e) === $s && typeof t.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? sn(t.senderPublicKey, Wr) : void 0, n = typeof t.iv < "u" ? sn(t.iv, Wr) : jo.randomBytes(Qd), i = new yp.ChaCha20Poly1305(sn(t.symKey, Wr)).seal(n, sn(t.message, Ep));
  return cN({ type: e, sealed: i, iv: n, senderPublicKey: r });
}
function aN(t) {
  const e = new yp.ChaCha20Poly1305(sn(t.symKey, Wr)), { sealed: r, iv: n } = Tu(t.encoded), i = e.open(n, r);
  if (i === null)
    throw new Error("Failed to decrypt");
  return Zr(i, Ep);
}
function cN(t) {
  if (Pc(t.type) === $s) {
    if (typeof t.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return Zr(Wd([t.type, t.senderPublicKey, t.iv, t.sealed]), Yd);
  }
  return Zr(Wd([t.type, t.iv, t.sealed]), Yd);
}
function Tu(t) {
  const e = sn(t, Yd), r = e.slice(tN, qm), n = qm;
  if (Pc(r) === $s) {
    const o = n + Sp, l = o + Qd, u = e.slice(n, o), h = e.slice(o, l), f = e.slice(l);
    return { type: r, sealed: f, iv: h, senderPublicKey: u };
  }
  const i = n + Qd, s = e.slice(n, i), a = e.slice(i);
  return { type: r, sealed: a, iv: s };
}
function uN(t, e) {
  const r = Tu(t);
  return Cw({ type: Pc(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? Zr(r.senderPublicKey, Wr) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function Cw(t) {
  const e = (t == null ? void 0 : t.type) || xw;
  if (e === $s) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function zm(t) {
  return t.type === $s && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
var lN = Object.defineProperty, Vm = Object.getOwnPropertySymbols, hN = Object.prototype.hasOwnProperty, dN = Object.prototype.propertyIsEnumerable, Km = (t, e, r) => e in t ? lN(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Bm = (t, e) => {
  for (var r in e || (e = {}))
    hN.call(e, r) && Km(t, r, e[r]);
  if (Vm)
    for (var r of Vm(e))
      dN.call(e, r) && Km(t, r, e[r]);
  return t;
};
const fN = "ReactNative", pn = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, pN = "js";
function Op() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Uo() {
  return !bp() && !!wp() && navigator.product === fN;
}
function $o() {
  return !Op() && !!wp() && !!bp();
}
function Rc() {
  return Uo() ? pn.reactNative : Op() ? pn.node : $o() ? pn.browser : pn.unknown;
}
function gN() {
  var t;
  try {
    return Uo() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function yN(t, e) {
  let r = Aa.parse(t);
  return r = Bm(Bm({}, r), e), t = Aa.stringify(r), t;
}
function mN() {
  return Ew() || { name: "", description: "", url: "", icons: [""] };
}
function vN() {
  if (Rc() === pn.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r, Version: n } = global.Platform;
    return [r, n].join("-");
  }
  const t = NR();
  if (t === null)
    return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function bN() {
  var t;
  const e = Rc();
  return e === pn.browser ? [e, ((t = _w()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function wN(t, e, r) {
  const n = vN(), i = bN();
  return [[t, e].join("-"), [pN, r].join("-"), n, i].join("/");
}
function _N({ protocol: t, version: e, relayUrl: r, sdkVersion: n, auth: i, projectId: s, useOnCloseEvent: a, bundleId: o }) {
  const l = r.split("?"), u = wN(t, e, n), h = { auth: i, ua: u, projectId: s, useOnCloseEvent: a || void 0, origin: o || void 0 }, f = yN(l[1] || "", h);
  return l[0] + "?" + f;
}
function vs(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function Dw(t) {
  return Object.fromEntries(t.entries());
}
function Tw(t) {
  return new Map(Object.entries(t));
}
function Js(t = Ae.FIVE_MINUTES, e) {
  const r = Ae.toMiliseconds(t || Ae.FIVE_MINUTES);
  let n, i, s;
  return { resolve: (a) => {
    s && n && (clearTimeout(s), n(a));
  }, reject: (a) => {
    s && i && (clearTimeout(s), i(a));
  }, done: () => new Promise((a, o) => {
    s = setTimeout(() => {
      o(new Error(e));
    }, r), n = a, i = o;
  }) };
}
function La(t, e, r) {
  return new Promise(async (n, i) => {
    const s = setTimeout(() => i(new Error(r)), e);
    try {
      const a = await t;
      n(a);
    } catch (a) {
      i(a);
    }
    clearTimeout(s);
  });
}
function Pw(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`))
    return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function EN(t) {
  return Pw("topic", t);
}
function SN(t) {
  return Pw("id", t);
}
function Rw(t) {
  const [e, r] = t.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string")
    n.topic = r;
  else if (e === "id" && Number.isInteger(Number(r)))
    n.id = Number(r);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return n;
}
function dn(t, e) {
  return Ae.fromMiliseconds((e || Date.now()) + Ae.toMiliseconds(t));
}
function Li(t) {
  return Date.now() >= Ae.toMiliseconds(t);
}
function Wt(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
async function ON({ id: t, topic: e, wcDeepLink: r }) {
  try {
    if (!r)
      return;
    const n = typeof r == "string" ? JSON.parse(r) : r;
    let i = n == null ? void 0 : n.href;
    if (typeof i != "string")
      return;
    i.endsWith("/") && (i = i.slice(0, -1));
    const s = `${i}/wc?requestId=${t}&sessionTopic=${e}`, a = Rc();
    a === pn.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : a === pn.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (n) {
    console.error(n);
  }
}
async function IN(t, e) {
  try {
    return await t.getItem(e) || ($o() ? localStorage.getItem(e) : void 0);
  } catch (r) {
    console.error(r);
  }
}
const xN = "irn";
function Xd(t) {
  return (t == null ? void 0 : t.relay) || { protocol: xN };
}
function lu(t) {
  const e = eN[t];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var CN = Object.defineProperty, DN = Object.defineProperties, TN = Object.getOwnPropertyDescriptors, Hm = Object.getOwnPropertySymbols, PN = Object.prototype.hasOwnProperty, RN = Object.prototype.propertyIsEnumerable, Wm = (t, e, r) => e in t ? CN(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, NN = (t, e) => {
  for (var r in e || (e = {}))
    PN.call(e, r) && Wm(t, r, e[r]);
  if (Hm)
    for (var r of Hm(e))
      RN.call(e, r) && Wm(t, r, e[r]);
  return t;
}, AN = (t, e) => DN(t, TN(e));
function LN(t, e = "-") {
  const r = {}, n = "relay" + e;
  return Object.keys(t).forEach((i) => {
    if (i.startsWith(n)) {
      const s = i.replace(n, ""), a = t[i];
      r[s] = a;
    }
  }), r;
}
function Gm(t) {
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, n = t.substring(0, e), i = t.substring(e + 1, r).split("@"), s = typeof r < "u" ? t.substring(r) : "", a = Aa.parse(s);
  return { protocol: n, topic: MN(i[0]), version: parseInt(i[1], 10), symKey: a.symKey, relay: LN(a), expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0 };
}
function MN(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function jN(t, e = "-") {
  const r = "relay", n = {};
  return Object.keys(t).forEach((i) => {
    const s = r + e + i;
    t[i] && (n[s] = t[i]);
  }), n;
}
function kN(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + Aa.stringify(AN(NN({ symKey: t.symKey }, jN(t.relay)), { expiryTimestamp: t.expiryTimestamp }));
}
function Fo(t) {
  const e = [];
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.push(`${n}:${i}`);
  }), e;
}
function UN(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...Fo(r.accounts));
  }), e;
}
function $N(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    Fo(n.accounts).includes(e) && r.push(...n.methods);
  }), r;
}
function FN(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    Fo(n.accounts).includes(e) && r.push(...n.events);
  }), r;
}
const qN = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, zN = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function he(t, e) {
  const { message: r, code: n } = zN[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function Gt(t, e) {
  const { message: r, code: n } = qN[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function Nc(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : !0 : !1;
}
function Pu(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function Vr(t) {
  return typeof t > "u";
}
function ur(t, e) {
  return e && Vr(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function Ip(t, e) {
  return e && Vr(t) ? !0 : typeof t == "number" && !isNaN(t);
}
function VN(t, e) {
  const { requiredNamespaces: r } = e, n = Object.keys(t.namespaces), i = Object.keys(r);
  let s = !0;
  return vs(i, n) ? (n.forEach((a) => {
    const { accounts: o, methods: l, events: u } = t.namespaces[a], h = Fo(o), f = r[a];
    (!vs(Ow(a, f), h) || !vs(f.methods, l) || !vs(f.events, u)) && (s = !1);
  }), s) : !1;
}
function Ru(t) {
  return ur(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function KN(t) {
  if (ur(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && Ru(r);
    }
  }
  return !1;
}
function BN(t) {
  if (ur(t, !1))
    try {
      return typeof new URL(t) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function HN(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function WN(t) {
  return t == null ? void 0 : t.topic;
}
function GN(t, e) {
  let r = null;
  return ur(t == null ? void 0 : t.publicKey, !1) || (r = he("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function Zm(t) {
  let e = !0;
  return Nc(t) ? t.length && (e = t.every((r) => ur(r, !1))) : e = !1, e;
}
function ZN(t, e, r) {
  let n = null;
  return Nc(e) && e.length ? e.forEach((i) => {
    n || Ru(i) || (n = Gt("UNSUPPORTED_CHAINS", `${r}, chain ${i} should be a string and conform to "namespace:chainId" format`));
  }) : Ru(t) || (n = Gt("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function YN(t, e, r) {
  let n = null;
  return Object.entries(t).forEach(([i, s]) => {
    if (n)
      return;
    const a = ZN(i, Ow(i, s), `${e} ${r}`);
    a && (n = a);
  }), n;
}
function QN(t, e) {
  let r = null;
  return Nc(t) ? t.forEach((n) => {
    r || KN(n) || (r = Gt("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = Gt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function JN(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r)
      return;
    const i = QN(n == null ? void 0 : n.accounts, `${e} namespace`);
    i && (r = i);
  }), r;
}
function XN(t, e) {
  let r = null;
  return Zm(t == null ? void 0 : t.methods) ? Zm(t == null ? void 0 : t.events) || (r = Gt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = Gt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function Nw(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r)
      return;
    const i = XN(n, `${e}, namespace`);
    i && (r = i);
  }), r;
}
function eA(t, e, r) {
  let n = null;
  if (t && Pu(t)) {
    const i = Nw(t, e);
    i && (n = i);
    const s = YN(t, e, r);
    s && (n = s);
  } else
    n = he("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return n;
}
function Bh(t, e) {
  let r = null;
  if (t && Pu(t)) {
    const n = Nw(t, e);
    n && (r = n);
    const i = JN(t, e);
    i && (r = i);
  } else
    r = he("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function Aw(t) {
  return ur(t.protocol, !0);
}
function tA(t, e) {
  let r = !1;
  return e && !t ? r = !0 : t && Nc(t) && t.length && t.forEach((n) => {
    r = Aw(n);
  }), r;
}
function rA(t) {
  return typeof t == "number";
}
function rn(t) {
  return typeof t < "u" && typeof t !== null;
}
function nA(t) {
  return !(!t || typeof t != "object" || !t.code || !Ip(t.code, !1) || !t.message || !ur(t.message, !1));
}
function iA(t) {
  return !(Vr(t) || !ur(t.method, !1));
}
function sA(t) {
  return !(Vr(t) || Vr(t.result) && Vr(t.error) || !Ip(t.id, !1) || !ur(t.jsonrpc, !1));
}
function oA(t) {
  return !(Vr(t) || !ur(t.name, !1));
}
function Ym(t, e) {
  return !(!Ru(e) || !UN(t).includes(e));
}
function aA(t, e, r) {
  return ur(r, !1) ? $N(t, e).includes(r) : !1;
}
function cA(t, e, r) {
  return ur(r, !1) ? FN(t, e).includes(r) : !1;
}
function Qm(t, e, r) {
  let n = null;
  const i = uA(t), s = lA(e), a = Object.keys(i), o = Object.keys(s), l = Jm(Object.keys(t)), u = Jm(Object.keys(e)), h = l.filter((f) => !u.includes(f));
  return h.length && (n = he("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${h.toString()}
      Received: ${Object.keys(e).toString()}`)), vs(a, o) || (n = he("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`)), Object.keys(e).forEach((f) => {
    if (!f.includes(":") || n)
      return;
    const g = Fo(e[f].accounts);
    g.includes(f) || (n = he("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${f}
        Required: ${f}
        Approved: ${g.toString()}`));
  }), a.forEach((f) => {
    n || (vs(i[f].methods, s[f].methods) ? vs(i[f].events, s[f].events) || (n = he("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${f}`)) : n = he("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${f}`));
  }), n;
}
function uA(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var n;
    r.includes(":") ? e[r] = t[r] : (n = t[r].chains) == null || n.forEach((i) => {
      e[i] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function Jm(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function lA(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":"))
      e[r] = t[r];
    else {
      const n = Fo(t[r].accounts);
      n == null || n.forEach((i) => {
        e[i] = { accounts: t[r].accounts.filter((s) => s.includes(`${i}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function hA(t, e) {
  return Ip(t, !1) && t <= e.max && t >= e.min;
}
function Xm() {
  const t = Rc();
  return new Promise((e) => {
    switch (t) {
      case pn.browser:
        e(dA());
        break;
      case pn.reactNative:
        e(fA());
        break;
      case pn.node:
        e(pA());
        break;
      default:
        e(!0);
    }
  });
}
function dA() {
  return $o() && (navigator == null ? void 0 : navigator.onLine);
}
async function fA() {
  if (Uo() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function pA() {
  return !0;
}
function gA(t) {
  switch (Rc()) {
    case pn.browser:
      yA(t);
      break;
    case pn.reactNative:
      mA(t);
      break;
  }
}
function yA(t) {
  !Uo() && $o() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function mA(t) {
  Uo() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
const Hh = {};
let Zc = class {
  static get(t) {
    return Hh[t];
  }
  static set(t, e) {
    Hh[t] = e;
  }
  static delete(t) {
    delete Hh[t];
  }
};
const vA = "PARSE_ERROR", bA = "INVALID_REQUEST", wA = "METHOD_NOT_FOUND", _A = "INVALID_PARAMS", Lw = "INTERNAL_ERROR", xp = "SERVER_ERROR", EA = [-32700, -32600, -32601, -32602, -32603], Oa = {
  [vA]: { code: -32700, message: "Parse error" },
  [bA]: { code: -32600, message: "Invalid Request" },
  [wA]: { code: -32601, message: "Method not found" },
  [_A]: { code: -32602, message: "Invalid params" },
  [Lw]: { code: -32603, message: "Internal error" },
  [xp]: { code: -32e3, message: "Server error" }
}, Mw = xp;
function SA(t) {
  return EA.includes(t);
}
function ev(t) {
  return Object.keys(Oa).includes(t) ? Oa[t] : Oa[Mw];
}
function OA(t) {
  return Object.values(Oa).find((r) => r.code === t) || Oa[Mw];
}
function IA(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var jw = {}, yi = {}, tv;
function xA() {
  if (tv)
    return yi;
  tv = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.isBrowserCryptoAvailable = yi.getSubtleCrypto = yi.getBrowerCrypto = void 0;
  function t() {
    return (ki == null ? void 0 : ki.crypto) || (ki == null ? void 0 : ki.msCrypto) || {};
  }
  yi.getBrowerCrypto = t;
  function e() {
    const n = t();
    return n.subtle || n.webkitSubtle;
  }
  yi.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return yi.isBrowserCryptoAvailable = r, yi;
}
var mi = {}, rv;
function CA() {
  if (rv)
    return mi;
  rv = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.isBrowser = mi.isNode = mi.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  mi.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  mi.isNode = e;
  function r() {
    return !t() && !e();
  }
  return mi.isBrowser = r, mi;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = ii;
  e.__exportStar(xA(), t), e.__exportStar(CA(), t);
})(jw);
function Cp(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function kw(t = 6) {
  return BigInt(Cp(t));
}
function ho(t, e, r) {
  return {
    id: r || Cp(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function Dp(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function Tp(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: DA(e, r)
  };
}
function DA(t, e) {
  return typeof t > "u" ? ev(Lw) : (typeof t == "string" && (t = Object.assign(Object.assign({}, ev(xp)), { message: t })), typeof e < "u" && (t.data = e), SA(t.code) && (t = OA(t.code)), t);
}
class TA {
}
class PA extends TA {
  constructor() {
    super();
  }
}
class RA extends PA {
  constructor(e) {
    super();
  }
}
const NA = "^wss?:";
function AA(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function LA(t, e) {
  const r = AA(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function nv(t) {
  return LA(t, NA);
}
function MA(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function Uw(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function Pp(t) {
  return Uw(t) && "method" in t;
}
function Dl(t) {
  return Uw(t) && (Ei(t) || Dn(t));
}
function Ei(t) {
  return "result" in t;
}
function Dn(t) {
  return "error" in t;
}
class jA extends RA {
  constructor(e) {
    super(e), this.events = new En.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(ho(e.method, e.params || [], e.id || kw().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (s) {
          i(s);
        }
      this.events.on(`${e.id}`, (s) => {
        Dn(s) ? i(s.error) : n(s.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), Dl(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
      type: e.method,
      data: e.params
    });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
const kA = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), UA = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", iv = (t) => t.split("?")[0], sv = 10, $A = kA();
class FA {
  constructor(e) {
    if (this.url = e, this.events = new En.EventEmitter(), this.registering = !1, !nv(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(Cc(e));
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  register(e = this.url) {
    if (!nv(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return i(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, n) => {
      const i = new URLSearchParams(e).get("origin"), s = jw.isReactNative() ? { headers: { origin: i } } : { rejectUnauthorized: !MA(e) }, a = new $A(e, [], s);
      UA() ? a.onerror = (o) => {
        const l = o;
        n(this.emitError(l.error));
      } : a.on("error", (o) => {
        n(this.emitError(o));
      }), a.onopen = () => {
        this.onOpen(a), r(a);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const r = typeof e.data == "string" ? _l(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = Tp(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return IA(e, iv(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > sv && this.events.setMaxListeners(sv);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${iv(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
}
var Nu = { exports: {} };
Nu.exports;
(function(t, e) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, a = 9007199254740991, o = "[object Arguments]", l = "[object Array]", u = "[object AsyncFunction]", h = "[object Boolean]", f = "[object Date]", g = "[object Error]", m = "[object Function]", w = "[object GeneratorFunction]", S = "[object Map]", x = "[object Number]", M = "[object Null]", _ = "[object Object]", I = "[object Promise]", b = "[object Proxy]", E = "[object RegExp]", y = "[object Set]", c = "[object String]", p = "[object Symbol]", D = "[object Undefined]", R = "[object WeakMap]", k = "[object ArrayBuffer]", B = "[object DataView]", W = "[object Float32Array]", C = "[object Float64Array]", N = "[object Int8Array]", G = "[object Int16Array]", z = "[object Int32Array]", $ = "[object Uint8Array]", q = "[object Uint8ClampedArray]", U = "[object Uint16Array]", V = "[object Uint32Array]", re = /[\\^$.*+?()[\]{}|]/g, K = /^\[object .+?Constructor\]$/, X = /^(?:0|[1-9]\d*)$/, Y = {};
  Y[W] = Y[C] = Y[N] = Y[G] = Y[z] = Y[$] = Y[q] = Y[U] = Y[V] = !0, Y[o] = Y[l] = Y[k] = Y[h] = Y[B] = Y[f] = Y[g] = Y[m] = Y[S] = Y[x] = Y[_] = Y[E] = Y[y] = Y[c] = Y[R] = !1;
  var ee = typeof ki == "object" && ki && ki.Object === Object && ki, L = typeof self == "object" && self && self.Object === Object && self, A = ee || L || Function("return this")(), T = e && !e.nodeType && e, d = T && !0 && t && !t.nodeType && t, O = d && d.exports === T, H = O && ee.process, Z = function() {
    try {
      return H && H.binding && H.binding("util");
    } catch {
    }
  }(), me = Z && Z.isTypedArray;
  function we(v, P) {
    for (var F = -1, J = v == null ? 0 : v.length, ke = 0, ce = []; ++F < J; ) {
      var Ge = v[F];
      P(Ge, F, v) && (ce[ke++] = Ge);
    }
    return ce;
  }
  function ye(v, P) {
    for (var F = -1, J = P.length, ke = v.length; ++F < J; )
      v[ke + F] = P[F];
    return v;
  }
  function De(v, P) {
    for (var F = -1, J = v == null ? 0 : v.length; ++F < J; )
      if (P(v[F], F, v))
        return !0;
    return !1;
  }
  function He(v, P) {
    for (var F = -1, J = Array(v); ++F < v; )
      J[F] = P(F);
    return J;
  }
  function Ue(v) {
    return function(P) {
      return v(P);
    };
  }
  function _e(v, P) {
    return v.has(P);
  }
  function be(v, P) {
    return v == null ? void 0 : v[P];
  }
  function de(v) {
    var P = -1, F = Array(v.size);
    return v.forEach(function(J, ke) {
      F[++P] = [ke, J];
    }), F;
  }
  function fe(v, P) {
    return function(F) {
      return v(P(F));
    };
  }
  function ue(v) {
    var P = -1, F = Array(v.size);
    return v.forEach(function(J) {
      F[++P] = J;
    }), F;
  }
  var ae = Array.prototype, oe = Function.prototype, te = Object.prototype, pe = A["__core-js_shared__"], ve = oe.toString, ne = te.hasOwnProperty, Ee = function() {
    var v = /[^.]+$/.exec(pe && pe.keys && pe.keys.IE_PROTO || "");
    return v ? "Symbol(src)_1." + v : "";
  }(), Ie = te.toString, Pe = RegExp(
    "^" + ve.call(ne).replace(re, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Re = O ? A.Buffer : void 0, Te = A.Symbol, At = A.Uint8Array, Ft = te.propertyIsEnumerable, Qt = ae.splice, It = Te ? Te.toStringTag : void 0, er = Object.getOwnPropertySymbols, tr = Re ? Re.isBuffer : void 0, an = fe(Object.keys, Object), We = un(A, "DataView"), Fe = un(A, "Map"), Qe = un(A, "Promise"), Ze = un(A, "Set"), Je = un(A, "WeakMap"), qe = un(Object, "create"), at = Lr(We), lt = Lr(Fe), ht = Lr(Qe), ct = Lr(Ze), dt = Lr(Je), it = Te ? Te.prototype : void 0, Xe = it ? it.valueOf : void 0;
  function je(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.clear(); ++P < F; ) {
      var J = v[P];
      this.set(J[0], J[1]);
    }
  }
  function j() {
    this.__data__ = qe ? qe(null) : {}, this.size = 0;
  }
  function Q(v) {
    var P = this.has(v) && delete this.__data__[v];
    return this.size -= P ? 1 : 0, P;
  }
  function ge(v) {
    var P = this.__data__;
    if (qe) {
      var F = P[v];
      return F === n ? void 0 : F;
    }
    return ne.call(P, v) ? P[v] : void 0;
  }
  function $e(v) {
    var P = this.__data__;
    return qe ? P[v] !== void 0 : ne.call(P, v);
  }
  function mt(v, P) {
    var F = this.__data__;
    return this.size += this.has(v) ? 0 : 1, F[v] = qe && P === void 0 ? n : P, this;
  }
  je.prototype.clear = j, je.prototype.delete = Q, je.prototype.get = ge, je.prototype.has = $e, je.prototype.set = mt;
  function Ke(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.clear(); ++P < F; ) {
      var J = v[P];
      this.set(J[0], J[1]);
    }
  }
  function gt() {
    this.__data__ = [], this.size = 0;
  }
  function ut(v) {
    var P = this.__data__, F = oi(P, v);
    if (F < 0)
      return !1;
    var J = P.length - 1;
    return F == J ? P.pop() : Qt.call(P, F, 1), --this.size, !0;
  }
  function Jt(v) {
    var P = this.__data__, F = oi(P, v);
    return F < 0 ? void 0 : P[F][1];
  }
  function Lt(v) {
    return oi(this.__data__, v) > -1;
  }
  function kt(v, P) {
    var F = this.__data__, J = oi(F, v);
    return J < 0 ? (++this.size, F.push([v, P])) : F[J][1] = P, this;
  }
  Ke.prototype.clear = gt, Ke.prototype.delete = ut, Ke.prototype.get = Jt, Ke.prototype.has = Lt, Ke.prototype.set = kt;
  function Ct(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.clear(); ++P < F; ) {
      var J = v[P];
      this.set(J[0], J[1]);
    }
  }
  function qn() {
    this.size = 0, this.__data__ = {
      hash: new je(),
      map: new (Fe || Ke)(),
      string: new je()
    };
  }
  function Fs(v) {
    var P = ai(this, v).delete(v);
    return this.size -= P ? 1 : 0, P;
  }
  function cn(v) {
    return ai(this, v).get(v);
  }
  function Ul(v) {
    return ai(this, v).has(v);
  }
  function $l(v, P) {
    var F = ai(this, v), J = F.size;
    return F.set(v, P), this.size += F.size == J ? 0 : 1, this;
  }
  Ct.prototype.clear = qn, Ct.prototype.delete = Fs, Ct.prototype.get = cn, Ct.prototype.has = Ul, Ct.prototype.set = $l;
  function si(v) {
    var P = -1, F = v == null ? 0 : v.length;
    for (this.__data__ = new Ct(); ++P < F; )
      this.add(v[P]);
  }
  function Fl(v) {
    return this.__data__.set(v, n), this;
  }
  function ql(v) {
    return this.__data__.has(v);
  }
  si.prototype.add = si.prototype.push = Fl, si.prototype.has = ql;
  function hr(v) {
    var P = this.__data__ = new Ke(v);
    this.size = P.size;
  }
  function zl() {
    this.__data__ = new Ke(), this.size = 0;
  }
  function Vl(v) {
    var P = this.__data__, F = P.delete(v);
    return this.size = P.size, F;
  }
  function Kl(v) {
    return this.__data__.get(v);
  }
  function Bl(v) {
    return this.__data__.has(v);
  }
  function Hl(v, P) {
    var F = this.__data__;
    if (F instanceof Ke) {
      var J = F.__data__;
      if (!Fe || J.length < r - 1)
        return J.push([v, P]), this.size = ++F.size, this;
      F = this.__data__ = new Ct(J);
    }
    return F.set(v, P), this.size = F.size, this;
  }
  hr.prototype.clear = zl, hr.prototype.delete = Vl, hr.prototype.get = Kl, hr.prototype.has = Bl, hr.prototype.set = Hl;
  function Wl(v, P) {
    var F = ci(v), J = !F && ch(v), ke = !F && !J && es(v), ce = !F && !J && !ke && Yo(v), Ge = F || J || ke || ce, yt = Ge ? He(v.length, String) : [], vt = yt.length;
    for (var Be in v)
      (P || ne.call(v, Be)) && !(Ge && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Be == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      ke && (Be == "offset" || Be == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      ce && (Be == "buffer" || Be == "byteLength" || Be == "byteOffset") || // Skip index properties.
      nh(Be, vt))) && yt.push(Be);
    return yt;
  }
  function oi(v, P) {
    for (var F = v.length; F--; )
      if (Ho(v[F][0], P))
        return F;
    return -1;
  }
  function Gl(v, P, F) {
    var J = P(v);
    return ci(v) ? J : ye(J, F(v));
  }
  function Sn(v) {
    return v == null ? v === void 0 ? D : M : It && It in Object(v) ? th(v) : ah(v);
  }
  function zo(v) {
    return On(v) && Sn(v) == o;
  }
  function Vo(v, P, F, J, ke) {
    return v === P ? !0 : v == null || P == null || !On(v) && !On(P) ? v !== v && P !== P : Zl(v, P, F, J, Vo, ke);
  }
  function Zl(v, P, F, J, ke, ce) {
    var Ge = ci(v), yt = ci(P), vt = Ge ? l : dr(v), Be = yt ? l : dr(P);
    vt = vt == o ? _ : vt, Be = Be == o ? _ : Be;
    var Pt = vt == _, qt = Be == _, _t = vt == Be;
    if (_t && es(v)) {
      if (!es(P))
        return !1;
      Ge = !0, Pt = !1;
    }
    if (_t && !Pt)
      return ce || (ce = new hr()), Ge || Yo(v) ? Ko(v, P, F, J, ke, ce) : Xl(v, P, vt, F, J, ke, ce);
    if (!(F & i)) {
      var Mt = Pt && ne.call(v, "__wrapped__"), jt = qt && ne.call(P, "__wrapped__");
      if (Mt || jt) {
        var fr = Mt ? v.value() : v, Xt = jt ? P.value() : P;
        return ce || (ce = new hr()), ke(fr, Xt, F, J, ce);
      }
    }
    return _t ? (ce || (ce = new hr()), eh(v, P, F, J, ke, ce)) : !1;
  }
  function Yl(v) {
    if (!Zo(v) || sh(v))
      return !1;
    var P = Wo(v) ? Pe : K;
    return P.test(Lr(v));
  }
  function Ql(v) {
    return On(v) && Go(v.length) && !!Y[Sn(v)];
  }
  function Jl(v) {
    if (!oh(v))
      return an(v);
    var P = [];
    for (var F in Object(v))
      ne.call(v, F) && F != "constructor" && P.push(F);
    return P;
  }
  function Ko(v, P, F, J, ke, ce) {
    var Ge = F & i, yt = v.length, vt = P.length;
    if (yt != vt && !(Ge && vt > yt))
      return !1;
    var Be = ce.get(v);
    if (Be && ce.get(P))
      return Be == P;
    var Pt = -1, qt = !0, _t = F & s ? new si() : void 0;
    for (ce.set(v, P), ce.set(P, v); ++Pt < yt; ) {
      var Mt = v[Pt], jt = P[Pt];
      if (J)
        var fr = Ge ? J(jt, Mt, Pt, P, v, ce) : J(Mt, jt, Pt, v, P, ce);
      if (fr !== void 0) {
        if (fr)
          continue;
        qt = !1;
        break;
      }
      if (_t) {
        if (!De(P, function(Xt, Mr) {
          if (!_e(_t, Mr) && (Mt === Xt || ke(Mt, Xt, F, J, ce)))
            return _t.push(Mr);
        })) {
          qt = !1;
          break;
        }
      } else if (!(Mt === jt || ke(Mt, jt, F, J, ce))) {
        qt = !1;
        break;
      }
    }
    return ce.delete(v), ce.delete(P), qt;
  }
  function Xl(v, P, F, J, ke, ce, Ge) {
    switch (F) {
      case B:
        if (v.byteLength != P.byteLength || v.byteOffset != P.byteOffset)
          return !1;
        v = v.buffer, P = P.buffer;
      case k:
        return !(v.byteLength != P.byteLength || !ce(new At(v), new At(P)));
      case h:
      case f:
      case x:
        return Ho(+v, +P);
      case g:
        return v.name == P.name && v.message == P.message;
      case E:
      case c:
        return v == P + "";
      case S:
        var yt = de;
      case y:
        var vt = J & i;
        if (yt || (yt = ue), v.size != P.size && !vt)
          return !1;
        var Be = Ge.get(v);
        if (Be)
          return Be == P;
        J |= s, Ge.set(v, P);
        var Pt = Ko(yt(v), yt(P), J, ke, ce, Ge);
        return Ge.delete(v), Pt;
      case p:
        if (Xe)
          return Xe.call(v) == Xe.call(P);
    }
    return !1;
  }
  function eh(v, P, F, J, ke, ce) {
    var Ge = F & i, yt = Bo(v), vt = yt.length, Be = Bo(P), Pt = Be.length;
    if (vt != Pt && !Ge)
      return !1;
    for (var qt = vt; qt--; ) {
      var _t = yt[qt];
      if (!(Ge ? _t in P : ne.call(P, _t)))
        return !1;
    }
    var Mt = ce.get(v);
    if (Mt && ce.get(P))
      return Mt == P;
    var jt = !0;
    ce.set(v, P), ce.set(P, v);
    for (var fr = Ge; ++qt < vt; ) {
      _t = yt[qt];
      var Xt = v[_t], Mr = P[_t];
      if (J)
        var Qo = Ge ? J(Mr, Xt, _t, P, v, ce) : J(Xt, Mr, _t, v, P, ce);
      if (!(Qo === void 0 ? Xt === Mr || ke(Xt, Mr, F, J, ce) : Qo)) {
        jt = !1;
        break;
      }
      fr || (fr = _t == "constructor");
    }
    if (jt && !fr) {
      var ui = v.constructor, li = P.constructor;
      ui != li && "constructor" in v && "constructor" in P && !(typeof ui == "function" && ui instanceof ui && typeof li == "function" && li instanceof li) && (jt = !1);
    }
    return ce.delete(v), ce.delete(P), jt;
  }
  function Bo(v) {
    return Gl(v, hh, rh);
  }
  function ai(v, P) {
    var F = v.__data__;
    return ih(P) ? F[typeof P == "string" ? "string" : "hash"] : F.map;
  }
  function un(v, P) {
    var F = be(v, P);
    return Yl(F) ? F : void 0;
  }
  function th(v) {
    var P = ne.call(v, It), F = v[It];
    try {
      v[It] = void 0;
      var J = !0;
    } catch {
    }
    var ke = Ie.call(v);
    return J && (P ? v[It] = F : delete v[It]), ke;
  }
  var rh = er ? function(v) {
    return v == null ? [] : (v = Object(v), we(er(v), function(P) {
      return Ft.call(v, P);
    }));
  } : dh, dr = Sn;
  (We && dr(new We(new ArrayBuffer(1))) != B || Fe && dr(new Fe()) != S || Qe && dr(Qe.resolve()) != I || Ze && dr(new Ze()) != y || Je && dr(new Je()) != R) && (dr = function(v) {
    var P = Sn(v), F = P == _ ? v.constructor : void 0, J = F ? Lr(F) : "";
    if (J)
      switch (J) {
        case at:
          return B;
        case lt:
          return S;
        case ht:
          return I;
        case ct:
          return y;
        case dt:
          return R;
      }
    return P;
  });
  function nh(v, P) {
    return P = P ?? a, !!P && (typeof v == "number" || X.test(v)) && v > -1 && v % 1 == 0 && v < P;
  }
  function ih(v) {
    var P = typeof v;
    return P == "string" || P == "number" || P == "symbol" || P == "boolean" ? v !== "__proto__" : v === null;
  }
  function sh(v) {
    return !!Ee && Ee in v;
  }
  function oh(v) {
    var P = v && v.constructor, F = typeof P == "function" && P.prototype || te;
    return v === F;
  }
  function ah(v) {
    return Ie.call(v);
  }
  function Lr(v) {
    if (v != null) {
      try {
        return ve.call(v);
      } catch {
      }
      try {
        return v + "";
      } catch {
      }
    }
    return "";
  }
  function Ho(v, P) {
    return v === P || v !== v && P !== P;
  }
  var ch = zo(/* @__PURE__ */ function() {
    return arguments;
  }()) ? zo : function(v) {
    return On(v) && ne.call(v, "callee") && !Ft.call(v, "callee");
  }, ci = Array.isArray;
  function uh(v) {
    return v != null && Go(v.length) && !Wo(v);
  }
  var es = tr || fh;
  function lh(v, P) {
    return Vo(v, P);
  }
  function Wo(v) {
    if (!Zo(v))
      return !1;
    var P = Sn(v);
    return P == m || P == w || P == u || P == b;
  }
  function Go(v) {
    return typeof v == "number" && v > -1 && v % 1 == 0 && v <= a;
  }
  function Zo(v) {
    var P = typeof v;
    return v != null && (P == "object" || P == "function");
  }
  function On(v) {
    return v != null && typeof v == "object";
  }
  var Yo = me ? Ue(me) : Ql;
  function hh(v) {
    return uh(v) ? Wl(v) : Jl(v);
  }
  function dh() {
    return [];
  }
  function fh() {
    return !1;
  }
  t.exports = lh;
})(Nu, Nu.exports);
var qA = Nu.exports;
const zA = /* @__PURE__ */ vl(qA);
function VA(t, e) {
  return e = e || {}, new Promise(function(r, n) {
    var i = new XMLHttpRequest(), s = [], a = [], o = {}, l = function() {
      return { ok: (i.status / 100 | 0) == 2, statusText: i.statusText, status: i.status, url: i.responseURL, text: function() {
        return Promise.resolve(i.responseText);
      }, json: function() {
        return Promise.resolve(i.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([i.response]));
      }, clone: l, headers: { keys: function() {
        return s;
      }, entries: function() {
        return a;
      }, get: function(h) {
        return o[h.toLowerCase()];
      }, has: function(h) {
        return h.toLowerCase() in o;
      } } };
    };
    for (var u in i.open(e.method || "get", t, !0), i.onload = function() {
      i.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(h, f, g) {
        s.push(f = f.toLowerCase()), a.push([f, g]), o[f] = o[f] ? o[f] + "," + g : g;
      }), r(l());
    }, i.onerror = n, i.withCredentials = e.credentials == "include", e.headers)
      i.setRequestHeader(u, e.headers[u]);
    i.send(e.body || null);
  });
}
const KA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: VA
}, Symbol.toStringTag, { value: "Module" })), ov = /* @__PURE__ */ bl(KA);
var BA = fetch || (self.fetch = ov.default || ov);
const HA = /* @__PURE__ */ vl(BA);
function WA(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), a = s.charCodeAt(0);
    if (r[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[a] = i;
  }
  var o = t.length, l = t.charAt(0), u = Math.log(o) / Math.log(256), h = Math.log(256) / Math.log(o);
  function f(w) {
    if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer, w.byteOffset, w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))), !(w instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (w.length === 0)
      return "";
    for (var S = 0, x = 0, M = 0, _ = w.length; M !== _ && w[M] === 0; )
      M++, S++;
    for (var I = (_ - M) * h + 1 >>> 0, b = new Uint8Array(I); M !== _; ) {
      for (var E = w[M], y = 0, c = I - 1; (E !== 0 || y < x) && c !== -1; c--, y++)
        E += 256 * b[c] >>> 0, b[c] = E % o >>> 0, E = E / o >>> 0;
      if (E !== 0)
        throw new Error("Non-zero carry");
      x = y, M++;
    }
    for (var p = I - x; p !== I && b[p] === 0; )
      p++;
    for (var D = l.repeat(S); p < I; ++p)
      D += t.charAt(b[p]);
    return D;
  }
  function g(w) {
    if (typeof w != "string")
      throw new TypeError("Expected String");
    if (w.length === 0)
      return new Uint8Array();
    var S = 0;
    if (w[S] !== " ") {
      for (var x = 0, M = 0; w[S] === l; )
        x++, S++;
      for (var _ = (w.length - S) * u + 1 >>> 0, I = new Uint8Array(_); w[S]; ) {
        var b = r[w.charCodeAt(S)];
        if (b === 255)
          return;
        for (var E = 0, y = _ - 1; (b !== 0 || E < M) && y !== -1; y--, E++)
          b += o * I[y] >>> 0, I[y] = b % 256 >>> 0, b = b / 256 >>> 0;
        if (b !== 0)
          throw new Error("Non-zero carry");
        M = E, S++;
      }
      if (w[S] !== " ") {
        for (var c = _ - M; c !== _ && I[c] === 0; )
          c++;
        for (var p = new Uint8Array(x + (_ - c)), D = x; c !== _; )
          p[D++] = I[c++];
        return p;
      }
    }
  }
  function m(w) {
    var S = g(w);
    if (S)
      return S;
    throw new Error(`Non-${e} character`);
  }
  return { encode: f, decodeUnsafe: g, decode: m };
}
var GA = WA, ZA = GA;
const $w = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, YA = (t) => new TextEncoder().encode(t), QA = (t) => new TextDecoder().decode(t);
class JA {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class XA {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Fw(this, e);
  }
}
class e8 {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Fw(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Fw = (t, e) => new e8({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class t8 {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new JA(e, r, n), this.decoder = new XA(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Tl = ({ name: t, prefix: e, encode: r, decode: n }) => new t8(t, e, r, n), Ac = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = ZA(r, e);
  return Tl({ prefix: t, name: e, encode: n, decode: (s) => $w(i(s)) });
}, r8 = (t, e, r, n) => {
  const i = {};
  for (let h = 0; h < e.length; ++h)
    i[e[h]] = h;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * r / 8 | 0);
  let o = 0, l = 0, u = 0;
  for (let h = 0; h < s; ++h) {
    const f = i[t[h]];
    if (f === void 0)
      throw new SyntaxError(`Non-${n} character`);
    l = l << r | f, o += r, o >= 8 && (o -= 8, a[u++] = 255 & l >> o);
  }
  if (o >= r || 255 & l << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, n8 = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", a = 0, o = 0;
  for (let l = 0; l < t.length; ++l)
    for (o = o << 8 | t[l], a += 8; a > r; )
      a -= r, s += e[i & o >> a];
  if (a && (s += e[i & o << r - a]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, vr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => Tl({ prefix: e, name: t, encode(i) {
  return n8(i, n, r);
}, decode(i) {
  return r8(i, n, r, t);
} }), i8 = Tl({ prefix: "\0", name: "identity", encode: (t) => QA(t), decode: (t) => YA(t) });
var s8 = Object.freeze({ __proto__: null, identity: i8 });
const o8 = vr({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var a8 = Object.freeze({ __proto__: null, base2: o8 });
const c8 = vr({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var u8 = Object.freeze({ __proto__: null, base8: c8 });
const l8 = Ac({ prefix: "9", name: "base10", alphabet: "0123456789" });
var h8 = Object.freeze({ __proto__: null, base10: l8 });
const d8 = vr({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), f8 = vr({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var p8 = Object.freeze({ __proto__: null, base16: d8, base16upper: f8 });
const g8 = vr({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), y8 = vr({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), m8 = vr({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), v8 = vr({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), b8 = vr({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), w8 = vr({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), _8 = vr({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), E8 = vr({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), S8 = vr({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var O8 = Object.freeze({ __proto__: null, base32: g8, base32upper: y8, base32pad: m8, base32padupper: v8, base32hex: b8, base32hexupper: w8, base32hexpad: _8, base32hexpadupper: E8, base32z: S8 });
const I8 = Ac({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), x8 = Ac({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var C8 = Object.freeze({ __proto__: null, base36: I8, base36upper: x8 });
const D8 = Ac({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), T8 = Ac({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var P8 = Object.freeze({ __proto__: null, base58btc: D8, base58flickr: T8 });
const R8 = vr({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), N8 = vr({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), A8 = vr({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), L8 = vr({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var M8 = Object.freeze({ __proto__: null, base64: R8, base64pad: N8, base64url: A8, base64urlpad: L8 });
const qw = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), j8 = qw.reduce((t, e, r) => (t[r] = e, t), []), k8 = qw.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function U8(t) {
  return t.reduce((e, r) => (e += j8[r], e), "");
}
function $8(t) {
  const e = [];
  for (const r of t) {
    const n = k8[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const F8 = Tl({ prefix: "🚀", name: "base256emoji", encode: U8, decode: $8 });
var q8 = Object.freeze({ __proto__: null, base256emoji: F8 }), z8 = zw, av = 128, V8 = 127, K8 = ~V8, B8 = Math.pow(2, 31);
function zw(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= B8; )
    e[r++] = t & 255 | av, t /= 128;
  for (; t & K8; )
    e[r++] = t & 255 | av, t >>>= 7;
  return e[r] = t | 0, zw.bytes = r - n + 1, e;
}
var H8 = ef, W8 = 128, cv = 127;
function ef(t, n) {
  var r = 0, n = n || 0, i = 0, s = n, a, o = t.length;
  do {
    if (s >= o)
      throw ef.bytes = 0, new RangeError("Could not decode varint");
    a = t[s++], r += i < 28 ? (a & cv) << i : (a & cv) * Math.pow(2, i), i += 7;
  } while (a >= W8);
  return ef.bytes = s - n, r;
}
var G8 = Math.pow(2, 7), Z8 = Math.pow(2, 14), Y8 = Math.pow(2, 21), Q8 = Math.pow(2, 28), J8 = Math.pow(2, 35), X8 = Math.pow(2, 42), eL = Math.pow(2, 49), tL = Math.pow(2, 56), rL = Math.pow(2, 63), nL = function(t) {
  return t < G8 ? 1 : t < Z8 ? 2 : t < Y8 ? 3 : t < Q8 ? 4 : t < J8 ? 5 : t < X8 ? 6 : t < eL ? 7 : t < tL ? 8 : t < rL ? 9 : 10;
}, iL = { encode: z8, decode: H8, encodingLength: nL }, Vw = iL;
const uv = (t, e, r = 0) => (Vw.encode(t, e, r), e), lv = (t) => Vw.encodingLength(t), tf = (t, e) => {
  const r = e.byteLength, n = lv(t), i = n + lv(r), s = new Uint8Array(i + r);
  return uv(t, s, 0), uv(r, s, n), s.set(e, i), new sL(t, r, e, s);
};
class sL {
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
}
const Kw = ({ name: t, code: e, encode: r }) => new oL(t, e, r);
class oL {
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? tf(this.code, r) : r.then((n) => tf(this.code, n));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const Bw = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), aL = Kw({ name: "sha2-256", code: 18, encode: Bw("SHA-256") }), cL = Kw({ name: "sha2-512", code: 19, encode: Bw("SHA-512") });
var uL = Object.freeze({ __proto__: null, sha256: aL, sha512: cL });
const Hw = 0, lL = "identity", Ww = $w, hL = (t) => tf(Hw, Ww(t)), dL = { code: Hw, name: lL, encode: Ww, digest: hL };
var fL = Object.freeze({ __proto__: null, identity: dL });
new TextEncoder(), new TextDecoder();
const hv = { ...s8, ...a8, ...u8, ...h8, ...p8, ...O8, ...C8, ...P8, ...M8, ...q8 };
({ ...uL, ...fL });
function Gw(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function pL(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Gw(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Zw(t, e, r, n) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
}
const dv = Zw("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Wh = Zw("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = pL(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), gL = { utf8: dv, "utf-8": dv, hex: hv.base16, latin1: Wh, ascii: Wh, binary: Wh, ...hv };
function yL(t, e = "utf8") {
  const r = gL[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Gw(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
const Yw = "wc", mL = 2, Rp = "core", qi = `${Yw}@2:${Rp}:`, vL = { name: Rp, logger: "error" }, bL = { database: ":memory:" }, wL = "crypto", fv = "client_ed25519_seed", _L = Ae.ONE_DAY, EL = "keychain", SL = "0.3", OL = "messages", IL = "0.3", xL = Ae.SIX_HOURS, CL = "publisher", Qw = "irn", DL = "error", Jw = "wss://relay.walletconnect.com", pv = "wss://relay.walletconnect.org", TL = "relayer", Pr = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, PL = "_subscription", vi = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, RL = Ae.ONE_SECOND, NL = "2.11.1", AL = 1e4, LL = "0.3", ML = "WALLETCONNECT_CLIENT_ID", xn = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, jL = "subscription", kL = "0.3", UL = Ae.FIVE_SECONDS * 1e3, $L = "pairing", FL = "0.3", la = { wc_pairingDelete: { req: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: Ae.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: Ae.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: Ae.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: Ae.ONE_DAY, prompt: !1, tag: 0 } } }, va = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, Zn = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, qL = "history", zL = "0.3", VL = "expirer", vn = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, KL = "0.3", Gh = "verify-api", io = "https://verify.walletconnect.com", rf = "https://verify.walletconnect.org", BL = [io, rf], HL = "echo", WL = "https://echo.walletconnect.com";
class GL {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = EL, this.version = SL, this.initialized = !1, this.storagePrefix = qi, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, i) => {
      this.isInitialized(), this.keychain.set(n, i), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.keychain.get(n);
      if (typeof i > "u") {
        const { message: s } = he("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(s);
      }
      return i;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = e, this.logger = wt.generateChildLogger(r, this.name);
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Dw(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Tw(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class ZL {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.name = wL, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(), s = Rm(i);
      return gw(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = rN();
      return this.setPrivateKey(i.publicKey, i.privateKey);
    }, this.signJWT = async (i) => {
      this.isInitialized();
      const s = await this.getClientSeed(), a = Rm(s), o = Jd();
      return await lR(o, i, _L, a);
    }, this.generateSharedKey = (i, s, a) => {
      this.isInitialized();
      const o = this.getPrivateKey(i), l = nN(o, s);
      return this.setSymKey(l, a);
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const a = s || iN(i);
      return await this.keychain.set(a, i), a;
    }, this.deleteKeyPair = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.deleteSymKey = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.encode = async (i, s, a) => {
      this.isInitialized();
      const o = Cw(a), l = Cc(s);
      if (zm(o)) {
        const g = o.senderPublicKey, m = o.receiverPublicKey;
        i = await this.generateSharedKey(g, m);
      }
      const u = this.getSymKey(i), { type: h, senderPublicKey: f } = o;
      return oN({ type: h, symKey: u, message: l, senderPublicKey: f });
    }, this.decode = async (i, s, a) => {
      this.isInitialized();
      const o = uN(s, a);
      if (zm(o)) {
        const l = o.receiverPublicKey, u = o.senderPublicKey;
        i = await this.generateSharedKey(l, u);
      }
      try {
        const l = this.getSymKey(i), u = aN({ symKey: l, encoded: s });
        return _l(u);
      } catch (l) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(l);
      }
    }, this.getPayloadType = (i) => {
      const s = Tu(i);
      return Pc(s.type);
    }, this.getPayloadSenderPublicKey = (i) => {
      const s = Tu(i);
      return s.senderPublicKey ? Zr(s.senderPublicKey, Wr) : void 0;
    }, this.core = e, this.logger = wt.generateChildLogger(r, this.name), this.keychain = n || new GL(this.core, this.logger);
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(fv);
    } catch {
      e = Jd(), await this.keychain.set(fv, e);
    }
    return yL(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class YL extends pT {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = OL, this.version = IL, this.initialized = !1, this.storagePrefix = qi, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, i) => {
      this.isInitialized();
      const s = lo(i);
      let a = this.messages.get(n);
      return typeof a > "u" && (a = {}), typeof a[s] < "u" || (a[s] = i, this.messages.set(n, a), await this.persist()), s;
    }, this.get = (n) => {
      this.isInitialized();
      let i = this.messages.get(n);
      return typeof i > "u" && (i = {}), i;
    }, this.has = (n, i) => {
      this.isInitialized();
      const s = this.get(n), a = lo(i);
      return typeof s[a] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = wt.generateChildLogger(e, this.name), this.core = r;
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Dw(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Tw(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class QL extends gT {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new En.EventEmitter(), this.name = CL, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = Ae.toMiliseconds(Ae.TEN_SECONDS * 2), this.needsTransportRestart = !1, this.publish = async (n, i, s) => {
      var a;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      try {
        const o = (s == null ? void 0 : s.ttl) || xL, l = Xd(s), u = (s == null ? void 0 : s.prompt) || !1, h = (s == null ? void 0 : s.tag) || 0, f = (s == null ? void 0 : s.id) || kw().toString(), g = { topic: n, message: i, opts: { ttl: o, relay: l, prompt: u, tag: h, id: f } }, m = setTimeout(() => this.queue.set(f, g), this.publishTimeout);
        try {
          await await La(this.rpcPublish(n, i, o, l, u, h, f), this.publishTimeout, `Failed to publish payload, please try again. id:${f} tag:${h}`), this.removeRequestFromQueue(f), this.relayer.events.emit(Pr.publish, g);
        } catch (w) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (a = s == null ? void 0 : s.internal) != null && a.throwOnFailedPublish)
            throw this.removeRequestFromQueue(f), w;
          return;
        } finally {
          clearTimeout(m);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      } catch (o) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o), o;
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.relayer = e, this.logger = wt.generateChildLogger(r, this.name), this.registerEventListeners();
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  rpcPublish(e, r, n, i, s, a, o) {
    var l, u, h, f;
    const g = { method: lu(i.protocol).publish, params: { topic: e, message: r, ttl: n, prompt: s, tag: a }, id: o };
    return Vr((l = g.params) == null ? void 0 : l.prompt) && ((u = g.params) == null || delete u.prompt), Vr((h = g.params) == null ? void 0 : h.tag) && ((f = g.params) == null || delete f.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: g }), this.relayer.request(g);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: n, opts: i } = e;
      await this.publish(r, n, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Mo.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(Pr.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(Pr.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class JL {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const n = this.get(e);
      this.exists(e, r) || this.map.set(e, [...n, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const n = this.get(e);
      if (!this.exists(e, r))
        return;
      const i = n.filter((s) => s !== r);
      if (!i.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var XL = Object.defineProperty, eM = Object.defineProperties, tM = Object.getOwnPropertyDescriptors, gv = Object.getOwnPropertySymbols, rM = Object.prototype.hasOwnProperty, nM = Object.prototype.propertyIsEnumerable, yv = (t, e, r) => e in t ? XL(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ha = (t, e) => {
  for (var r in e || (e = {}))
    rM.call(e, r) && yv(t, r, e[r]);
  if (gv)
    for (var r of gv(e))
      nM.call(e, r) && yv(t, r, e[r]);
  return t;
}, Zh = (t, e) => eM(t, tM(e));
class iM extends vT {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new JL(), this.events = new En.EventEmitter(), this.name = jL, this.version = kL, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = qi, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } });
      try {
        const s = Xd(i), a = { topic: n, relay: s };
        this.pending.set(n, a);
        const o = await this.rpcSubscribe(n, s);
        return this.onSubscribe(o, a), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } }), o;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i);
    }, this.isSubscribed = async (n) => {
      if (this.topics.includes(n))
        return !0;
      const i = `${this.pendingSubscriptionWatchLabel}_${n}`;
      return await new Promise((s, a) => {
        const o = new Ae.Watch();
        o.start(i);
        const l = setInterval(() => {
          !this.pending.has(n) && this.topics.includes(n) && (clearInterval(l), o.stop(i), s(!0)), o.elapsed(i) >= UL && (clearInterval(l), o.stop(i), a(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = wt.generateChildLogger(r, this.name), this.clientId = "";
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === r;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (i) => await this.unsubscribeById(e, i, r)));
  }
  async unsubscribeById(e, r, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    try {
      const i = Xd(n);
      await this.rpcUnsubscribe(e, r, i);
      const s = Gt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i;
    }
  }
  async rpcSubscribe(e, r) {
    const n = { method: lu(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      await await La(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Pr.connection_stalled);
    }
    return lo(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const r = e[0].relay, n = { method: lu(r.protocol).batchSubscribe, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await La(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(Pr.connection_stalled);
    }
  }
  rpcUnsubscribe(e, r, n) {
    const i = { method: lu(n.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i }), this.relayer.request(i);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, Zh(ha({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, ha({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, n) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r));
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, ha({}, r)), this.topicMap.set(r.topic, e), this.events.emit(xn.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: n } = he("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(xn.deleted, Zh(ha({}, n), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(xn.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(n);
      }
    }
    this.events.emit(xn.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: r } = he("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const r = await this.rpcBatchSubscribe(e);
    Nc(r) && this.onBatchSubscribe(r.map((n, i) => Zh(ha({}, e[i]), { id: n })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Mo.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(Pr.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(Pr.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(xn.created, async (e) => {
      const r = xn.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(xn.deleted, async (e) => {
      const r = xn.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
}
var sM = Object.defineProperty, mv = Object.getOwnPropertySymbols, oM = Object.prototype.hasOwnProperty, aM = Object.prototype.propertyIsEnumerable, vv = (t, e, r) => e in t ? sM(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, cM = (t, e) => {
  for (var r in e || (e = {}))
    oM.call(e, r) && vv(t, r, e[r]);
  if (mv)
    for (var r of mv(e))
      aM.call(e, r) && vv(t, r, e[r]);
  return t;
};
class uM extends yT {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new En.EventEmitter(), this.name = TL, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.request = async (r) => {
      this.logger.debug("Publishing Request Payload");
      const n = r.id, i = this.provider.request(r);
      this.requestsInFlight.set(n, { promise: i, request: r });
      try {
        return await this.toEstablishConnection(), await i;
      } catch (s) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(s), s;
      } finally {
        this.requestsInFlight.delete(n);
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r);
    }, this.onConnectHandler = () => {
      this.events.emit(Pr.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(Pr.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(vi.payload, this.onPayloadHandler), this.provider.on(vi.connect, this.onConnectHandler), this.provider.on(vi.disconnect, this.onDisconnectHandler), this.provider.on(vi.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? wt.generateChildLogger(e.logger, this.name) : wt.pino(wt.getDefaultLoggerOptions({ level: e.logger || DL })), this.messages = new YL(this.logger, e.core), this.subscriber = new iM(this, this.logger), this.publisher = new QL(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Jw, this.projectId = e.projectId, this.bundleId = gN(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pv}...`), await this.restartTransport(pv);
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, AL);
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, r, n) {
    this.isInitialized(), await this.publisher.publish(e, r, n), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now() });
  }
  async subscribe(e, r) {
    var n;
    this.isInitialized();
    let i = ((n = this.subscriber.topicMap.get(e)) == null ? void 0 : n[0]) || "";
    if (i)
      return i;
    let s;
    const a = (o) => {
      o.topic === e && (this.subscriber.off(xn.created, a), s());
    };
    return await Promise.all([new Promise((o) => {
      s = o, this.subscriber.on(xn.created, a);
    }), new Promise(async (o) => {
      i = await this.subscriber.subscribe(e, r), o();
    })]), i;
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportClose() {
    this.requestsInFlight.size > 0 && (this.logger.debug("Waiting for all in-flight requests to finish before closing transport..."), this.requestsInFlight.forEach(async (e) => {
      await e.promise;
    })), this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await La(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
      try {
        await Promise.all([new Promise((r) => {
          if (!this.initialized)
            return r();
          this.subscriber.once(xn.resubscribed, () => {
            r();
          });
        }), new Promise(async (r, n) => {
          try {
            await La(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (i) {
            n(i);
            return;
          }
          r();
        })]);
      } catch (r) {
        this.logger.error(r);
        const n = r;
        if (!this.isConnectionStalled(n.message))
          throw r;
        this.provider.events.emit(vi.disconnect);
      } finally {
        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Xm())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new jA(new FA(_N({ sdkVersion: NL, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: n } = e;
    await this.messages.set(r, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: n } = e;
    if (!n || n.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isSubscribed(r))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const i = this.messages.has(r, n);
    return i && this.logger.debug(`Ignoring duplicate message: ${n}`), i;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), Pp(e)) {
      if (!e.method.endsWith(PL))
        return;
      const r = e.params, { topic: n, message: i, publishedAt: s } = r.data, a = { topic: n, message: i, publishedAt: s };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(cM({ type: "event", event: r.id }, a)), this.events.emit(r.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else
      Dl(e) && this.events.emit(Pr.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(Pr.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = Dp(e.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off(vi.payload, this.onPayloadHandler), this.provider.off(vi.connect, this.onConnectHandler), this.provider.off(vi.disconnect, this.onDisconnectHandler), this.provider.off(vi.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(Pr.connection_stalled, () => {
      this.restartTransport().catch((r) => this.logger.error(r));
    });
    let e = await Xm();
    gA(async (r) => {
      this.initialized && e !== r && (e = r, r ? await this.restartTransport().catch((n) => this.logger.error(n)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((n) => this.logger.error(n))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(Pr.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, Ae.toMiliseconds(RL)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const r = setInterval(() => {
            this.connected && (clearInterval(r), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
}
var lM = Object.defineProperty, bv = Object.getOwnPropertySymbols, hM = Object.prototype.hasOwnProperty, dM = Object.prototype.propertyIsEnumerable, wv = (t, e, r) => e in t ? lM(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, _v = (t, e) => {
  for (var r in e || (e = {}))
    hM.call(e, r) && wv(t, r, e[r]);
  if (bv)
    for (var r of bv(e))
      dM.call(e, r) && wv(t, r, e[r]);
  return t;
};
class Pl extends mT {
  constructor(e, r, n, i = qi, s = void 0) {
    super(e, r, n, i), this.core = e, this.logger = r, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = LL, this.cached = [], this.initialized = !1, this.storagePrefix = qi, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a) => {
        this.getKey && a !== null && !Vr(a) ? this.map.set(this.getKey(a), a) : HN(a) ? this.map.set(a.id, a) : WN(a) && this.map.set(a.topic, a);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (a, o) => {
      this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a, value: o }), this.map.set(a, o), await this.persist());
    }, this.get = (a) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a }), this.getData(a)), this.getAll = (a) => (this.isInitialized(), a ? this.values.filter((o) => Object.keys(a).every((l) => zA(o[l], a[l]))) : this.values), this.update = async (a, o) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a, update: o });
      const l = _v(_v({}, this.getData(a)), o);
      this.map.set(a, l), await this.persist();
    }, this.delete = async (a, o) => {
      this.isInitialized(), this.map.has(a) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a, reason: o }), this.map.delete(a), await this.persist());
    }, this.logger = wt.generateChildLogger(r, this.name), this.storagePrefix = i, this.getKey = s;
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      const { message: n } = he("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: r } = he("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class fM {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = $L, this.version = FL, this.events = new fp(), this.initialized = !1, this.storagePrefix = qi, this.ignoredPayloadTypes = [$s], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async () => {
      this.isInitialized();
      const n = Jd(), i = await this.core.crypto.setSymKey(n), s = dn(Ae.FIVE_MINUTES), a = { protocol: Qw }, o = { topic: i, expiry: s, relay: a, active: !1 }, l = kN({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: n, relay: a, expiryTimestamp: s });
      return await this.pairings.set(i, o), await this.core.relayer.subscribe(i), this.core.expirer.set(i, s), { topic: i, uri: l };
    }, this.pair = async (n) => {
      this.isInitialized(), this.isValidPair(n);
      const { topic: i, symKey: s, relay: a, expiryTimestamp: o } = Gm(n.uri);
      let l;
      if (this.pairings.keys.includes(i) && (l = this.pairings.get(i), l.active))
        throw new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
      const u = o || dn(Ae.FIVE_MINUTES), h = { topic: i, relay: a, expiry: u, active: !1 };
      return await this.pairings.set(i, h), this.core.expirer.set(i, u), n.activatePairing && await this.activate({ topic: i }), this.events.emit(va.create, h), this.core.crypto.keychain.has(i) || (await this.core.crypto.setSymKey(s, i), await this.core.relayer.subscribe(i, { relay: a })), h;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const i = dn(Ae.THIRTY_DAYS);
      await this.pairings.update(n, { active: !0, expiry: i }), this.core.expirer.set(n, i);
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: i } = n;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}), { done: a, resolve: o, reject: l } = Js();
        this.events.once(Wt("pairing_ping", s), ({ error: u }) => {
          u ? l(u) : o();
        }), await a();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: i }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: i });
    }, this.updateMetadata = async ({ topic: n, metadata: i }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: i });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: i } = n;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Gt("USER_DISCONNECTED")), await this.deletePairing(i));
    }, this.sendRequest = async (n, i, s) => {
      const a = ho(i, s), o = await this.core.crypto.encode(n, a), l = la[i].req;
      return this.core.history.set(n, a), this.core.relayer.publish(n, o, l), a.id;
    }, this.sendResult = async (n, i, s) => {
      const a = Dp(n, s), o = await this.core.crypto.encode(i, a), l = await this.core.history.get(i, n), u = la[l.request.method].res;
      await this.core.relayer.publish(i, o, u), await this.core.history.resolve(a);
    }, this.sendError = async (n, i, s) => {
      const a = Tp(n, s), o = await this.core.crypto.encode(i, a), l = await this.core.history.get(i, n), u = la[l.request.method] ? la[l.request.method].res : la.unregistered_method.res;
      await this.core.relayer.publish(i, o, u), await this.core.history.resolve(a);
    }, this.deletePairing = async (n, i) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Gt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((i) => Li(i.expiry));
      await Promise.all(n.map((i) => this.deletePairing(i.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: i, payload: s } = n;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s);
      }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: i, payload: s } = n, a = (await this.core.history.get(i, s.id)).request.method;
      switch (a) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(a);
      }
    }, this.onPairingPingRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(s, n, !0), this.events.emit(va.ping, { id: s, topic: n });
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onPairingPingResponse = (n, i) => {
      const { id: s } = i;
      setTimeout(() => {
        Ei(i) ? this.events.emit(Wt("pairing_ping", s), {}) : Dn(i) && this.events.emit(Wt("pairing_ping", s), { error: i.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(va.delete, { id: s, topic: n });
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodRequest = async (n, i) => {
      const { id: s, method: a } = i;
      try {
        if (this.registeredMethods.includes(a))
          return;
        const o = Gt("WC_METHOD_UNSUPPORTED", a);
        await this.sendError(s, n, o), this.logger.error(o);
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Gt("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n) => {
      var i;
      if (!rn(n)) {
        const { message: a } = he("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw new Error(a);
      }
      if (!BN(n.uri)) {
        const { message: a } = he("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw new Error(a);
      }
      const s = Gm(n.uri);
      if (!((i = s == null ? void 0 : s.relay) != null && i.protocol)) {
        const { message: a } = he("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(a);
      }
      if (!(s != null && s.symKey)) {
        const { message: a } = he("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(a);
      }
      if (s != null && s.expiryTimestamp && Ae.toMiliseconds(s == null ? void 0 : s.expiryTimestamp) < Date.now()) {
        const { message: a } = he("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }, this.isValidPing = async (n) => {
      if (!rn(n)) {
        const { message: s } = he("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidDisconnect = async (n) => {
      if (!rn(n)) {
        const { message: s } = he("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidPairingTopic = async (n) => {
      if (!ur(n, !1)) {
        const { message: i } = he("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(i);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: i } = he("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(i);
      }
      if (Li(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: i } = he("EXPIRED", `pairing topic: ${n}`);
        throw new Error(i);
      }
    }, this.core = e, this.logger = wt.generateChildLogger(r, this.name), this.pairings = new Pl(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(Pr.message, async (e) => {
      const { topic: r, message: n } = e;
      if (!this.pairings.keys.includes(r) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n)))
        return;
      const i = await this.core.crypto.decode(r, n);
      try {
        Pp(i) ? (this.core.history.set(r, i), this.onRelayEventRequest({ topic: r, payload: i })) : Dl(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({ topic: r, payload: i }), this.core.history.delete(r, i.id));
      } catch (s) {
        this.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(vn.expired, async (e) => {
      const { topic: r } = Rw(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(va.expire, { topic: r }));
    });
  }
}
class pM extends fT {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new En.EventEmitter(), this.name = qL, this.version = zL, this.cached = [], this.initialized = !1, this.storagePrefix = qi, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, i, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: i, chainId: s }), this.records.has(i.id))
        return;
      const a = { id: i.id, topic: n, request: { method: i.method, params: i.params || null }, chainId: s, expiry: dn(Ae.THIRTY_DAYS) };
      this.records.set(a.id, a), this.events.emit(Zn.created, a);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id))
        return;
      const i = await this.getRecord(n.id);
      typeof i.response > "u" && (i.response = Dn(n) ? { error: n.error } : { result: n.result }, this.records.set(i.id, i), this.events.emit(Zn.updated, i));
    }, this.get = async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: i }), await this.getRecord(i)), this.delete = (n, i) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i }), this.values.forEach((s) => {
        if (s.topic === n) {
          if (typeof i < "u" && s.id !== i)
            return;
          this.records.delete(s.id), this.events.emit(Zn.deleted, s);
        }
      });
    }, this.exists = async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = wt.generateChildLogger(r, this.name);
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u")
        return;
      const n = { topic: r.topic, request: ho(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: n } = he("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Zn.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: r } = he("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Zn.created, (e) => {
      const r = Zn.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Zn.updated, (e) => {
      const r = Zn.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Zn.deleted, (e) => {
      const r = Zn.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.core.heartbeat.on(Mo.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        Ae.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class gM extends bT {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new En.EventEmitter(), this.name = VL, this.version = KL, this.cached = [], this.initialized = !1, this.storagePrefix = qi, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const i = this.formatTarget(n);
        return typeof this.getExpiration(i) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, i) => {
      this.isInitialized();
      const s = this.formatTarget(n), a = { target: s, expiry: i };
      this.expirations.set(s, a), this.checkExpiry(s, a), this.events.emit(vn.created, { target: s, expiration: a });
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.formatTarget(n);
      return this.getExpiration(i);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const i = this.formatTarget(n), s = this.getExpiration(i);
        this.expirations.delete(i), this.events.emit(vn.deleted, { target: i, expiration: s });
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = wt.generateChildLogger(r, this.name);
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return EN(e);
    if (typeof e == "number")
      return SN(e);
    const { message: r } = he("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(vn.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: r } = he("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: n } = he("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: n } = r;
    Ae.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(vn.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Mo.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(vn.created, (e) => {
      const r = vn.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(vn.expired, (e) => {
      const r = vn.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(vn.deleted, (e) => {
      const r = vn.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class yM extends wT {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.name = Gh, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (n) => {
      if (this.verifyDisabled || Uo() || !$o())
        return;
      const i = this.getVerifyUrl(n == null ? void 0 : n.verifyUrl);
      this.verifyUrl !== i && this.removeIframe(), this.verifyUrl = i;
      try {
        await this.createIframe();
      } catch (s) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = rf;
        try {
          await this.createIframe();
        } catch (s) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s), this.verifyDisabled = !0;
        }
      }
    }, this.register = async (n) => {
      this.initialized ? this.sendPost(n.attestationId) : (this.addToQueue(n.attestationId), await this.init());
    }, this.resolve = async (n) => {
      if (this.isDevEnv)
        return "";
      const i = this.getVerifyUrl(n == null ? void 0 : n.verifyUrl);
      let s;
      try {
        s = await this.fetchAttestation(n.attestationId, i);
      } catch (a) {
        this.logger.info(`failed to resolve attestation: ${n.attestationId} from url: ${i}`), this.logger.info(a), s = await this.fetchAttestation(n.attestationId, rf);
      }
      return s;
    }, this.fetchAttestation = async (n, i) => {
      this.logger.info(`resolving attestation: ${n} from url: ${i}`);
      const s = this.startAbortTimer(Ae.ONE_SECOND * 2), a = await fetch(`${i}/attestation/${n}`, { signal: this.abortController.signal });
      return clearTimeout(s), a.status === 200 ? await a.json() : void 0;
    }, this.addToQueue = (n) => {
      this.queue.push(n);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((n) => this.sendPost(n)), this.queue = []);
    }, this.sendPost = (n) => {
      var i;
      try {
        if (!this.iframe)
          return;
        (i = this.iframe.contentWindow) == null || i.postMessage(n, "*"), this.logger.info(`postMessage sent: ${n} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let n;
      const i = (s) => {
        s.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", i), n());
      };
      await Promise.race([new Promise((s) => {
        if (document.getElementById(Gh))
          return s();
        window.addEventListener("message", i);
        const a = document.createElement("iframe");
        a.id = Gh, a.src = `${this.verifyUrl}/${this.projectId}`, a.style.display = "none", document.body.append(a), this.iframe = a, n = s;
      }), new Promise((s, a) => setTimeout(() => {
        window.removeEventListener("message", i), a("verify iframe load timeout");
      }, Ae.toMiliseconds(Ae.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);
    }, this.getVerifyUrl = (n) => {
      let i = n || io;
      return BL.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${io}`), i = io), i;
    }, this.logger = wt.generateChildLogger(r, this.name), this.verifyUrl = io, this.abortController = new AbortController(), this.isDevEnv = Op() && process.env.IS_VITEST;
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), Ae.toMiliseconds(e));
  }
}
class mM extends _T {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.context = HL, this.registerDeviceToken = async (n) => {
      const { clientId: i, token: s, notificationType: a, enableEncrypted: o = !1 } = n, l = `${WL}/${this.projectId}/clients`;
      await HA(l, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i, type: a, token: s, always_raw: o }) });
    }, this.logger = wt.generateChildLogger(r, this.context);
  }
}
var vM = Object.defineProperty, Ev = Object.getOwnPropertySymbols, bM = Object.prototype.hasOwnProperty, wM = Object.prototype.propertyIsEnumerable, Sv = (t, e, r) => e in t ? vM(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ov = (t, e) => {
  for (var r in e || (e = {}))
    bM.call(e, r) && Sv(t, r, e[r]);
  if (Ev)
    for (var r of Ev(e))
      wM.call(e, r) && Sv(t, r, e[r]);
  return t;
};
class Np extends dT {
  constructor(e) {
    super(e), this.protocol = Yw, this.version = mL, this.name = Rp, this.events = new En.EventEmitter(), this.initialized = !1, this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Jw, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : wt.pino(wt.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || vL.logger }));
    this.logger = wt.generateChildLogger(r, this.name), this.heartbeat = new Mo.HeartBeat(), this.crypto = new ZL(this, this.logger, e == null ? void 0 : e.keychain), this.history = new pM(this, this.logger), this.expirer = new gM(this, this.logger), this.storage = e != null && e.storage ? e.storage : new TD(Ov(Ov({}, bL), e == null ? void 0 : e.storageOptions)), this.relayer = new uM({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new fM(this, this.logger), this.verify = new yM(this.projectId || "", this.logger), this.echoClient = new mM(this.projectId || "", this.logger);
  }
  static async init(e) {
    const r = new Np(e);
    await r.initialize();
    const n = await r.crypto.getClientId();
    return await r.storage.setItem(ML, n), r;
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const _M = Np, Xw = "wc", e_ = 2, t_ = "client", Ap = `${Xw}@${e_}:${t_}:`, Yh = { name: t_, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, Iv = "WALLETCONNECT_DEEPLINK_CHOICE", EM = "proposal", SM = "Proposal expired", OM = "session", Yc = Ae.SEVEN_DAYS, IM = "engine", bi = { wc_sessionPropose: { req: { ttl: Ae.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: Ae.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: Ae.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: Ae.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: Ae.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: Ae.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: Ae.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: Ae.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: Ae.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: Ae.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: Ae.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Qh = { min: Ae.FIVE_MINUTES, max: Ae.SEVEN_DAYS }, wi = { idle: "IDLE", active: "ACTIVE" }, xM = "request", CM = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var DM = Object.defineProperty, TM = Object.defineProperties, PM = Object.getOwnPropertyDescriptors, xv = Object.getOwnPropertySymbols, RM = Object.prototype.hasOwnProperty, NM = Object.prototype.propertyIsEnumerable, Cv = (t, e, r) => e in t ? DM(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, $r = (t, e) => {
  for (var r in e || (e = {}))
    RM.call(e, r) && Cv(t, r, e[r]);
  if (xv)
    for (var r of xv(e))
      NM.call(e, r) && Cv(t, r, e[r]);
  return t;
}, Gs = (t, e) => TM(t, PM(e));
class AM extends ST {
  constructor(e) {
    super(e), this.name = IM, this.events = new fp(), this.initialized = !1, this.ignoredPayloadTypes = [$s], this.requestQueue = { state: wi.idle, queue: [] }, this.sessionRequestQueue = { state: wi.idle, queue: [] }, this.requestQueueDelay = Ae.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(bi) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, Ae.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      await this.isInitialized();
      const n = Gs($r({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: a, sessionProperties: o, relays: l } = n;
      let u = i, h, f = !1;
      if (u && (f = this.client.core.pairing.pairings.get(u).active), !u || !f) {
        const { topic: b, uri: E } = await this.client.core.pairing.create();
        u = b, h = E;
      }
      const g = await this.client.core.crypto.generateKeyPair(), m = bi.wc_sessionPropose.req.ttl || Ae.FIVE_MINUTES, w = dn(m), S = $r({ requiredNamespaces: s, optionalNamespaces: a, relays: l ?? [{ protocol: Qw }], proposer: { publicKey: g, metadata: this.client.metadata }, expiryTimestamp: w }, o && { sessionProperties: o }), { reject: x, resolve: M, done: _ } = Js(m, SM);
      if (this.events.once(Wt("session_connect"), async ({ error: b, session: E }) => {
        if (b)
          x(b);
        else if (E) {
          E.self.publicKey = g;
          const y = Gs($r({}, E), { requiredNamespaces: S.requiredNamespaces, optionalNamespaces: S.optionalNamespaces });
          await this.client.session.set(E.topic, y), await this.setExpiry(E.topic, E.expiry), u && await this.client.core.pairing.updateMetadata({ topic: u, metadata: E.peer.metadata }), M(y);
        }
      }), !u) {
        const { message: b } = he("NO_MATCHING_KEY", `connect() pairing topic: ${u}`);
        throw new Error(b);
      }
      const I = await this.sendRequest({ topic: u, method: "wc_sessionPropose", params: S, throwOnFailedPublish: !0 });
      return await this.setProposal(I, $r({ id: I }, S)), { uri: h, approval: _ };
    }, this.pair = async (r) => (await this.isInitialized(), await this.client.core.pairing.pair(r)), this.approve = async (r) => {
      await this.isInitialized(), await this.isValidApprove(r);
      const { id: n, relayProtocol: i, namespaces: s, sessionProperties: a } = r, o = this.client.proposal.get(n);
      let { pairingTopic: l, proposer: u, requiredNamespaces: h, optionalNamespaces: f } = o;
      l = l || "";
      const g = await this.client.core.crypto.generateKeyPair(), m = u.publicKey, w = await this.client.core.crypto.generateSharedKey(g, m);
      l && n && (await this.client.core.pairing.updateMetadata({ topic: l, metadata: u.metadata }), await this.sendResult({ id: n, topic: l, result: { relay: { protocol: i ?? "irn" }, responderPublicKey: g } }), await this.client.proposal.delete(n, Gt("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l }));
      const S = $r({ relay: { protocol: i ?? "irn" }, namespaces: s, pairingTopic: l, controller: { publicKey: g, metadata: this.client.metadata }, expiry: dn(Yc) }, a && { sessionProperties: a });
      await this.client.core.relayer.subscribe(w);
      const x = Gs($r({}, S), { topic: w, requiredNamespaces: h, optionalNamespaces: f, pairingTopic: l, acknowledged: !1, self: S.controller, peer: { publicKey: u.publicKey, metadata: u.metadata }, controller: g });
      await this.client.session.set(w, x);
      try {
        await this.sendRequest({ topic: w, method: "wc_sessionSettle", params: S, throwOnFailedPublish: !0 });
      } catch (M) {
        throw this.client.logger.error(M), this.client.session.delete(w, Gt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(w), M;
      }
      return await this.setExpiry(w, dn(Yc)), { topic: w, acknowledged: () => new Promise((M) => setTimeout(() => M(this.client.session.get(w)), 500)) };
    }, this.reject = async (r) => {
      await this.isInitialized(), await this.isValidReject(r);
      const { id: n, reason: i } = r, { pairingTopic: s } = this.client.proposal.get(n);
      s && (await this.sendError(n, s, i), await this.client.proposal.delete(n, Gt("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      await this.isInitialized(), await this.isValidUpdate(r);
      const { topic: n, namespaces: i } = r, s = await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: i } }), { done: a, resolve: o, reject: l } = Js();
      return this.events.once(Wt("session_update", s), ({ error: u }) => {
        u ? l(u) : o();
      }), await this.client.session.update(n, { namespaces: i }), { acknowledged: a };
    }, this.extend = async (r) => {
      await this.isInitialized(), await this.isValidExtend(r);
      const { topic: n } = r, i = await this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {} }), { done: s, resolve: a, reject: o } = Js();
      return this.events.once(Wt("session_extend", i), ({ error: l }) => {
        l ? o(l) : a();
      }), await this.setExpiry(n, dn(Yc)), { acknowledged: s };
    }, this.request = async (r) => {
      await this.isInitialized(), await this.isValidRequest(r);
      const { chainId: n, request: i, topic: s, expiry: a = bi.wc_sessionRequest.req.ttl } = r, o = Cp(), { done: l, resolve: u, reject: h } = Js(a, "Request expired. Please try again.");
      return this.events.once(Wt("session_request", o), ({ error: f, result: g }) => {
        f ? h(f) : u(g);
      }), await Promise.all([new Promise(async (f) => {
        await this.sendRequest({ clientRpcId: o, topic: s, method: "wc_sessionRequest", params: { request: Gs($r({}, i), { expiryTimestamp: dn(a) }), chainId: n }, expiry: a, throwOnFailedPublish: !0 }).catch((g) => h(g)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: o }), f();
      }), new Promise(async (f) => {
        const g = await IN(this.client.core.storage, Iv);
        ON({ id: o, topic: s, wcDeepLink: g }), f();
      }), l()]).then((f) => f[2]);
    }, this.respond = async (r) => {
      await this.isInitialized(), await this.isValidRespond(r);
      const { topic: n, response: i } = r, { id: s } = i;
      Ei(i) ? await this.sendResult({ id: s, topic: n, result: i.result, throwOnFailedPublish: !0 }) : Dn(i) && await this.sendError(s, n, i.error), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      await this.isInitialized(), await this.isValidPing(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const i = await this.sendRequest({ topic: n, method: "wc_sessionPing", params: {} }), { done: s, resolve: a, reject: o } = Js();
        this.events.once(Wt("session_ping", i), ({ error: l }) => {
          l ? o(l) : a();
        }), await s();
      } else
        this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (r) => {
      await this.isInitialized(), await this.isValidEmit(r);
      const { topic: n, event: i, chainId: s } = r;
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: i, chainId: s } });
    }, this.disconnect = async (r) => {
      await this.isInitialized(), await this.isValidDisconnect(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n))
        await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: Gt("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: n, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(n))
        await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: i } = he("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(i);
      }
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((n) => VN(n, r))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic)
        try {
          const n = this.client.core.pairing.pairings.get(r.pairingTopic), i = this.client.core.pairing.pairings.getAll().filter((s) => {
            var a, o;
            return ((a = s.peerMetadata) == null ? void 0 : a.url) && ((o = s.peerMetadata) == null ? void 0 : o.url) === r.peer.metadata.url && s.topic && s.topic !== n.topic;
          });
          if (i.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (n) {
          this.client.logger.error(n);
        }
    }, this.deleteSession = async (r) => {
      const { topic: n, expirerHasDeleted: i = !1, emitEvent: s = !0, id: a = 0 } = r, { self: o } = this.client.session.get(n);
      await this.client.core.relayer.unsubscribe(n), await this.client.session.delete(n, Gt("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(o.publicKey) && await this.client.core.crypto.deleteKeyPair(o.publicKey), this.client.core.crypto.keychain.has(n) && await this.client.core.crypto.deleteSymKey(n), i || this.client.core.expirer.del(n), this.client.core.storage.removeItem(Iv).catch((l) => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach((l) => {
        l.topic === n && this.deletePendingSessionRequest(l.id, Gt("USER_DISCONNECTED"));
      }), s && this.client.events.emit("session_delete", { id: a, topic: n });
    }, this.deleteProposal = async (r, n) => {
      await Promise.all([this.client.proposal.delete(r, Gt("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.deletePendingSessionRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== r), i && (this.sessionRequestQueue.state = wi.idle, this.client.events.emit("session_request_expire", { id: r }));
    }, this.setExpiry = async (r, n) => {
      this.client.session.keys.includes(r) && await this.client.session.update(r, { expiry: n }), this.client.core.expirer.set(r, n);
    }, this.setProposal = async (r, n) => {
      await this.client.proposal.set(r, n), this.client.core.expirer.set(r, dn(bi.wc_sessionPropose.req.ttl));
    }, this.setPendingSessionRequest = async (r) => {
      const { id: n, topic: i, params: s, verifyContext: a } = r, o = s.request.expiryTimestamp || dn(bi.wc_sessionRequest.req.ttl);
      await this.client.pendingRequest.set(n, { id: n, topic: i, params: s, verifyContext: a }), o && this.client.core.expirer.set(n, o);
    }, this.sendRequest = async (r) => {
      const { topic: n, method: i, params: s, expiry: a, relayRpcId: o, clientRpcId: l, throwOnFailedPublish: u } = r, h = ho(i, s, l);
      if ($o() && CM.includes(i)) {
        const m = lo(JSON.stringify(h));
        this.client.core.verify.register({ attestationId: m });
      }
      const f = await this.client.core.crypto.encode(n, h), g = bi[i].req;
      return a && (g.ttl = a), o && (g.id = o), this.client.core.history.set(n, h), u ? (g.internal = Gs($r({}, g.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, f, g)) : this.client.core.relayer.publish(n, f, g).catch((m) => this.client.logger.error(m)), h.id;
    }, this.sendResult = async (r) => {
      const { id: n, topic: i, result: s, throwOnFailedPublish: a } = r, o = Dp(n, s), l = await this.client.core.crypto.encode(i, o), u = await this.client.core.history.get(i, n), h = bi[u.request.method].res;
      a ? (h.internal = Gs($r({}, h.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, l, h)) : this.client.core.relayer.publish(i, l, h).catch((f) => this.client.logger.error(f)), await this.client.core.history.resolve(o);
    }, this.sendError = async (r, n, i) => {
      const s = Tp(r, i), a = await this.client.core.crypto.encode(n, s), o = await this.client.core.history.get(n, r), l = bi[o.request.method].res;
      this.client.core.relayer.publish(n, a, l), await this.client.core.history.resolve(s);
    }, this.cleanup = async () => {
      const r = [], n = [];
      this.client.session.getAll().forEach((i) => {
        let s = !1;
        Li(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && r.push(i.topic);
      }), this.client.proposal.getAll().forEach((i) => {
        Li(i.expiryTimestamp) && n.push(i.id);
      }), await Promise.all([...r.map((i) => this.deleteSession({ topic: i })), ...n.map((i) => this.deleteProposal(i))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === wi.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = wi.active;
        const r = this.requestQueue.queue.shift();
        if (r)
          try {
            this.processRequest(r), await new Promise((n) => setTimeout(n, 300));
          } catch (n) {
            this.client.logger.warn(n);
          }
      }
      this.requestQueue.state = wi.idle;
    }, this.processRequest = (r) => {
      const { topic: n, payload: i } = r, s = i.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(n, i);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(n, i);
        case "wc_sessionPing":
          return this.onSessionPingRequest(n, i);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequest(n, i);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(n, i);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: n, payload: i } = r, s = (await this.client.core.history.get(n, i.id)).request.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, i);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, i);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: n } = r, { message: i } = he("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i);
    }, this.onSessionProposeRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        this.isValidConnect($r({}, n.params));
        const a = i.expiryTimestamp || dn(bi.wc_sessionPropose.req.ttl), o = $r({ id: s, pairingTopic: r, expiryTimestamp: a }, i);
        await this.setProposal(s, o);
        const l = lo(JSON.stringify(n)), u = await this.getVerifyContext(l, o.proposer.metadata);
        this.client.events.emit("session_proposal", { id: s, params: o, verifyContext: u });
      } catch (a) {
        await this.sendError(s, r, a), this.client.logger.error(a);
      }
    }, this.onSessionProposeResponse = async (r, n) => {
      const { id: i } = n;
      if (Ei(n)) {
        const { result: s } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: s });
        const a = this.client.proposal.get(i);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const o = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o });
        const l = s.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l });
        const u = await this.client.core.crypto.generateSharedKey(o, l);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: u });
        const h = await this.client.core.relayer.subscribe(u);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h }), await this.client.core.pairing.activate({ topic: r });
      } else
        Dn(n) && (await this.client.proposal.delete(i, Gt("USER_DISCONNECTED")), this.events.emit(Wt("session_connect"), { error: n.error }));
    }, this.onSessionSettleRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: a, controller: o, expiry: l, namespaces: u, sessionProperties: h, pairingTopic: f } = n.params, g = $r({ topic: r, relay: a, expiry: l, namespaces: u, acknowledged: !0, pairingTopic: f, requiredNamespaces: {}, optionalNamespaces: {}, controller: o.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o.publicKey, metadata: o.metadata } }, h && { sessionProperties: h });
        await this.sendResult({ id: n.id, topic: r, result: !0 }), this.events.emit(Wt("session_connect"), { session: g }), this.cleanupDuplicatePairings(g);
      } catch (a) {
        await this.sendError(i, r, a), this.client.logger.error(a);
      }
    }, this.onSessionSettleResponse = async (r, n) => {
      const { id: i } = n;
      Ei(n) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(Wt("session_approve", i), {})) : Dn(n) && (await this.client.session.delete(r, Gt("USER_DISCONNECTED")), this.events.emit(Wt("session_approve", i), { error: n.error }));
    }, this.onSessionUpdateRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        const a = `${r}_session_update`, o = Zc.get(a);
        if (o && this.isRequestOutOfSync(o, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidUpdate($r({ topic: r }, i)), await this.client.session.update(r, { namespaces: i.namespaces }), await this.sendResult({ id: s, topic: r, result: !0 }), this.client.events.emit("session_update", { id: s, topic: r, params: i }), Zc.set(a, s);
      } catch (a) {
        await this.sendError(s, r, a), this.client.logger.error(a);
      }
    }, this.isRequestOutOfSync = (r, n) => parseInt(n.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, n) => {
      const { id: i } = n;
      Ei(n) ? this.events.emit(Wt("session_update", i), {}) : Dn(n) && this.events.emit(Wt("session_update", i), { error: n.error });
    }, this.onSessionExtendRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, dn(Yc)), await this.sendResult({ id: i, topic: r, result: !0 }), this.client.events.emit("session_extend", { id: i, topic: r });
      } catch (s) {
        await this.sendError(i, r, s), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (r, n) => {
      const { id: i } = n;
      Ei(n) ? this.events.emit(Wt("session_extend", i), {}) : Dn(n) && this.events.emit(Wt("session_extend", i), { error: n.error });
    }, this.onSessionPingRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: i, topic: r, result: !0 }), this.client.events.emit("session_ping", { id: i, topic: r });
      } catch (s) {
        await this.sendError(i, r, s), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (r, n) => {
      const { id: i } = n;
      setTimeout(() => {
        Ei(n) ? this.events.emit(Wt("session_ping", i), {}) : Dn(n) && this.events.emit(Wt("session_ping", i), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidDisconnect({ topic: r, reason: n.params }), await Promise.all([new Promise((s) => {
          this.client.core.relayer.once(Pr.publish, async () => {
            s(await this.deleteSession({ topic: r, id: i }));
          });
        }), this.sendResult({ id: i, topic: r, result: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: r, error: Gt("USER_DISCONNECTED") })]);
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidRequest($r({ topic: r }, s));
        const a = lo(JSON.stringify(ho("wc_sessionRequest", s, i))), o = this.client.session.get(r), l = await this.getVerifyContext(a, o.peer.metadata), u = { id: i, topic: r, params: s, verifyContext: l };
        await this.setPendingSessionRequest(u), this.addSessionRequestToSessionRequestQueue(u), this.processSessionRequestQueue();
      } catch (a) {
        await this.sendError(i, r, a), this.client.logger.error(a);
      }
    }, this.onSessionRequestResponse = (r, n) => {
      const { id: i } = n;
      Ei(n) ? this.events.emit(Wt("session_request", i), { result: n.result }) : Dn(n) && this.events.emit(Wt("session_request", i), { error: n.error });
    }, this.onSessionEventRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        const a = `${r}_session_event_${s.event.name}`, o = Zc.get(a);
        if (o && this.isRequestOutOfSync(o, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return;
        }
        this.isValidEmit($r({ topic: r }, s)), this.client.events.emit("session_event", { id: i, topic: r, params: s }), Zc.set(a, i);
      } catch (a) {
        await this.sendError(i, r, a), this.client.logger.error(a);
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = wi.idle, this.processSessionRequestQueue();
      }, Ae.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: r, error: n }) => {
      const i = this.client.core.history.pending;
      i.length > 0 && i.filter((s) => s.topic === r && s.request.method === "wc_sessionRequest").forEach((s) => {
        this.events.emit(Wt("session_request", s.request.id), { error: n });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === wi.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = wi.active, this.client.events.emit("session_request", r);
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.onPairingCreated = (r) => {
      if (r.active)
        return;
      const n = this.client.proposal.getAll().find((i) => i.pairingTopic === r.topic);
      n && this.onSessionProposeRequest(r.topic, ho("wc_sessionPropose", { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties }, n.id));
    }, this.isValidConnect = async (r) => {
      if (!rn(r)) {
        const { message: l } = he("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(l);
      }
      const { pairingTopic: n, requiredNamespaces: i, optionalNamespaces: s, sessionProperties: a, relays: o } = r;
      if (Vr(n) || await this.isValidPairingTopic(n), !tA(o, !0)) {
        const { message: l } = he("MISSING_OR_INVALID", `connect() relays: ${o}`);
        throw new Error(l);
      }
      !Vr(i) && Pu(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !Vr(s) && Pu(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), Vr(a) || this.validateSessionProps(a, "sessionProperties");
    }, this.validateNamespaces = (r, n) => {
      const i = eA(r, "connect()", n);
      if (i)
        throw new Error(i.message);
    }, this.isValidApprove = async (r) => {
      if (!rn(r))
        throw new Error(he("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: n, namespaces: i, relayProtocol: s, sessionProperties: a } = r;
      await this.isValidProposalId(n);
      const o = this.client.proposal.get(n), l = Bh(i, "approve()");
      if (l)
        throw new Error(l.message);
      const u = Qm(o.requiredNamespaces, i, "approve()");
      if (u)
        throw new Error(u.message);
      if (!ur(s, !0)) {
        const { message: h } = he("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(h);
      }
      Vr(a) || this.validateSessionProps(a, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!rn(r)) {
        const { message: s } = he("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(s);
      }
      const { id: n, reason: i } = r;
      if (await this.isValidProposalId(n), !nA(i)) {
        const { message: s } = he("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!rn(r)) {
        const { message: u } = he("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(u);
      }
      const { relay: n, controller: i, namespaces: s, expiry: a } = r;
      if (!Aw(n)) {
        const { message: u } = he("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(u);
      }
      const o = GN(i, "onSessionSettleRequest()");
      if (o)
        throw new Error(o.message);
      const l = Bh(s, "onSessionSettleRequest()");
      if (l)
        throw new Error(l.message);
      if (Li(a)) {
        const { message: u } = he("EXPIRED", "onSessionSettleRequest()");
        throw new Error(u);
      }
    }, this.isValidUpdate = async (r) => {
      if (!rn(r)) {
        const { message: l } = he("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(l);
      }
      const { topic: n, namespaces: i } = r;
      await this.isValidSessionTopic(n);
      const s = this.client.session.get(n), a = Bh(i, "update()");
      if (a)
        throw new Error(a.message);
      const o = Qm(s.requiredNamespaces, i, "update()");
      if (o)
        throw new Error(o.message);
    }, this.isValidExtend = async (r) => {
      if (!rn(r)) {
        const { message: i } = he("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (r) => {
      if (!rn(r)) {
        const { message: l } = he("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(l);
      }
      const { topic: n, request: i, chainId: s, expiry: a } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!Ym(o, s)) {
        const { message: l } = he("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(l);
      }
      if (!iA(i)) {
        const { message: l } = he("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(l);
      }
      if (!aA(o, s, i.method)) {
        const { message: l } = he("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(l);
      }
      if (a && !hA(a, Qh)) {
        const { message: l } = he("MISSING_OR_INVALID", `request() expiry: ${a}. Expiry must be a number (in seconds) between ${Qh.min} and ${Qh.max}`);
        throw new Error(l);
      }
    }, this.isValidRespond = async (r) => {
      var n;
      if (!rn(r)) {
        const { message: a } = he("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(a);
      }
      const { topic: i, response: s } = r;
      try {
        await this.isValidSessionTopic(i);
      } catch (a) {
        throw (n = r == null ? void 0 : r.response) != null && n.id && this.cleanupAfterResponse(r), a;
      }
      if (!sA(s)) {
        const { message: a } = he("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
    }, this.isValidPing = async (r) => {
      if (!rn(r)) {
        const { message: i } = he("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (r) => {
      if (!rn(r)) {
        const { message: o } = he("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(o);
      }
      const { topic: n, event: i, chainId: s } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!Ym(a, s)) {
        const { message: o } = he("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(o);
      }
      if (!oA(i)) {
        const { message: o } = he("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(o);
      }
      if (!cA(a, s, i.name)) {
        const { message: o } = he("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(o);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!rn(r)) {
        const { message: i } = he("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.getVerifyContext = async (r, n) => {
      const i = { verified: { verifyUrl: n.verifyUrl || io, validation: "UNKNOWN", origin: n.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: r, verifyUrl: n.verifyUrl });
        s && (i.verified.origin = s.origin, i.verified.isScam = s.isScam, i.verified.validation = s.origin === new URL(n.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.info(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`), i;
    }, this.validateSessionProps = (r, n) => {
      Object.values(r).forEach((i) => {
        if (!ur(i, !1)) {
          const { message: s } = he("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: e } = he("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(Pr.message, async (e) => {
      const { topic: r, message: n } = e;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(n)))
        return;
      const i = await this.client.core.crypto.decode(r, n);
      try {
        Pp(i) ? (this.client.core.history.set(r, i), this.onRelayEventRequest({ topic: r, payload: i })) : Dl(i) ? (await this.client.core.history.resolve(i), await this.onRelayEventResponse({ topic: r, payload: i }), this.client.core.history.delete(r, i.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: i });
      } catch (s) {
        this.client.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(vn.expired, async (e) => {
      const { topic: r, id: n } = Rw(e.target);
      if (n && this.client.pendingRequest.keys.includes(n))
        return await this.deletePendingSessionRequest(n, he("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: r })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(va.create, (e) => this.onPairingCreated(e));
  }
  isValidPairingTopic(e) {
    if (!ur(e, !1)) {
      const { message: r } = he("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = he("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Li(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = he("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!ur(e, !1)) {
      const { message: r } = he("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: r } = he("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Li(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: r } = he("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: r } = he("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (ur(e, !1)) {
      const { message: r } = he("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = he("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!rA(e)) {
      const { message: r } = he("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = he("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Li(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: r } = he("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
}
class LM extends Pl {
  constructor(e, r) {
    super(e, r, EM, Ap), this.core = e, this.logger = r;
  }
}
class MM extends Pl {
  constructor(e, r) {
    super(e, r, OM, Ap), this.core = e, this.logger = r;
  }
}
class jM extends Pl {
  constructor(e, r) {
    super(e, r, xM, Ap, (n) => n.id), this.core = e, this.logger = r;
  }
}
class Lp extends ET {
  constructor(e) {
    super(e), this.protocol = Xw, this.version = e_, this.name = Yh.name, this.events = new En.EventEmitter(), this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.name = (e == null ? void 0 : e.name) || Yh.name, this.metadata = (e == null ? void 0 : e.metadata) || mN();
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : wt.pino(wt.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || Yh.logger }));
    this.core = (e == null ? void 0 : e.core) || new _M(e), this.logger = wt.generateChildLogger(r, this.name), this.session = new MM(this.core, this.logger), this.proposal = new LM(this.core, this.logger), this.pendingRequest = new jM(this.core, this.logger), this.engine = new AM(this);
  }
  static async init(e) {
    const r = new Lp(e);
    return await r.initialize(), r;
  }
  get context() {
    return wt.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
var kM = Object.defineProperty, UM = Object.defineProperties, $M = Object.getOwnPropertyDescriptors, Dv = Object.getOwnPropertySymbols, FM = Object.prototype.hasOwnProperty, qM = Object.prototype.propertyIsEnumerable, Tv = (t, e, r) => e in t ? kM(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, zM = (t, e) => {
  for (var r in e || (e = {}))
    FM.call(e, r) && Tv(t, r, e[r]);
  if (Dv)
    for (var r of Dv(e))
      qM.call(e, r) && Tv(t, r, e[r]);
  return t;
}, VM = (t, e) => UM(t, $M(e)), Mp = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, $t = (t, e, r) => (Mp(t, e, "read from private field"), r ? r.call(t) : e.get(t)), ds = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, Au = (t, e, r, n) => (Mp(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), Ir = (t, e, r) => (Mp(t, e, "access private method"), r), ps, Xs, ba, ar, nf, r_, xr, qr, sf, Pv;
let KM = class {
  constructor(t) {
    ds(this, nf), ds(this, xr), ds(this, sf), ds(this, ps, void 0), ds(this, Xs, void 0), ds(this, ba, void 0), ds(this, ar, void 0), Au(this, ps, t), Au(this, Xs, Ir(this, nf, r_).call(this)), Ir(this, xr, qr).call(this);
  }
  async connect(t) {
    const { requiredNamespaces: e, optionalNamespaces: r } = t;
    return new Promise(async (n, i) => {
      await Ir(this, xr, qr).call(this);
      const s = $t(this, Xs).subscribeModal((l) => {
        l.open || (s(), i(new Error("Modal closed")));
      }), { uri: a, approval: o } = await $t(this, ar).connect(t);
      if (a) {
        const l = /* @__PURE__ */ new Set();
        e && Object.values(e).forEach(({ chains: u }) => {
          u && u.forEach((h) => l.add(h));
        }), r && Object.values(r).forEach(({ chains: u }) => {
          u && u.forEach((h) => l.add(h));
        }), await $t(this, Xs).openModal({ uri: a, chains: Array.from(l) });
      }
      try {
        const l = await o();
        n(l);
      } catch (l) {
        i(l);
      } finally {
        s(), $t(this, Xs).closeModal();
      }
    });
  }
  async disconnect(t) {
    await Ir(this, xr, qr).call(this), await $t(this, ar).disconnect(t);
  }
  async request(t) {
    return await Ir(this, xr, qr).call(this), await $t(this, ar).request(t);
  }
  async getSessions() {
    return await Ir(this, xr, qr).call(this), $t(this, ar).session.getAll();
  }
  async getSession() {
    return await Ir(this, xr, qr).call(this), $t(this, ar).session.getAll().at(-1);
  }
  async onSessionEvent(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).on("session_event", t);
  }
  async offSessionEvent(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).off("session_event", t);
  }
  async onSessionUpdate(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).on("session_update", t);
  }
  async offSessionUpdate(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).off("session_update", t);
  }
  async onSessionDelete(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).on("session_delete", t);
  }
  async offSessionDelete(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).off("session_delete", t);
  }
  async onSessionExpire(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).on("session_expire", t);
  }
  async offSessionExpire(t) {
    await Ir(this, xr, qr).call(this), $t(this, ar).off("session_expire", t);
  }
};
ps = /* @__PURE__ */ new WeakMap(), Xs = /* @__PURE__ */ new WeakMap(), ba = /* @__PURE__ */ new WeakMap(), ar = /* @__PURE__ */ new WeakMap(), nf = /* @__PURE__ */ new WeakSet(), r_ = function() {
  const { modalOptions: t, projectId: e } = $t(this, ps);
  return new BC(VM(zM({}, t), { projectId: e }));
}, xr = /* @__PURE__ */ new WeakSet(), qr = async function() {
  return $t(this, ar) ? !0 : (!$t(this, ba) && typeof window < "u" && Au(this, ba, Ir(this, sf, Pv).call(this)), $t(this, ba));
}, sf = /* @__PURE__ */ new WeakSet(), Pv = async function() {
  Au(this, ar, await Lp.init({ metadata: $t(this, ps).metadata, projectId: $t(this, ps).projectId, relayUrl: $t(this, ps).relayUrl }));
  const t = await $t(this, ar).core.crypto.getClientId();
  try {
    localStorage.setItem("WCM_WALLETCONNECT_CLIENT_ID", t);
  } catch {
    console.info("Unable to set client id");
  }
};
const BM = [
  "decrypt",
  "disconnect",
  "getSelectedAccount",
  "getBalance",
  "getRecords",
  "requestCreateEvent",
  "getEvent",
  "getEvents",
  "createSharedState",
  "importSharedState",
  "requestSignature"
], n_ = ["aleo:1"], HM = ["chainChanged", "accountSelected", "selectedAccountSynced", "sharedAccountSynced"], WM = "f0aaeffe71b636da453fce042d79d723", GM = {
  standaloneChains: n_,
  enableExplorer: !1,
  enableAccountView: !0,
  enableNetworkView: !0,
  enableStandaloneMode: !0,
  mobileWallets: [
    {
      id: "puzzle",
      name: "Puzzle Wallet",
      links: {
        native: "puzzleapp://",
        universal: ""
      }
    }
  ],
  desktopWallets: [
    {
      id: "puzzle",
      name: "Puzzle Wallet",
      links: {
        native: "",
        universal: "https://walletconnect.puzzle.online/"
      }
    },
    {
      id: "avail",
      name: "Avail Wallet",
      links: {
        native: "avail://",
        universal: "https://avail.global"
      }
    }
  ],
  walletImages: {
    puzzle: "https://i.imgur.com/p9tHaFC.png",
    avail: "https://i.imgur.com/GxNn8BO.png"
  }
}, i_ = new fp();
let wa;
function ZM(t) {
  wa = new KM({
    projectId: WM,
    metadata: {
      name: t.dAppName,
      description: t.dAppDescription,
      url: t.dAppUrl,
      icons: [t.dAppIconURL]
    },
    modalOptions: { ...GM }
  }), window.localStorage.removeItem("WALLETCONNECT_DEEPLINK_CHOICE");
}
async function s_() {
  return new Promise((t) => {
    if (wa)
      t(wa);
    else {
      const e = setInterval(() => {
        wa && (clearInterval(e), t(wa));
      }, 200);
    }
    window.localStorage.removeItem("WALLETCONNECT_DEEPLINK_CHOICE");
  });
}
var St;
(function(t) {
  t.assertEqual = (i) => i;
  function e(i) {
  }
  t.assertIs = e;
  function r(i) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (i) => {
    const s = {};
    for (const a of i)
      s[a] = a;
    return s;
  }, t.getValidEnumValues = (i) => {
    const s = t.objectKeys(i).filter((o) => typeof i[i[o]] != "number"), a = {};
    for (const o of s)
      a[o] = i[o];
    return t.objectValues(a);
  }, t.objectValues = (i) => t.objectKeys(i).map(function(s) {
    return i[s];
  }), t.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const s = [];
    for (const a in i)
      Object.prototype.hasOwnProperty.call(i, a) && s.push(a);
    return s;
  }, t.find = (i, s) => {
    for (const a of i)
      if (s(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, s = " | ") {
    return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s;
})(St || (St = {}));
var of;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(of || (of = {}));
const Se = St.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Mi = (t) => {
  switch (typeof t) {
    case "undefined":
      return Se.undefined;
    case "string":
      return Se.string;
    case "number":
      return isNaN(t) ? Se.nan : Se.number;
    case "boolean":
      return Se.boolean;
    case "function":
      return Se.function;
    case "bigint":
      return Se.bigint;
    case "symbol":
      return Se.symbol;
    case "object":
      return Array.isArray(t) ? Se.array : t === null ? Se.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? Se.promise : typeof Map < "u" && t instanceof Map ? Se.map : typeof Set < "u" && t instanceof Set ? Se.set : typeof Date < "u" && t instanceof Date ? Se.date : Se.object;
    default:
      return Se.unknown;
  }
}, ie = St.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), YM = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class An extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(s) {
      return s.message;
    }, n = { _errors: [] }, i = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o = n, l = 0;
          for (; l < a.path.length; ) {
            const u = a.path[l];
            l === a.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(a))) : o[u] = o[u] || { _errors: [] }, o = o[u], l++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, St.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(e(i))) : n.push(e(i));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
An.create = (t) => new An(t);
const Ma = (t, e) => {
  let r;
  switch (t.code) {
    case ie.invalid_type:
      t.received === Se.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case ie.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, St.jsonStringifyReplacer)}`;
      break;
    case ie.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${St.joinValues(t.keys, ", ")}`;
      break;
    case ie.invalid_union:
      r = "Invalid input";
      break;
    case ie.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${St.joinValues(t.options)}`;
      break;
    case ie.invalid_enum_value:
      r = `Invalid enum value. Expected ${St.joinValues(t.options)}, received '${t.received}'`;
      break;
    case ie.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case ie.invalid_return_type:
      r = "Invalid function return type";
      break;
    case ie.invalid_date:
      r = "Invalid date";
      break;
    case ie.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : St.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case ie.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case ie.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case ie.custom:
      r = "Invalid input";
      break;
    case ie.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case ie.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case ie.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, St.assertNever(t);
  }
  return { message: r };
};
let o_ = Ma;
function QM(t) {
  o_ = t;
}
function Lu() {
  return o_;
}
const Mu = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: i } = t, s = [...r, ...i.path || []], a = {
    ...i,
    path: s
  };
  let o = "";
  const l = n.filter((u) => !!u).slice().reverse();
  for (const u of l)
    o = u(a, { data: e, defaultError: o }).message;
  return {
    ...i,
    path: s,
    message: i.message || o
  };
}, JM = [];
function xe(t, e) {
  const r = Mu({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      Lu(),
      Ma
      // then global default map
    ].filter((n) => !!n)
  });
  t.common.issues.push(r);
}
class Nr {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const i of r) {
      if (i.status === "aborted")
        return et;
      i.status === "dirty" && e.dirty(), n.push(i.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const i of r)
      n.push({
        key: await i.key,
        value: await i.value
      });
    return Nr.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const i of r) {
      const { key: s, value: a } = i;
      if (s.status === "aborted" || a.status === "aborted")
        return et;
      s.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || i.alwaysSet) && (n[s.value] = a.value);
    }
    return { status: e.value, value: n };
  }
}
const et = Object.freeze({
  status: "aborted"
}), a_ = (t) => ({ status: "dirty", value: t }), Yr = (t) => ({ status: "valid", value: t }), af = (t) => t.status === "aborted", cf = (t) => t.status === "dirty", ju = (t) => t.status === "valid", ku = (t) => typeof Promise < "u" && t instanceof Promise;
var Le;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(Le || (Le = {}));
class Jn {
  constructor(e, r, n, i) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Rv = (t, e) => {
  if (ju(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new An(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function st(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: i } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: i } : { errorMap: (s, a) => s.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: n ?? a.defaultError } : { message: r ?? a.defaultError }, description: i };
}
class ft {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Mi(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: Mi(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Nr(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Mi(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (ku(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Mi(e)
    }, s = this._parseSync({ data: e, path: i.path, parent: i });
    return Rv(i, s);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Mi(e)
    }, i = this._parse({ data: e, path: n.path, parent: n }), s = await (ku(i) ? i : Promise.resolve(i));
    return Rv(n, s);
  }
  refine(e, r) {
    const n = (i) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r;
    return this._refinement((i, s) => {
      const a = e(i), o = () => s.addIssue({
        code: ie.custom,
        ...n(i)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((l) => l ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((n, i) => e(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
  }
  _refinement(e) {
    return new kn({
      schema: this,
      typeName: ze.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return Oi.create(this, this._def);
  }
  nullable() {
    return xs.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ln.create(this, this._def);
  }
  promise() {
    return Oo.create(this, this._def);
  }
  or(e) {
    return $a.create([this, e], this._def);
  }
  and(e) {
    return Fa.create(this, e, this._def);
  }
  transform(e) {
    return new kn({
      ...st(this._def),
      schema: this,
      typeName: ze.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Ba({
      ...st(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ze.ZodDefault
    });
  }
  brand() {
    return new u_({
      typeName: ze.ZodBranded,
      type: this,
      ...st(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new qu({
      ...st(this._def),
      innerType: this,
      catchValue: r,
      typeName: ze.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Lc.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const XM = /^c[^\s-]{8,}$/i, e4 = /^[a-z][a-z0-9]*$/, t4 = /[0-9A-HJKMNP-TV-Z]{26}/, r4 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, n4 = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, i4 = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), s4 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, o4 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, a4 = (t) => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function c4(t, e) {
  return !!((e === "v4" || !e) && s4.test(t) || (e === "v6" || !e) && o4.test(t));
}
class Rn extends ft {
  constructor() {
    super(...arguments), this._regex = (e, r, n) => this.refinement((i) => e.test(i), {
      validation: r,
      code: ie.invalid_string,
      ...Le.errToObj(n)
    }), this.nonempty = (e) => this.min(1, Le.errToObj(e)), this.trim = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== Se.string) {
      const i = this._getOrReturnCtx(e);
      return xe(
        i,
        {
          code: ie.invalid_type,
          expected: Se.string,
          received: i.parsedType
        }
        //
      ), et;
    }
    const r = new Nr();
    let n;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (n = this._getOrReturnCtx(e, n), xe(n, {
          code: ie.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (n = this._getOrReturnCtx(e, n), xe(n, {
          code: ie.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "length") {
        const s = e.data.length > i.value, a = e.data.length < i.value;
        (s || a) && (n = this._getOrReturnCtx(e, n), s ? xe(n, {
          code: ie.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : a && xe(n, {
          code: ie.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email")
        n4.test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "email",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "emoji")
        i4.test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "emoji",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        r4.test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "uuid",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        XM.test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "cuid",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid2")
        e4.test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "cuid2",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "ulid")
        t4.test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "ulid",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          n = this._getOrReturnCtx(e, n), xe(n, {
            validation: "url",
            code: ie.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "regex",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (n = this._getOrReturnCtx(e, n), xe(n, {
          code: ie.invalid_string,
          validation: { includes: i.value, position: i.position },
          message: i.message
        }), r.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (n = this._getOrReturnCtx(e, n), xe(n, {
          code: ie.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (n = this._getOrReturnCtx(e, n), xe(n, {
          code: ie.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "datetime" ? a4(i).test(e.data) || (n = this._getOrReturnCtx(e, n), xe(n, {
          code: ie.invalid_string,
          validation: "datetime",
          message: i.message
        }), r.dirty()) : i.kind === "ip" ? c4(e.data, i.version) || (n = this._getOrReturnCtx(e, n), xe(n, {
          validation: "ip",
          code: ie.invalid_string,
          message: i.message
        }), r.dirty()) : St.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _addCheck(e) {
    return new Rn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...Le.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...Le.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...Le.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...Le.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...Le.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...Le.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...Le.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...Le.errToObj(e) });
  }
  datetime(e) {
    var r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : !1,
      ...Le.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...Le.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r == null ? void 0 : r.position,
      ...Le.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...Le.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...Le.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...Le.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...Le.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...Le.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
Rn.create = (t) => {
  var e;
  return new Rn({
    checks: [],
    typeName: ze.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...st(t)
  });
};
function u4(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, i = r > n ? r : n, s = parseInt(t.toFixed(i).replace(".", "")), a = parseInt(e.toFixed(i).replace(".", ""));
  return s % a / Math.pow(10, i);
}
class zi extends ft {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== Se.number) {
      const i = this._getOrReturnCtx(e);
      return xe(i, {
        code: ie.invalid_type,
        expected: Se.number,
        received: i.parsedType
      }), et;
    }
    let r;
    const n = new Nr();
    for (const i of this._def.checks)
      i.kind === "int" ? St.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), n.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), n.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), n.dirty()) : i.kind === "multipleOf" ? u4(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), n.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.not_finite,
        message: i.message
      }), n.dirty()) : St.assertNever(i);
    return { status: n.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Le.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Le.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Le.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Le.toString(r));
  }
  setLimit(e, r, n, i) {
    return new zi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: Le.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new zi({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: Le.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Le.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Le.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Le.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Le.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Le.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: Le.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Le.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Le.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && St.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
zi.create = (t) => new zi({
  checks: [],
  typeName: ze.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...st(t)
});
class Vi extends ft {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== Se.bigint) {
      const i = this._getOrReturnCtx(e);
      return xe(i, {
        code: ie.invalid_type,
        expected: Se.bigint,
        received: i.parsedType
      }), et;
    }
    let r;
    const n = new Nr();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), n.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), n.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), xe(r, {
        code: ie.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), n.dirty()) : St.assertNever(i);
    return { status: n.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Le.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Le.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Le.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Le.toString(r));
  }
  setLimit(e, r, n, i) {
    return new Vi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: Le.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Vi({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Le.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Le.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Le.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Le.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Le.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
Vi.create = (t) => {
  var e;
  return new Vi({
    checks: [],
    typeName: ze.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...st(t)
  });
};
class ja extends ft {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== Se.boolean) {
      const r = this._getOrReturnCtx(e);
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.boolean,
        received: r.parsedType
      }), et;
    }
    return Yr(e.data);
  }
}
ja.create = (t) => new ja({
  typeName: ze.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...st(t)
});
class Os extends ft {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== Se.date) {
      const i = this._getOrReturnCtx(e);
      return xe(i, {
        code: ie.invalid_type,
        expected: Se.date,
        received: i.parsedType
      }), et;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return xe(i, {
        code: ie.invalid_date
      }), et;
    }
    const r = new Nr();
    let n;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (n = this._getOrReturnCtx(e, n), xe(n, {
        code: ie.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (n = this._getOrReturnCtx(e, n), xe(n, {
        code: ie.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : St.assertNever(i);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Os({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: Le.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: Le.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
Os.create = (t) => new Os({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: ze.ZodDate,
  ...st(t)
});
class Uu extends ft {
  _parse(e) {
    if (this._getType(e) !== Se.symbol) {
      const r = this._getOrReturnCtx(e);
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.symbol,
        received: r.parsedType
      }), et;
    }
    return Yr(e.data);
  }
}
Uu.create = (t) => new Uu({
  typeName: ze.ZodSymbol,
  ...st(t)
});
class ka extends ft {
  _parse(e) {
    if (this._getType(e) !== Se.undefined) {
      const r = this._getOrReturnCtx(e);
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.undefined,
        received: r.parsedType
      }), et;
    }
    return Yr(e.data);
  }
}
ka.create = (t) => new ka({
  typeName: ze.ZodUndefined,
  ...st(t)
});
class Ua extends ft {
  _parse(e) {
    if (this._getType(e) !== Se.null) {
      const r = this._getOrReturnCtx(e);
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.null,
        received: r.parsedType
      }), et;
    }
    return Yr(e.data);
  }
}
Ua.create = (t) => new Ua({
  typeName: ze.ZodNull,
  ...st(t)
});
class So extends ft {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Yr(e.data);
  }
}
So.create = (t) => new So({
  typeName: ze.ZodAny,
  ...st(t)
});
class ws extends ft {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Yr(e.data);
  }
}
ws.create = (t) => new ws({
  typeName: ze.ZodUnknown,
  ...st(t)
});
class Ci extends ft {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return xe(r, {
      code: ie.invalid_type,
      expected: Se.never,
      received: r.parsedType
    }), et;
  }
}
Ci.create = (t) => new Ci({
  typeName: ze.ZodNever,
  ...st(t)
});
class $u extends ft {
  _parse(e) {
    if (this._getType(e) !== Se.undefined) {
      const r = this._getOrReturnCtx(e);
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.void,
        received: r.parsedType
      }), et;
    }
    return Yr(e.data);
  }
}
$u.create = (t) => new $u({
  typeName: ze.ZodVoid,
  ...st(t)
});
class Ln extends ft {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), i = this._def;
    if (r.parsedType !== Se.array)
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.array,
        received: r.parsedType
      }), et;
    if (i.exactLength !== null) {
      const a = r.data.length > i.exactLength.value, o = r.data.length < i.exactLength.value;
      (a || o) && (xe(r, {
        code: a ? ie.too_big : ie.too_small,
        minimum: o ? i.exactLength.value : void 0,
        maximum: a ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && r.data.length < i.minLength.value && (xe(r, {
      code: ie.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (xe(r, {
      code: ie.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => i.type._parseAsync(new Jn(r, a, r.path, o)))).then((a) => Nr.mergeArray(n, a));
    const s = [...r.data].map((a, o) => i.type._parseSync(new Jn(r, a, r.path, o)));
    return Nr.mergeArray(n, s);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new Ln({
      ...this._def,
      minLength: { value: e, message: Le.toString(r) }
    });
  }
  max(e, r) {
    return new Ln({
      ...this._def,
      maxLength: { value: e, message: Le.toString(r) }
    });
  }
  length(e, r) {
    return new Ln({
      ...this._def,
      exactLength: { value: e, message: Le.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Ln.create = (t, e) => new Ln({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ze.ZodArray,
  ...st(e)
});
function eo(t) {
  if (t instanceof Vt) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = Oi.create(eo(n));
    }
    return new Vt({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof Ln ? new Ln({
      ...t._def,
      type: eo(t.element)
    }) : t instanceof Oi ? Oi.create(eo(t.unwrap())) : t instanceof xs ? xs.create(eo(t.unwrap())) : t instanceof Xn ? Xn.create(t.items.map((e) => eo(e))) : t;
}
class Vt extends ft {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = St.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== Se.object) {
      const l = this._getOrReturnCtx(e);
      return xe(l, {
        code: ie.invalid_type,
        expected: Se.object,
        received: l.parsedType
      }), et;
    }
    const { status: r, ctx: n } = this._processInputParams(e), { shape: i, keys: s } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof Ci && this._def.unknownKeys === "strip"))
      for (const l in n.data)
        s.includes(l) || a.push(l);
    const o = [];
    for (const l of s) {
      const u = i[l], h = n.data[l];
      o.push({
        key: { status: "valid", value: l },
        value: u._parse(new Jn(n, h, n.path, l)),
        alwaysSet: l in n.data
      });
    }
    if (this._def.catchall instanceof Ci) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of a)
          o.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: n.data[u] }
          });
      else if (l === "strict")
        a.length > 0 && (xe(n, {
          code: ie.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const u of a) {
        const h = n.data[u];
        o.push({
          key: { status: "valid", value: u },
          value: l._parse(
            new Jn(n, h, n.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of o) {
        const h = await u.key;
        l.push({
          key: h,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return l;
    }).then((l) => Nr.mergeObjectSync(r, l)) : Nr.mergeObjectSync(r, o);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return Le.errToObj, new Vt({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var i, s, a, o;
          const l = (a = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = Le.errToObj(e).message) !== null && o !== void 0 ? o : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new Vt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Vt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new Vt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new Vt({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: ze.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new Vt({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return St.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new Vt({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return St.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new Vt({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return eo(this);
  }
  partial(e) {
    const r = {};
    return St.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      e && !e[n] ? r[n] = i : r[n] = i.optional();
    }), new Vt({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return St.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof Oi; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new Vt({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return c_(St.objectKeys(this.shape));
  }
}
Vt.create = (t, e) => new Vt({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Ci.create(),
  typeName: ze.ZodObject,
  ...st(e)
});
Vt.strictCreate = (t, e) => new Vt({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Ci.create(),
  typeName: ze.ZodObject,
  ...st(e)
});
Vt.lazycreate = (t, e) => new Vt({
  shape: t,
  unknownKeys: "strip",
  catchall: Ci.create(),
  typeName: ze.ZodObject,
  ...st(e)
});
class $a extends ft {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function i(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((o) => new An(o.ctx.common.issues));
      return xe(r, {
        code: ie.invalid_union,
        unionErrors: a
      }), et;
    }
    if (r.common.async)
      return Promise.all(n.map(async (s) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(i);
    {
      let s;
      const a = [];
      for (const l of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, h = l._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (h.status === "valid")
          return h;
        h.status === "dirty" && !s && (s = { result: h, ctx: u }), u.common.issues.length && a.push(u.common.issues);
      }
      if (s)
        return r.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((l) => new An(l));
      return xe(r, {
        code: ie.invalid_union,
        unionErrors: o
      }), et;
    }
  }
  get options() {
    return this._def.options;
  }
}
$a.create = (t, e) => new $a({
  options: t,
  typeName: ze.ZodUnion,
  ...st(e)
});
const hu = (t) => t instanceof za ? hu(t.schema) : t instanceof kn ? hu(t.innerType()) : t instanceof Va ? [t.value] : t instanceof Ki ? t.options : t instanceof Ka ? Object.keys(t.enum) : t instanceof Ba ? hu(t._def.innerType) : t instanceof ka ? [void 0] : t instanceof Ua ? [null] : null;
class Rl extends ft {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Se.object)
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.object,
        received: r.parsedType
      }), et;
    const n = this.discriminator, i = r.data[n], s = this.optionsMap.get(i);
    return s ? r.common.async ? s._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : s._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (xe(r, {
      code: ie.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), et);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const i = /* @__PURE__ */ new Map();
    for (const s of r) {
      const a = hu(s.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (i.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        i.set(o, s);
      }
    }
    return new Rl({
      typeName: ze.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: i,
      ...st(n)
    });
  }
}
function uf(t, e) {
  const r = Mi(t), n = Mi(e);
  if (t === e)
    return { valid: !0, data: t };
  if (r === Se.object && n === Se.object) {
    const i = St.objectKeys(e), s = St.objectKeys(t).filter((o) => i.indexOf(o) !== -1), a = { ...t, ...e };
    for (const o of s) {
      const l = uf(t[o], e[o]);
      if (!l.valid)
        return { valid: !1 };
      a[o] = l.data;
    }
    return { valid: !0, data: a };
  } else if (r === Se.array && n === Se.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const i = [];
    for (let s = 0; s < t.length; s++) {
      const a = t[s], o = e[s], l = uf(a, o);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else
    return r === Se.date && n === Se.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Fa extends ft {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), i = (s, a) => {
      if (af(s) || af(a))
        return et;
      const o = uf(s.value, a.value);
      return o.valid ? ((cf(s) || cf(a)) && r.dirty(), { status: r.value, value: o.data }) : (xe(n, {
        code: ie.invalid_intersection_types
      }), et);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([s, a]) => i(s, a)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Fa.create = (t, e, r) => new Fa({
  left: t,
  right: e,
  typeName: ze.ZodIntersection,
  ...st(r)
});
class Xn extends ft {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Se.array)
      return xe(n, {
        code: ie.invalid_type,
        expected: Se.array,
        received: n.parsedType
      }), et;
    if (n.data.length < this._def.items.length)
      return xe(n, {
        code: ie.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), et;
    !this._def.rest && n.data.length > this._def.items.length && (xe(n, {
      code: ie.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((s, a) => {
      const o = this._def.items[a] || this._def.rest;
      return o ? o._parse(new Jn(n, s, n.path, a)) : null;
    }).filter((s) => !!s);
    return n.common.async ? Promise.all(i).then((s) => Nr.mergeArray(r, s)) : Nr.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Xn({
      ...this._def,
      rest: e
    });
  }
}
Xn.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Xn({
    items: t,
    typeName: ze.ZodTuple,
    rest: null,
    ...st(e)
  });
};
class qa extends ft {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Se.object)
      return xe(n, {
        code: ie.invalid_type,
        expected: Se.object,
        received: n.parsedType
      }), et;
    const i = [], s = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      i.push({
        key: s._parse(new Jn(n, o, n.path, o)),
        value: a._parse(new Jn(n, n.data[o], n.path, o))
      });
    return n.common.async ? Nr.mergeObjectAsync(r, i) : Nr.mergeObjectSync(r, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof ft ? new qa({
      keyType: e,
      valueType: r,
      typeName: ze.ZodRecord,
      ...st(n)
    }) : new qa({
      keyType: Rn.create(),
      valueType: e,
      typeName: ze.ZodRecord,
      ...st(r)
    });
  }
}
class Fu extends ft {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Se.map)
      return xe(n, {
        code: ie.invalid_type,
        expected: Se.map,
        received: n.parsedType
      }), et;
    const i = this._def.keyType, s = this._def.valueType, a = [...n.data.entries()].map(([o, l], u) => ({
      key: i._parse(new Jn(n, o, n.path, [u, "key"])),
      value: s._parse(new Jn(n, l, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of a) {
          const u = await l.key, h = await l.value;
          if (u.status === "aborted" || h.status === "aborted")
            return et;
          (u.status === "dirty" || h.status === "dirty") && r.dirty(), o.set(u.value, h.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const l of a) {
        const u = l.key, h = l.value;
        if (u.status === "aborted" || h.status === "aborted")
          return et;
        (u.status === "dirty" || h.status === "dirty") && r.dirty(), o.set(u.value, h.value);
      }
      return { status: r.value, value: o };
    }
  }
}
Fu.create = (t, e, r) => new Fu({
  valueType: e,
  keyType: t,
  typeName: ze.ZodMap,
  ...st(r)
});
class Is extends ft {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Se.set)
      return xe(n, {
        code: ie.invalid_type,
        expected: Se.set,
        received: n.parsedType
      }), et;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (xe(n, {
      code: ie.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (xe(n, {
      code: ie.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), r.dirty());
    const s = this._def.valueType;
    function a(l) {
      const u = /* @__PURE__ */ new Set();
      for (const h of l) {
        if (h.status === "aborted")
          return et;
        h.status === "dirty" && r.dirty(), u.add(h.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((l, u) => s._parse(new Jn(n, l, n.path, u)));
    return n.common.async ? Promise.all(o).then((l) => a(l)) : a(o);
  }
  min(e, r) {
    return new Is({
      ...this._def,
      minSize: { value: e, message: Le.toString(r) }
    });
  }
  max(e, r) {
    return new Is({
      ...this._def,
      maxSize: { value: e, message: Le.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Is.create = (t, e) => new Is({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: ze.ZodSet,
  ...st(e)
});
class fo extends ft {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Se.function)
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.function,
        received: r.parsedType
      }), et;
    function n(o, l) {
      return Mu({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Lu(),
          Ma
        ].filter((u) => !!u),
        issueData: {
          code: ie.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function i(o, l) {
      return Mu({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Lu(),
          Ma
        ].filter((u) => !!u),
        issueData: {
          code: ie.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const s = { errorMap: r.common.contextualErrorMap }, a = r.data;
    return this._def.returns instanceof Oo ? Yr(async (...o) => {
      const l = new An([]), u = await this._def.args.parseAsync(o, s).catch((f) => {
        throw l.addIssue(n(o, f)), l;
      }), h = await a(...u);
      return await this._def.returns._def.type.parseAsync(h, s).catch((f) => {
        throw l.addIssue(i(h, f)), l;
      });
    }) : Yr((...o) => {
      const l = this._def.args.safeParse(o, s);
      if (!l.success)
        throw new An([n(o, l.error)]);
      const u = a(...l.data), h = this._def.returns.safeParse(u, s);
      if (!h.success)
        throw new An([i(u, h.error)]);
      return h.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new fo({
      ...this._def,
      args: Xn.create(e).rest(ws.create())
    });
  }
  returns(e) {
    return new fo({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new fo({
      args: e || Xn.create([]).rest(ws.create()),
      returns: r || ws.create(),
      typeName: ze.ZodFunction,
      ...st(n)
    });
  }
}
class za extends ft {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
za.create = (t, e) => new za({
  getter: t,
  typeName: ze.ZodLazy,
  ...st(e)
});
class Va extends ft {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return xe(r, {
        received: r.data,
        code: ie.invalid_literal,
        expected: this._def.value
      }), et;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Va.create = (t, e) => new Va({
  value: t,
  typeName: ze.ZodLiteral,
  ...st(e)
});
function c_(t, e) {
  return new Ki({
    values: t,
    typeName: ze.ZodEnum,
    ...st(e)
  });
}
class Ki extends ft {
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return xe(r, {
        expected: St.joinValues(n),
        received: r.parsedType,
        code: ie.invalid_type
      }), et;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return xe(r, {
        received: r.data,
        code: ie.invalid_enum_value,
        options: n
      }), et;
    }
    return Yr(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e) {
    return Ki.create(e);
  }
  exclude(e) {
    return Ki.create(this.options.filter((r) => !e.includes(r)));
  }
}
Ki.create = c_;
class Ka extends ft {
  _parse(e) {
    const r = St.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== Se.string && n.parsedType !== Se.number) {
      const i = St.objectValues(r);
      return xe(n, {
        expected: St.joinValues(i),
        received: n.parsedType,
        code: ie.invalid_type
      }), et;
    }
    if (r.indexOf(e.data) === -1) {
      const i = St.objectValues(r);
      return xe(n, {
        received: n.data,
        code: ie.invalid_enum_value,
        options: i
      }), et;
    }
    return Yr(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Ka.create = (t, e) => new Ka({
  values: t,
  typeName: ze.ZodNativeEnum,
  ...st(e)
});
class Oo extends ft {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Se.promise && r.common.async === !1)
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.promise,
        received: r.parsedType
      }), et;
    const n = r.parsedType === Se.promise ? r.data : Promise.resolve(r.data);
    return Yr(n.then((i) => this._def.type.parseAsync(i, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
Oo.create = (t, e) => new Oo({
  type: t,
  typeName: ze.ZodPromise,
  ...st(e)
});
class kn extends ft {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ze.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), i = this._def.effect || null;
    if (i.type === "preprocess") {
      const a = i.transform(n.data);
      return n.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    const s = {
      addIssue: (a) => {
        xe(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), i.type === "refinement") {
      const a = (o) => {
        const l = i.refinement(o, s);
        if (n.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? et : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? et : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!ju(a))
          return a;
        const o = i.transform(a.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => ju(a) ? Promise.resolve(i.transform(a.value, s)).then((o) => ({ status: r.value, value: o })) : a);
    St.assertNever(i);
  }
}
kn.create = (t, e, r) => new kn({
  schema: t,
  typeName: ze.ZodEffects,
  effect: e,
  ...st(r)
});
kn.createWithPreprocess = (t, e, r) => new kn({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: ze.ZodEffects,
  ...st(r)
});
class Oi extends ft {
  _parse(e) {
    return this._getType(e) === Se.undefined ? Yr(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Oi.create = (t, e) => new Oi({
  innerType: t,
  typeName: ze.ZodOptional,
  ...st(e)
});
class xs extends ft {
  _parse(e) {
    return this._getType(e) === Se.null ? Yr(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
xs.create = (t, e) => new xs({
  innerType: t,
  typeName: ze.ZodNullable,
  ...st(e)
});
class Ba extends ft {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === Se.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ba.create = (t, e) => new Ba({
  innerType: t,
  typeName: ze.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...st(e)
});
class qu extends ft {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return ku(i) ? i.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new An(n.common.issues);
        }
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new An(n.common.issues);
        }
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
qu.create = (t, e) => new qu({
  innerType: t,
  typeName: ze.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...st(e)
});
class zu extends ft {
  _parse(e) {
    if (this._getType(e) !== Se.nan) {
      const r = this._getOrReturnCtx(e);
      return xe(r, {
        code: ie.invalid_type,
        expected: Se.nan,
        received: r.parsedType
      }), et;
    }
    return { status: "valid", value: e.data };
  }
}
zu.create = (t) => new zu({
  typeName: ze.ZodNaN,
  ...st(t)
});
const l4 = Symbol("zod_brand");
class u_ extends ft {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Lc extends ft {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? et : i.status === "dirty" ? (r.dirty(), a_(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? et : i.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new Lc({
      in: e,
      out: r,
      typeName: ze.ZodPipeline
    });
  }
}
const l_ = (t, e = {}, r) => t ? So.create().superRefine((n, i) => {
  var s, a;
  if (!t(n)) {
    const o = typeof e == "function" ? e(n) : e, l = (a = (s = o.fatal) !== null && s !== void 0 ? s : r) !== null && a !== void 0 ? a : !0, u = typeof o == "string" ? { message: o } : o;
    i.addIssue({ code: "custom", ...u, fatal: l });
  }
}) : So.create(), h4 = {
  object: Vt.lazycreate
};
var ze;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline";
})(ze || (ze = {}));
const d4 = (t, e = {
  message: `Input not instance of ${t.name}`
}) => l_((r) => r instanceof t, e), h_ = Rn.create, d_ = zi.create, f4 = zu.create, p4 = Vi.create, f_ = ja.create, g4 = Os.create, y4 = Uu.create, m4 = ka.create, v4 = Ua.create, b4 = So.create, w4 = ws.create, _4 = Ci.create, E4 = $u.create, S4 = Ln.create, O4 = Vt.create, I4 = Vt.strictCreate, x4 = $a.create, C4 = Rl.create, D4 = Fa.create, T4 = Xn.create, P4 = qa.create, R4 = Fu.create, N4 = Is.create, A4 = fo.create, L4 = za.create, M4 = Va.create, j4 = Ki.create, k4 = Ka.create, U4 = Oo.create, Nv = kn.create, $4 = Oi.create, F4 = xs.create, q4 = kn.createWithPreprocess, z4 = Lc.create, V4 = () => h_().optional(), K4 = () => d_().optional(), B4 = () => f_().optional(), H4 = {
  string: (t) => Rn.create({ ...t, coerce: !0 }),
  number: (t) => zi.create({ ...t, coerce: !0 }),
  boolean: (t) => ja.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => Vi.create({ ...t, coerce: !0 }),
  date: (t) => Os.create({ ...t, coerce: !0 })
}, W4 = et;
var $n = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Ma,
  setErrorMap: QM,
  getErrorMap: Lu,
  makeIssue: Mu,
  EMPTY_PATH: JM,
  addIssueToContext: xe,
  ParseStatus: Nr,
  INVALID: et,
  DIRTY: a_,
  OK: Yr,
  isAborted: af,
  isDirty: cf,
  isValid: ju,
  isAsync: ku,
  get util() {
    return St;
  },
  get objectUtil() {
    return of;
  },
  ZodParsedType: Se,
  getParsedType: Mi,
  ZodType: ft,
  ZodString: Rn,
  ZodNumber: zi,
  ZodBigInt: Vi,
  ZodBoolean: ja,
  ZodDate: Os,
  ZodSymbol: Uu,
  ZodUndefined: ka,
  ZodNull: Ua,
  ZodAny: So,
  ZodUnknown: ws,
  ZodNever: Ci,
  ZodVoid: $u,
  ZodArray: Ln,
  ZodObject: Vt,
  ZodUnion: $a,
  ZodDiscriminatedUnion: Rl,
  ZodIntersection: Fa,
  ZodTuple: Xn,
  ZodRecord: qa,
  ZodMap: Fu,
  ZodSet: Is,
  ZodFunction: fo,
  ZodLazy: za,
  ZodLiteral: Va,
  ZodEnum: Ki,
  ZodNativeEnum: Ka,
  ZodPromise: Oo,
  ZodEffects: kn,
  ZodTransformer: kn,
  ZodOptional: Oi,
  ZodNullable: xs,
  ZodDefault: Ba,
  ZodCatch: qu,
  ZodNaN: zu,
  BRAND: l4,
  ZodBranded: u_,
  ZodPipeline: Lc,
  custom: l_,
  Schema: ft,
  ZodSchema: ft,
  late: h4,
  get ZodFirstPartyTypeKind() {
    return ze;
  },
  coerce: H4,
  any: b4,
  array: S4,
  bigint: p4,
  boolean: f_,
  date: g4,
  discriminatedUnion: C4,
  effect: Nv,
  enum: j4,
  function: A4,
  instanceof: d4,
  intersection: D4,
  lazy: L4,
  literal: M4,
  map: R4,
  nan: f4,
  nativeEnum: k4,
  never: _4,
  null: v4,
  nullable: F4,
  number: d_,
  object: O4,
  oboolean: B4,
  onumber: K4,
  optional: $4,
  ostring: V4,
  pipeline: z4,
  preprocess: q4,
  promise: U4,
  record: P4,
  set: N4,
  strictObject: I4,
  string: h_,
  symbol: y4,
  transformer: Nv,
  tuple: T4,
  undefined: m4,
  union: x4,
  unknown: w4,
  void: E4,
  NEVER: W4,
  ZodIssueCode: ie,
  quotelessJson: YM,
  ZodError: An
});
const G4 = /^aleo1[a-z0-9]{58}$/i, Z4 = /^AViewKey1[a-z0-9]{44}$/i, Y4 = /^APrivateKey1[a-z0-9]{47}$/i, Q4 = /^at1[a-z0-9]{58}$/i, J4 = /^\d+field$/, X4 = /^\d+u32$/, ej = /^\d+u64$/;
$n.string().regex(G4);
$n.string().regex(Z4);
$n.string().regex(Y4);
$n.string().regex(Q4);
$n.string().regex(J4);
$n.string().regex(X4);
$n.string().regex(ej);
var Av;
(function(t) {
  t.Record = "record", t.OutputRecord = "outputRecord", t.Public = "public", t.Private = "private", t.Constant = "constant", t.Future = "future", t.ExternalRecord = "external_record";
})(Av || (Av = {}));
var lf;
(function(t) {
  t.Deploy = "Deploy", t.Execute = "Execute", t.Send = "Send", t.Receive = "Receive", t.Join = "Join", t.Split = "Split", t.Shield = "Shield", t.Unshield = "Unshield";
})(lf || (lf = {}));
var hf;
(function(t) {
  t.Creating = "Creating", t.Pending = "Pending", t.Settled = "Settled", t.Failed = "Failed";
})(hf || (hf = {}));
var df;
(function(t) {
  t.Private = "Private", t.Public = "Public";
})(df || (df = {}));
var ff;
(function(t) {
  t.AleoTestnet = "AleoTestnet", t.AleoMainnet = "AleoMainnet";
})(ff || (ff = {}));
var Lv;
(function(t) {
  t[t.ALEO = 0] = "ALEO";
})(Lv || (Lv = {}));
$n.nativeEnum(lf);
$n.nativeEnum(hf);
$n.nativeEnum(ff);
$n.nativeEnum(df);
var pf = { exports: {} }, Jh, Mv;
function tj() {
  if (Mv)
    return Jh;
  Mv = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, s = n * 365.25;
  Jh = function(h, f) {
    f = f || {};
    var g = typeof h;
    if (g === "string" && h.length > 0)
      return a(h);
    if (g === "number" && isFinite(h))
      return f.long ? l(h) : o(h);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(h)
    );
  };
  function a(h) {
    if (h = String(h), !(h.length > 100)) {
      var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        h
      );
      if (f) {
        var g = parseFloat(f[1]), m = (f[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return g * s;
          case "weeks":
          case "week":
          case "w":
            return g * i;
          case "days":
          case "day":
          case "d":
            return g * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return g * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return g * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return g * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return g;
          default:
            return;
        }
      }
    }
  }
  function o(h) {
    var f = Math.abs(h);
    return f >= n ? Math.round(h / n) + "d" : f >= r ? Math.round(h / r) + "h" : f >= e ? Math.round(h / e) + "m" : f >= t ? Math.round(h / t) + "s" : h + "ms";
  }
  function l(h) {
    var f = Math.abs(h);
    return f >= n ? u(h, f, n, "day") : f >= r ? u(h, f, r, "hour") : f >= e ? u(h, f, e, "minute") : f >= t ? u(h, f, t, "second") : h + " ms";
  }
  function u(h, f, g, m) {
    var w = f >= g * 1.5;
    return Math.round(h / g) + " " + m + (w ? "s" : "");
  }
  return Jh;
}
function rj(t) {
  r.debug = r, r.default = r, r.coerce = l, r.disable = s, r.enable = i, r.enabled = a, r.humanize = tj(), r.destroy = u, Object.keys(t).forEach((h) => {
    r[h] = t[h];
  }), r.names = [], r.skips = [], r.formatters = {};
  function e(h) {
    let f = 0;
    for (let g = 0; g < h.length; g++)
      f = (f << 5) - f + h.charCodeAt(g), f |= 0;
    return r.colors[Math.abs(f) % r.colors.length];
  }
  r.selectColor = e;
  function r(h) {
    let f, g = null, m, w;
    function S(...x) {
      if (!S.enabled)
        return;
      const M = S, _ = Number(/* @__PURE__ */ new Date()), I = _ - (f || _);
      M.diff = I, M.prev = f, M.curr = _, f = _, x[0] = r.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let b = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (E, y) => {
        if (E === "%%")
          return "%";
        b++;
        const c = r.formatters[y];
        if (typeof c == "function") {
          const p = x[b];
          E = c.call(M, p), x.splice(b, 1), b--;
        }
        return E;
      }), r.formatArgs.call(M, x), (M.log || r.log).apply(M, x);
    }
    return S.namespace = h, S.useColors = r.useColors(), S.color = r.selectColor(h), S.extend = n, S.destroy = r.destroy, Object.defineProperty(S, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => g !== null ? g : (m !== r.namespaces && (m = r.namespaces, w = r.enabled(h)), w),
      set: (x) => {
        g = x;
      }
    }), typeof r.init == "function" && r.init(S), S;
  }
  function n(h, f) {
    const g = r(this.namespace + (typeof f > "u" ? ":" : f) + h);
    return g.log = this.log, g;
  }
  function i(h) {
    r.save(h), r.namespaces = h, r.names = [], r.skips = [];
    let f;
    const g = (typeof h == "string" ? h : "").split(/[\s,]+/), m = g.length;
    for (f = 0; f < m; f++)
      g[f] && (h = g[f].replace(/\*/g, ".*?"), h[0] === "-" ? r.skips.push(new RegExp("^" + h.slice(1) + "$")) : r.names.push(new RegExp("^" + h + "$")));
  }
  function s() {
    const h = [
      ...r.names.map(o),
      ...r.skips.map(o).map((f) => "-" + f)
    ].join(",");
    return r.enable(""), h;
  }
  function a(h) {
    if (h[h.length - 1] === "*")
      return !0;
    let f, g;
    for (f = 0, g = r.skips.length; f < g; f++)
      if (r.skips[f].test(h))
        return !1;
    for (f = 0, g = r.names.length; f < g; f++)
      if (r.names[f].test(h))
        return !0;
    return !1;
  }
  function o(h) {
    return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(h) {
    return h instanceof Error ? h.stack || h.message : h;
  }
  function u() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var nj = rj;
(function(t, e) {
  e.formatArgs = n, e.save = i, e.load = s, e.useColors = r, e.storage = a(), e.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const u = "color: " + this.color;
    l.splice(1, 0, u, "color: inherit");
    let h = 0, f = 0;
    l[0].replace(/%[a-zA-Z%]/g, (g) => {
      g !== "%%" && (h++, g === "%c" && (f = h));
    }), l.splice(f, 0, u);
  }
  e.log = console.debug || console.log || (() => {
  });
  function i(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = nj(e);
  const { formatters: o } = t.exports;
  o.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (u) {
      return "[UnexpectedJSONParseError]: " + u.message;
    }
  };
})(pf, pf.exports);
var ij = pf.exports;
const sj = /* @__PURE__ */ vl(ij), Nl = sj("wallet:sdk");
Nl.enabled = !0;
function K9() {
  const e = !!_n(), { data: r, error: n, loading: i, setData: s, setError: a, setLoading: o } = hp(), [l] = Fi((h) => [h.setAccount]);
  async function u() {
    try {
      o(!0), a(void 0);
      const f = await (await s_()).connect({
        requiredNamespaces: {
          aleo: {
            methods: BM,
            chains: n_,
            events: HM
          }
        }
      });
      s(f);
      const g = f.namespaces.aleo.accounts[0].split(":");
      return l({
        network: g[0],
        chainId: g[1],
        address: g[2],
        shortenedAddress: Ld(g[2])
      }), i_.emit("session_change"), window.localStorage.removeItem("WALLETCONNECT_DEEPLINK_CHOICE"), f;
    } catch (h) {
      throw a(h), h;
    } finally {
      o(!1);
    }
  }
  return { data: r, error: n, loading: i, isConnected: e, connect: u };
}
const B9 = () => {
  const t = _n(), { request: e, data: r, error: n, loading: i } = Ic({
    topic: (t == null ? void 0 : t.topic) ?? "",
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "createSharedState",
      params: {}
    }
  }), s = n ? n.message : r && r.error, a = r;
  return { createSharedState: () => {
    t && !i && e();
  }, data: a == null ? void 0 : a.data, loading: i, error: s };
}, H9 = (t) => {
  Nl("useDecrypt", t);
  const e = _n(), { request: r, data: n, error: i, loading: s } = Ic({
    topic: (e == null ? void 0 : e.topic) ?? "",
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "decrypt",
      params: {
        ciphertexts: t
      }
    }
  }), a = i ? i.message : n && n.error, o = n;
  return { decrypt: () => {
    t && e && !s && r();
  }, plaintexts: o == null ? void 0 : o.plaintexts, loading: s, error: a };
};
function W9() {
  const t = _n(), [e] = Fi((o) => [o.onDisconnect]), { error: r, loading: n, setError: i, setLoading: s } = hp();
  async function a() {
    if (!t || n) {
      t || e();
      return;
    }
    try {
      s(!0), i(void 0);
      try {
        await (await s_()).disconnect({
          topic: t.topic,
          reason: zt("USER_DISCONNECTED")
        }), i_.emit("session_change");
      } catch (o) {
        console.warn(o);
      }
      Fi.getState().onDisconnect();
    } catch (o) {
      throw i(o), o;
    } finally {
      s(!1);
    }
  }
  return { error: r, loading: n, disconnect: a };
}
const G9 = ({ id: t, address: e, multisig: r = !1 }) => {
  const n = _n(), [i] = Fi((S) => [S.account]), s = t !== void 0 && t !== "" && !!n && !!i && (r ? !!e : !0), { refetch: a, data: o, error: l, isLoading: u } = Oc({
    queryKey: ["useEvent", i == null ? void 0 : i.address, e, r, t, n == null ? void 0 : n.topic],
    enabled: s,
    wcParams: {
      topic: n == null ? void 0 : n.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "getEvent",
        params: {
          id: t ?? "",
          address: e
        }
      }
    }
  });
  Ec(({ params: S, topic: x }) => {
    const M = S.event.name, _ = S.event.address ?? S.event.data.address;
    (t && M === "selectedAccountSynced" && !r || M === "sharedAccountSynced" && r && _ === e) && a();
  });
  const h = !!n && !!i && !!t && (r ? !!e : !0);
  pr(() => {
    h && !u && a();
  }, [h]);
  const f = () => {
    h && !u && a();
  }, g = l ? l.message : o && o.error, m = o, w = m == null ? void 0 : m.event;
  return { fetchEvent: f, event: w, error: g, loading: u };
}, Z9 = ({ filter: t, page: e }) => {
  const r = _n(), [n] = Fi((w) => [w.account]);
  (t == null ? void 0 : t.programId) === "" && (t.programId = void 0);
  const { refetch: i, data: s, error: a, isLoading: o } = Oc({
    queryKey: ["useEvents", n == null ? void 0 : n.address, t, e, r == null ? void 0 : r.topic],
    enabled: !!r && !!n,
    wcParams: {
      topic: (r == null ? void 0 : r.topic) ?? "",
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "getEvents",
        params: {
          filter: t,
          page: e
        }
      }
    }
  });
  Ec(({ id: w, params: S, topic: x }) => {
    S.event.name === "selectedAccountSynced" && i();
  });
  const l = !!r && !!n;
  pr(() => {
    l && !o && i();
  }, [l]);
  const u = () => {
    l && !o && i();
  }, h = a ? a.message : s && s.error, f = s, g = f == null ? void 0 : f.events, m = (f == null ? void 0 : f.pageCount) ?? 0;
  return { fetchPage: u, events: g, error: h, loading: o, page: e, pageCount: m };
}, Y9 = (t) => {
  const e = _n(), { request: r, data: n, error: i, loading: s } = Ic({
    topic: (e == null ? void 0 : e.topic) ?? "",
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "importSharedState",
      params: {
        seed: t
      }
    }
  }), a = i ? i.message : n && n.error, o = n;
  return { importSharedState: () => {
    e && !s && r();
  }, data: o == null ? void 0 : o.data, loading: s, error: a };
}, Q9 = (t) => {
  try {
    return JSON.stringify(t, null, 2).replaceAll('"', "") ?? "";
  } catch {
    return "";
  }
}, J9 = ({ address: t, multisig: e = !1, filter: r, page: n }) => {
  const i = _n(), [s] = Fi((x) => [
    x.account
  ]), { refetch: a, data: o, error: l, isLoading: u } = Oc({
    queryKey: ["useRecords", s == null ? void 0 : s.address, t, e, r, n, i == null ? void 0 : i.topic],
    enabled: (e ? !!t : !0) && !!i && !!s,
    wcParams: {
      topic: i == null ? void 0 : i.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "getRecords",
        params: {
          address: t,
          filter: r,
          page: n
        }
      }
    }
  }), h = !!i && !!s && (e ? !!t : !0);
  Ec(({ params: x }) => {
    const M = x.event.name, _ = x.event.address ?? x.event.data.address;
    (M === "selectedAccountSynced" && !e || M === "sharedAccountSynced" && e && _ === t) && a();
  });
  const f = () => {
    h && !u && (Nl("useRecords refetching...", [t, e, r, n]), a());
  }, g = l ? l.message : o && o.error, m = o, w = m == null ? void 0 : m.records, S = (m == null ? void 0 : m.pageCount) ?? 0;
  return { fetchPage: f, records: w, error: g, loading: u, page: n, pageCount: S };
}, X9 = (t) => {
  const e = _n(), r = t == null ? void 0 : t.inputs.map((h) => typeof h == "string" ? h : h.plaintext), { request: n, data: i, error: s, loading: a } = Ic({
    topic: (e == null ? void 0 : e.topic) ?? "",
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "requestCreateEvent",
      params: {
        ...t,
        inputs: r
      }
    }
  }), o = s ? s.message : i && i.error, l = i;
  return { createEvent: () => {
    t && e && !a && (Nl("useCreateEvent requesting...", t), n());
  }, eventId: l == null ? void 0 : l.eventId, loading: a, error: o };
};
var Ot;
(function(t) {
  t.assertEqual = (i) => i;
  function e(i) {
  }
  t.assertIs = e;
  function r(i) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (i) => {
    const s = {};
    for (const a of i)
      s[a] = a;
    return s;
  }, t.getValidEnumValues = (i) => {
    const s = t.objectKeys(i).filter((o) => typeof i[i[o]] != "number"), a = {};
    for (const o of s)
      a[o] = i[o];
    return t.objectValues(a);
  }, t.objectValues = (i) => t.objectKeys(i).map(function(s) {
    return i[s];
  }), t.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const s = [];
    for (const a in i)
      Object.prototype.hasOwnProperty.call(i, a) && s.push(a);
    return s;
  }, t.find = (i, s) => {
    for (const a of i)
      if (s(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, s = " | ") {
    return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s;
})(Ot || (Ot = {}));
var gf;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(gf || (gf = {}));
const Oe = Ot.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ji = (t) => {
  switch (typeof t) {
    case "undefined":
      return Oe.undefined;
    case "string":
      return Oe.string;
    case "number":
      return isNaN(t) ? Oe.nan : Oe.number;
    case "boolean":
      return Oe.boolean;
    case "function":
      return Oe.function;
    case "bigint":
      return Oe.bigint;
    case "symbol":
      return Oe.symbol;
    case "object":
      return Array.isArray(t) ? Oe.array : t === null ? Oe.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? Oe.promise : typeof Map < "u" && t instanceof Map ? Oe.map : typeof Set < "u" && t instanceof Set ? Oe.set : typeof Date < "u" && t instanceof Date ? Oe.date : Oe.object;
    default:
      return Oe.unknown;
  }
}, se = Ot.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), oj = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class Mn extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(s) {
      return s.message;
    }, n = { _errors: [] }, i = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o = n, l = 0;
          for (; l < a.path.length; ) {
            const u = a.path[l];
            l === a.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(a))) : o[u] = o[u] || { _errors: [] }, o = o[u], l++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Ot.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(e(i))) : n.push(e(i));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
Mn.create = (t) => new Mn(t);
const Ha = (t, e) => {
  let r;
  switch (t.code) {
    case se.invalid_type:
      t.received === Oe.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case se.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, Ot.jsonStringifyReplacer)}`;
      break;
    case se.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Ot.joinValues(t.keys, ", ")}`;
      break;
    case se.invalid_union:
      r = "Invalid input";
      break;
    case se.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Ot.joinValues(t.options)}`;
      break;
    case se.invalid_enum_value:
      r = `Invalid enum value. Expected ${Ot.joinValues(t.options)}, received '${t.received}'`;
      break;
    case se.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case se.invalid_return_type:
      r = "Invalid function return type";
      break;
    case se.invalid_date:
      r = "Invalid date";
      break;
    case se.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Ot.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case se.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case se.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case se.custom:
      r = "Invalid input";
      break;
    case se.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case se.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case se.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, Ot.assertNever(t);
  }
  return { message: r };
};
let p_ = Ha;
function aj(t) {
  p_ = t;
}
function Vu() {
  return p_;
}
const Ku = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: i } = t, s = [...r, ...i.path || []], a = {
    ...i,
    path: s
  };
  let o = "";
  const l = n.filter((u) => !!u).slice().reverse();
  for (const u of l)
    o = u(a, { data: e, defaultError: o }).message;
  return {
    ...i,
    path: s,
    message: i.message || o
  };
}, cj = [];
function Ce(t, e) {
  const r = Ku({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      Vu(),
      Ha
      // then global default map
    ].filter((n) => !!n)
  });
  t.common.issues.push(r);
}
class Ar {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const i of r) {
      if (i.status === "aborted")
        return Ye;
      i.status === "dirty" && e.dirty(), n.push(i.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const i of r)
      n.push({
        key: await i.key,
        value: await i.value
      });
    return Ar.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const i of r) {
      const { key: s, value: a } = i;
      if (s.status === "aborted" || a.status === "aborted")
        return Ye;
      s.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || i.alwaysSet) && (n[s.value] = a.value);
    }
    return { status: e.value, value: n };
  }
}
const Ye = Object.freeze({
  status: "aborted"
}), g_ = (t) => ({ status: "dirty", value: t }), Qr = (t) => ({ status: "valid", value: t }), yf = (t) => t.status === "aborted", mf = (t) => t.status === "dirty", Bu = (t) => t.status === "valid", Hu = (t) => typeof Promise < "u" && t instanceof Promise;
var Me;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(Me || (Me = {}));
class ei {
  constructor(e, r, n, i) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const jv = (t, e) => {
  if (Bu(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new Mn(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function ot(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: i } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: i } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: n ?? o.defaultError } : { message: r ?? o.defaultError }, description: i };
}
class pt {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return ji(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: ji(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Ar(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: ji(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (Hu(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: ji(e)
    }, s = this._parseSync({ data: e, path: i.path, parent: i });
    return jv(i, s);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: ji(e)
    }, i = this._parse({ data: e, path: n.path, parent: n }), s = await (Hu(i) ? i : Promise.resolve(i));
    return jv(n, s);
  }
  refine(e, r) {
    const n = (i) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r;
    return this._refinement((i, s) => {
      const a = e(i), o = () => s.addIssue({
        code: se.custom,
        ...n(i)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((l) => l ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((n, i) => e(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
  }
  _refinement(e) {
    return new Un({
      schema: this,
      typeName: Ve.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return Ii.create(this, this._def);
  }
  nullable() {
    return Ts.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return jn.create(this, this._def);
  }
  promise() {
    return xo.create(this, this._def);
  }
  or(e) {
    return Ya.create([this, e], this._def);
  }
  and(e) {
    return Qa.create(this, e, this._def);
  }
  transform(e) {
    return new Un({
      ...ot(this._def),
      schema: this,
      typeName: Ve.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new rc({
      ...ot(this._def),
      innerType: this,
      defaultValue: r,
      typeName: Ve.ZodDefault
    });
  }
  brand() {
    return new m_({
      typeName: Ve.ZodBranded,
      type: this,
      ...ot(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Yu({
      ...ot(this._def),
      innerType: this,
      catchValue: r,
      typeName: Ve.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Mc.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const uj = /^c[^\s-]{8,}$/i, lj = /^[a-z][a-z0-9]*$/, hj = /[0-9A-HJKMNP-TV-Z]{26}/, dj = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, fj = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, pj = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), gj = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, yj = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, mj = (t) => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function vj(t, e) {
  return !!((e === "v4" || !e) && gj.test(t) || (e === "v6" || !e) && yj.test(t));
}
class Nn extends pt {
  constructor() {
    super(...arguments), this._regex = (e, r, n) => this.refinement((i) => e.test(i), {
      validation: r,
      code: se.invalid_string,
      ...Me.errToObj(n)
    }), this.nonempty = (e) => this.min(1, Me.errToObj(e)), this.trim = () => new Nn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Nn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Nn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== Oe.string) {
      const s = this._getOrReturnCtx(e);
      return Ce(
        s,
        {
          code: se.invalid_type,
          expected: Oe.string,
          received: s.parsedType
        }
        //
      ), Ye;
    }
    const n = new Ar();
    let i;
    for (const s of this._def.checks)
      if (s.kind === "min")
        e.data.length < s.value && (i = this._getOrReturnCtx(e, i), Ce(i, {
          code: se.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "max")
        e.data.length > s.value && (i = this._getOrReturnCtx(e, i), Ce(i, {
          code: se.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "length") {
        const a = e.data.length > s.value, o = e.data.length < s.value;
        (a || o) && (i = this._getOrReturnCtx(e, i), a ? Ce(i, {
          code: se.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : o && Ce(i, {
          code: se.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), n.dirty());
      } else if (s.kind === "email")
        fj.test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "email",
          code: se.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "emoji")
        pj.test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "emoji",
          code: se.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "uuid")
        dj.test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "uuid",
          code: se.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid")
        uj.test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "cuid",
          code: se.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid2")
        lj.test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "cuid2",
          code: se.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "ulid")
        hj.test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "ulid",
          code: se.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "url")
        try {
          new URL(e.data);
        } catch {
          i = this._getOrReturnCtx(e, i), Ce(i, {
            validation: "url",
            code: se.invalid_string,
            message: s.message
          }), n.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "regex",
          code: se.invalid_string,
          message: s.message
        }), n.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          code: se.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), n.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          code: se.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          code: se.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "datetime" ? mj(s).test(e.data) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          code: se.invalid_string,
          validation: "datetime",
          message: s.message
        }), n.dirty()) : s.kind === "ip" ? vj(e.data, s.version) || (i = this._getOrReturnCtx(e, i), Ce(i, {
          validation: "ip",
          code: se.invalid_string,
          message: s.message
        }), n.dirty()) : Ot.assertNever(s);
    return { status: n.value, value: e.data };
  }
  _addCheck(e) {
    return new Nn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...Me.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...Me.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...Me.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...Me.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...Me.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...Me.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...Me.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...Me.errToObj(e) });
  }
  datetime(e) {
    var r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : !1,
      ...Me.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...Me.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r == null ? void 0 : r.position,
      ...Me.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...Me.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...Me.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...Me.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...Me.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...Me.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
Nn.create = (t) => {
  var e;
  return new Nn({
    checks: [],
    typeName: Ve.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...ot(t)
  });
};
function bj(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, i = r > n ? r : n, s = parseInt(t.toFixed(i).replace(".", "")), a = parseInt(e.toFixed(i).replace(".", ""));
  return s % a / Math.pow(10, i);
}
class Bi extends pt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== Oe.number) {
      const s = this._getOrReturnCtx(e);
      return Ce(s, {
        code: se.invalid_type,
        expected: Oe.number,
        received: s.parsedType
      }), Ye;
    }
    let n;
    const i = new Ar();
    for (const s of this._def.checks)
      s.kind === "int" ? Ot.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), i.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? bj(e.data, s.value) !== 0 && (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.not_finite,
        message: s.message
      }), i.dirty()) : Ot.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Me.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Me.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Me.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Me.toString(r));
  }
  setLimit(e, r, n, i) {
    return new Bi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: Me.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Bi({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: Me.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Me.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Me.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Me.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Me.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Me.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: Me.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Me.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Me.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Ot.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
Bi.create = (t) => new Bi({
  checks: [],
  typeName: Ve.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...ot(t)
});
class Hi extends pt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== Oe.bigint) {
      const s = this._getOrReturnCtx(e);
      return Ce(s, {
        code: se.invalid_type,
        expected: Oe.bigint,
        received: s.parsedType
      }), Ye;
    }
    let n;
    const i = new Ar();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), Ce(n, {
        code: se.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : Ot.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Me.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Me.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Me.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Me.toString(r));
  }
  setLimit(e, r, n, i) {
    return new Hi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: Me.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Hi({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Me.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Me.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Me.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Me.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Me.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
Hi.create = (t) => {
  var e;
  return new Hi({
    checks: [],
    typeName: Ve.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...ot(t)
  });
};
class Wa extends pt {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== Oe.boolean) {
      const n = this._getOrReturnCtx(e);
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.boolean,
        received: n.parsedType
      }), Ye;
    }
    return Qr(e.data);
  }
}
Wa.create = (t) => new Wa({
  typeName: Ve.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...ot(t)
});
class Cs extends pt {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== Oe.date) {
      const s = this._getOrReturnCtx(e);
      return Ce(s, {
        code: se.invalid_type,
        expected: Oe.date,
        received: s.parsedType
      }), Ye;
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e);
      return Ce(s, {
        code: se.invalid_date
      }), Ye;
    }
    const n = new Ar();
    let i;
    for (const s of this._def.checks)
      s.kind === "min" ? e.data.getTime() < s.value && (i = this._getOrReturnCtx(e, i), Ce(i, {
        code: se.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), n.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (i = this._getOrReturnCtx(e, i), Ce(i, {
        code: se.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), n.dirty()) : Ot.assertNever(s);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Cs({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: Me.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: Me.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
Cs.create = (t) => new Cs({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: Ve.ZodDate,
  ...ot(t)
});
class Wu extends pt {
  _parse(e) {
    if (this._getType(e) !== Oe.symbol) {
      const n = this._getOrReturnCtx(e);
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.symbol,
        received: n.parsedType
      }), Ye;
    }
    return Qr(e.data);
  }
}
Wu.create = (t) => new Wu({
  typeName: Ve.ZodSymbol,
  ...ot(t)
});
class Ga extends pt {
  _parse(e) {
    if (this._getType(e) !== Oe.undefined) {
      const n = this._getOrReturnCtx(e);
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.undefined,
        received: n.parsedType
      }), Ye;
    }
    return Qr(e.data);
  }
}
Ga.create = (t) => new Ga({
  typeName: Ve.ZodUndefined,
  ...ot(t)
});
class Za extends pt {
  _parse(e) {
    if (this._getType(e) !== Oe.null) {
      const n = this._getOrReturnCtx(e);
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.null,
        received: n.parsedType
      }), Ye;
    }
    return Qr(e.data);
  }
}
Za.create = (t) => new Za({
  typeName: Ve.ZodNull,
  ...ot(t)
});
class Io extends pt {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Qr(e.data);
  }
}
Io.create = (t) => new Io({
  typeName: Ve.ZodAny,
  ...ot(t)
});
class _s extends pt {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Qr(e.data);
  }
}
_s.create = (t) => new _s({
  typeName: Ve.ZodUnknown,
  ...ot(t)
});
class Di extends pt {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return Ce(r, {
      code: se.invalid_type,
      expected: Oe.never,
      received: r.parsedType
    }), Ye;
  }
}
Di.create = (t) => new Di({
  typeName: Ve.ZodNever,
  ...ot(t)
});
class Gu extends pt {
  _parse(e) {
    if (this._getType(e) !== Oe.undefined) {
      const n = this._getOrReturnCtx(e);
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.void,
        received: n.parsedType
      }), Ye;
    }
    return Qr(e.data);
  }
}
Gu.create = (t) => new Gu({
  typeName: Ve.ZodVoid,
  ...ot(t)
});
class jn extends pt {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), i = this._def;
    if (r.parsedType !== Oe.array)
      return Ce(r, {
        code: se.invalid_type,
        expected: Oe.array,
        received: r.parsedType
      }), Ye;
    if (i.exactLength !== null) {
      const a = r.data.length > i.exactLength.value, o = r.data.length < i.exactLength.value;
      (a || o) && (Ce(r, {
        code: a ? se.too_big : se.too_small,
        minimum: o ? i.exactLength.value : void 0,
        maximum: a ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && r.data.length < i.minLength.value && (Ce(r, {
      code: se.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (Ce(r, {
      code: se.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => i.type._parseAsync(new ei(r, a, r.path, o)))).then((a) => Ar.mergeArray(n, a));
    const s = [...r.data].map((a, o) => i.type._parseSync(new ei(r, a, r.path, o)));
    return Ar.mergeArray(n, s);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new jn({
      ...this._def,
      minLength: { value: e, message: Me.toString(r) }
    });
  }
  max(e, r) {
    return new jn({
      ...this._def,
      maxLength: { value: e, message: Me.toString(r) }
    });
  }
  length(e, r) {
    return new jn({
      ...this._def,
      exactLength: { value: e, message: Me.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
jn.create = (t, e) => new jn({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ve.ZodArray,
  ...ot(e)
});
function to(t) {
  if (t instanceof Kt) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = Ii.create(to(n));
    }
    return new Kt({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof jn ? new jn({
      ...t._def,
      type: to(t.element)
    }) : t instanceof Ii ? Ii.create(to(t.unwrap())) : t instanceof Ts ? Ts.create(to(t.unwrap())) : t instanceof ti ? ti.create(t.items.map((e) => to(e))) : t;
}
class Kt extends pt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = Ot.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== Oe.object) {
      const u = this._getOrReturnCtx(e);
      return Ce(u, {
        code: se.invalid_type,
        expected: Oe.object,
        received: u.parsedType
      }), Ye;
    }
    const { status: n, ctx: i } = this._processInputParams(e), { shape: s, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Di && this._def.unknownKeys === "strip"))
      for (const u in i.data)
        a.includes(u) || o.push(u);
    const l = [];
    for (const u of a) {
      const h = s[u], f = i.data[u];
      l.push({
        key: { status: "valid", value: u },
        value: h._parse(new ei(i, f, i.path, u)),
        alwaysSet: u in i.data
      });
    }
    if (this._def.catchall instanceof Di) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const h of o)
          l.push({
            key: { status: "valid", value: h },
            value: { status: "valid", value: i.data[h] }
          });
      else if (u === "strict")
        o.length > 0 && (Ce(i, {
          code: se.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const h of o) {
        const f = i.data[h];
        l.push({
          key: { status: "valid", value: h },
          value: u._parse(
            new ei(i, f, i.path, h)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: h in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const h of l) {
        const f = await h.key;
        u.push({
          key: f,
          value: await h.value,
          alwaysSet: h.alwaysSet
        });
      }
      return u;
    }).then((u) => Ar.mergeObjectSync(n, u)) : Ar.mergeObjectSync(n, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return Me.errToObj, new Kt({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var i, s, a, o;
          const l = (a = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = Me.errToObj(e).message) !== null && o !== void 0 ? o : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new Kt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Kt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new Kt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new Kt({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: Ve.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new Kt({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return Ot.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new Kt({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return Ot.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new Kt({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return to(this);
  }
  partial(e) {
    const r = {};
    return Ot.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      e && !e[n] ? r[n] = i : r[n] = i.optional();
    }), new Kt({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return Ot.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let s = this.shape[n];
        for (; s instanceof Ii; )
          s = s._def.innerType;
        r[n] = s;
      }
    }), new Kt({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return y_(Ot.objectKeys(this.shape));
  }
}
Kt.create = (t, e) => new Kt({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Di.create(),
  typeName: Ve.ZodObject,
  ...ot(e)
});
Kt.strictCreate = (t, e) => new Kt({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Di.create(),
  typeName: Ve.ZodObject,
  ...ot(e)
});
Kt.lazycreate = (t, e) => new Kt({
  shape: t,
  unknownKeys: "strip",
  catchall: Di.create(),
  typeName: Ve.ZodObject,
  ...ot(e)
});
class Ya extends pt {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function i(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((o) => new Mn(o.ctx.common.issues));
      return Ce(r, {
        code: se.invalid_union,
        unionErrors: a
      }), Ye;
    }
    if (r.common.async)
      return Promise.all(n.map(async (s) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(i);
    {
      let s;
      const a = [];
      for (const l of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, h = l._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (h.status === "valid")
          return h;
        h.status === "dirty" && !s && (s = { result: h, ctx: u }), u.common.issues.length && a.push(u.common.issues);
      }
      if (s)
        return r.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((l) => new Mn(l));
      return Ce(r, {
        code: se.invalid_union,
        unionErrors: o
      }), Ye;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ya.create = (t, e) => new Ya({
  options: t,
  typeName: Ve.ZodUnion,
  ...ot(e)
});
const du = (t) => t instanceof Xa ? du(t.schema) : t instanceof Un ? du(t.innerType()) : t instanceof ec ? [t.value] : t instanceof Wi ? t.options : t instanceof tc ? Object.keys(t.enum) : t instanceof rc ? du(t._def.innerType) : t instanceof Ga ? [void 0] : t instanceof Za ? [null] : null;
class Al extends pt {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Oe.object)
      return Ce(r, {
        code: se.invalid_type,
        expected: Oe.object,
        received: r.parsedType
      }), Ye;
    const n = this.discriminator, i = r.data[n], s = this.optionsMap.get(i);
    return s ? r.common.async ? s._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : s._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (Ce(r, {
      code: se.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), Ye);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const i = /* @__PURE__ */ new Map();
    for (const s of r) {
      const a = du(s.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (i.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        i.set(o, s);
      }
    }
    return new Al({
      typeName: Ve.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: i,
      ...ot(n)
    });
  }
}
function vf(t, e) {
  const r = ji(t), n = ji(e);
  if (t === e)
    return { valid: !0, data: t };
  if (r === Oe.object && n === Oe.object) {
    const i = Ot.objectKeys(e), s = Ot.objectKeys(t).filter((o) => i.indexOf(o) !== -1), a = { ...t, ...e };
    for (const o of s) {
      const l = vf(t[o], e[o]);
      if (!l.valid)
        return { valid: !1 };
      a[o] = l.data;
    }
    return { valid: !0, data: a };
  } else if (r === Oe.array && n === Oe.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const i = [];
    for (let s = 0; s < t.length; s++) {
      const a = t[s], o = e[s], l = vf(a, o);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else
    return r === Oe.date && n === Oe.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Qa extends pt {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), i = (s, a) => {
      if (yf(s) || yf(a))
        return Ye;
      const o = vf(s.value, a.value);
      return o.valid ? ((mf(s) || mf(a)) && r.dirty(), { status: r.value, value: o.data }) : (Ce(n, {
        code: se.invalid_intersection_types
      }), Ye);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([s, a]) => i(s, a)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Qa.create = (t, e, r) => new Qa({
  left: t,
  right: e,
  typeName: Ve.ZodIntersection,
  ...ot(r)
});
class ti extends pt {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Oe.array)
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.array,
        received: n.parsedType
      }), Ye;
    if (n.data.length < this._def.items.length)
      return Ce(n, {
        code: se.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Ye;
    !this._def.rest && n.data.length > this._def.items.length && (Ce(n, {
      code: se.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const s = [...n.data].map((a, o) => {
      const l = this._def.items[o] || this._def.rest;
      return l ? l._parse(new ei(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(s).then((a) => Ar.mergeArray(r, a)) : Ar.mergeArray(r, s);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new ti({
      ...this._def,
      rest: e
    });
  }
}
ti.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ti({
    items: t,
    typeName: Ve.ZodTuple,
    rest: null,
    ...ot(e)
  });
};
class Ja extends pt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Oe.object)
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.object,
        received: n.parsedType
      }), Ye;
    const i = [], s = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      i.push({
        key: s._parse(new ei(n, o, n.path, o)),
        value: a._parse(new ei(n, n.data[o], n.path, o))
      });
    return n.common.async ? Ar.mergeObjectAsync(r, i) : Ar.mergeObjectSync(r, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof pt ? new Ja({
      keyType: e,
      valueType: r,
      typeName: Ve.ZodRecord,
      ...ot(n)
    }) : new Ja({
      keyType: Nn.create(),
      valueType: e,
      typeName: Ve.ZodRecord,
      ...ot(r)
    });
  }
}
class Zu extends pt {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Oe.map)
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.map,
        received: n.parsedType
      }), Ye;
    const i = this._def.keyType, s = this._def.valueType, a = [...n.data.entries()].map(([o, l], u) => ({
      key: i._parse(new ei(n, o, n.path, [u, "key"])),
      value: s._parse(new ei(n, l, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of a) {
          const u = await l.key, h = await l.value;
          if (u.status === "aborted" || h.status === "aborted")
            return Ye;
          (u.status === "dirty" || h.status === "dirty") && r.dirty(), o.set(u.value, h.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const l of a) {
        const u = l.key, h = l.value;
        if (u.status === "aborted" || h.status === "aborted")
          return Ye;
        (u.status === "dirty" || h.status === "dirty") && r.dirty(), o.set(u.value, h.value);
      }
      return { status: r.value, value: o };
    }
  }
}
Zu.create = (t, e, r) => new Zu({
  valueType: e,
  keyType: t,
  typeName: Ve.ZodMap,
  ...ot(r)
});
class Ds extends pt {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Oe.set)
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.set,
        received: n.parsedType
      }), Ye;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (Ce(n, {
      code: se.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (Ce(n, {
      code: se.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), r.dirty());
    const s = this._def.valueType;
    function a(l) {
      const u = /* @__PURE__ */ new Set();
      for (const h of l) {
        if (h.status === "aborted")
          return Ye;
        h.status === "dirty" && r.dirty(), u.add(h.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((l, u) => s._parse(new ei(n, l, n.path, u)));
    return n.common.async ? Promise.all(o).then((l) => a(l)) : a(o);
  }
  min(e, r) {
    return new Ds({
      ...this._def,
      minSize: { value: e, message: Me.toString(r) }
    });
  }
  max(e, r) {
    return new Ds({
      ...this._def,
      maxSize: { value: e, message: Me.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Ds.create = (t, e) => new Ds({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: Ve.ZodSet,
  ...ot(e)
});
class po extends pt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Oe.function)
      return Ce(r, {
        code: se.invalid_type,
        expected: Oe.function,
        received: r.parsedType
      }), Ye;
    function n(o, l) {
      return Ku({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Vu(),
          Ha
        ].filter((u) => !!u),
        issueData: {
          code: se.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function i(o, l) {
      return Ku({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Vu(),
          Ha
        ].filter((u) => !!u),
        issueData: {
          code: se.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const s = { errorMap: r.common.contextualErrorMap }, a = r.data;
    return this._def.returns instanceof xo ? Qr(async (...o) => {
      const l = new Mn([]), u = await this._def.args.parseAsync(o, s).catch((g) => {
        throw l.addIssue(n(o, g)), l;
      }), h = await a(...u);
      return await this._def.returns._def.type.parseAsync(h, s).catch((g) => {
        throw l.addIssue(i(h, g)), l;
      });
    }) : Qr((...o) => {
      const l = this._def.args.safeParse(o, s);
      if (!l.success)
        throw new Mn([n(o, l.error)]);
      const u = a(...l.data), h = this._def.returns.safeParse(u, s);
      if (!h.success)
        throw new Mn([i(u, h.error)]);
      return h.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new po({
      ...this._def,
      args: ti.create(e).rest(_s.create())
    });
  }
  returns(e) {
    return new po({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new po({
      args: e || ti.create([]).rest(_s.create()),
      returns: r || _s.create(),
      typeName: Ve.ZodFunction,
      ...ot(n)
    });
  }
}
class Xa extends pt {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
Xa.create = (t, e) => new Xa({
  getter: t,
  typeName: Ve.ZodLazy,
  ...ot(e)
});
class ec extends pt {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return Ce(r, {
        received: r.data,
        code: se.invalid_literal,
        expected: this._def.value
      }), Ye;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
ec.create = (t, e) => new ec({
  value: t,
  typeName: Ve.ZodLiteral,
  ...ot(e)
});
function y_(t, e) {
  return new Wi({
    values: t,
    typeName: Ve.ZodEnum,
    ...ot(e)
  });
}
class Wi extends pt {
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return Ce(r, {
        expected: Ot.joinValues(n),
        received: r.parsedType,
        code: se.invalid_type
      }), Ye;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return Ce(r, {
        received: r.data,
        code: se.invalid_enum_value,
        options: n
      }), Ye;
    }
    return Qr(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e) {
    return Wi.create(e);
  }
  exclude(e) {
    return Wi.create(this.options.filter((r) => !e.includes(r)));
  }
}
Wi.create = y_;
class tc extends pt {
  _parse(e) {
    const r = Ot.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== Oe.string && n.parsedType !== Oe.number) {
      const i = Ot.objectValues(r);
      return Ce(n, {
        expected: Ot.joinValues(i),
        received: n.parsedType,
        code: se.invalid_type
      }), Ye;
    }
    if (r.indexOf(e.data) === -1) {
      const i = Ot.objectValues(r);
      return Ce(n, {
        received: n.data,
        code: se.invalid_enum_value,
        options: i
      }), Ye;
    }
    return Qr(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
tc.create = (t, e) => new tc({
  values: t,
  typeName: Ve.ZodNativeEnum,
  ...ot(e)
});
class xo extends pt {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Oe.promise && r.common.async === !1)
      return Ce(r, {
        code: se.invalid_type,
        expected: Oe.promise,
        received: r.parsedType
      }), Ye;
    const n = r.parsedType === Oe.promise ? r.data : Promise.resolve(r.data);
    return Qr(n.then((i) => this._def.type.parseAsync(i, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
xo.create = (t, e) => new xo({
  type: t,
  typeName: Ve.ZodPromise,
  ...ot(e)
});
class Un extends pt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ve.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), i = this._def.effect || null;
    if (i.type === "preprocess") {
      const a = i.transform(n.data);
      return n.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    const s = {
      addIssue: (a) => {
        Ce(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), i.type === "refinement") {
      const a = (o) => {
        const l = i.refinement(o, s);
        if (n.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? Ye : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? Ye : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Bu(a))
          return a;
        const o = i.transform(a.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => Bu(a) ? Promise.resolve(i.transform(a.value, s)).then((o) => ({ status: r.value, value: o })) : a);
    Ot.assertNever(i);
  }
}
Un.create = (t, e, r) => new Un({
  schema: t,
  typeName: Ve.ZodEffects,
  effect: e,
  ...ot(r)
});
Un.createWithPreprocess = (t, e, r) => new Un({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: Ve.ZodEffects,
  ...ot(r)
});
class Ii extends pt {
  _parse(e) {
    return this._getType(e) === Oe.undefined ? Qr(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ii.create = (t, e) => new Ii({
  innerType: t,
  typeName: Ve.ZodOptional,
  ...ot(e)
});
class Ts extends pt {
  _parse(e) {
    return this._getType(e) === Oe.null ? Qr(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ts.create = (t, e) => new Ts({
  innerType: t,
  typeName: Ve.ZodNullable,
  ...ot(e)
});
class rc extends pt {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === Oe.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
rc.create = (t, e) => new rc({
  innerType: t,
  typeName: Ve.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...ot(e)
});
class Yu extends pt {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Hu(i) ? i.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Mn(n.common.issues);
        }
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Mn(n.common.issues);
        }
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Yu.create = (t, e) => new Yu({
  innerType: t,
  typeName: Ve.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...ot(e)
});
class Qu extends pt {
  _parse(e) {
    if (this._getType(e) !== Oe.nan) {
      const n = this._getOrReturnCtx(e);
      return Ce(n, {
        code: se.invalid_type,
        expected: Oe.nan,
        received: n.parsedType
      }), Ye;
    }
    return { status: "valid", value: e.data };
  }
}
Qu.create = (t) => new Qu({
  typeName: Ve.ZodNaN,
  ...ot(t)
});
const wj = Symbol("zod_brand");
class m_ extends pt {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Mc extends pt {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? Ye : s.status === "dirty" ? (r.dirty(), g_(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? Ye : i.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new Mc({
      in: e,
      out: r,
      typeName: Ve.ZodPipeline
    });
  }
}
const v_ = (t, e = {}, r) => t ? Io.create().superRefine((n, i) => {
  var s, a;
  if (!t(n)) {
    const o = typeof e == "function" ? e(n) : e, l = (a = (s = o.fatal) !== null && s !== void 0 ? s : r) !== null && a !== void 0 ? a : !0, u = typeof o == "string" ? { message: o } : o;
    i.addIssue({ code: "custom", ...u, fatal: l });
  }
}) : Io.create(), _j = {
  object: Kt.lazycreate
};
var Ve;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline";
})(Ve || (Ve = {}));
const Ej = (t, e = {
  message: `Input not instance of ${t.name}`
}) => v_((r) => r instanceof t, e), b_ = Nn.create, w_ = Bi.create, Sj = Qu.create, Oj = Hi.create, __ = Wa.create, Ij = Cs.create, xj = Wu.create, Cj = Ga.create, Dj = Za.create, Tj = Io.create, Pj = _s.create, Rj = Di.create, Nj = Gu.create, Aj = jn.create, Lj = Kt.create, Mj = Kt.strictCreate, jj = Ya.create, kj = Al.create, Uj = Qa.create, $j = ti.create, Fj = Ja.create, qj = Zu.create, zj = Ds.create, Vj = po.create, Kj = Xa.create, Bj = ec.create, Hj = Wi.create, Wj = tc.create, Gj = xo.create, kv = Un.create, Zj = Ii.create, Yj = Ts.create, Qj = Un.createWithPreprocess, Jj = Mc.create, Xj = () => b_().optional(), ek = () => w_().optional(), tk = () => __().optional(), rk = {
  string: (t) => Nn.create({ ...t, coerce: !0 }),
  number: (t) => Bi.create({ ...t, coerce: !0 }),
  boolean: (t) => Wa.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => Hi.create({ ...t, coerce: !0 }),
  date: (t) => Cs.create({ ...t, coerce: !0 })
}, nk = Ye;
var Fn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Ha,
  setErrorMap: aj,
  getErrorMap: Vu,
  makeIssue: Ku,
  EMPTY_PATH: cj,
  addIssueToContext: Ce,
  ParseStatus: Ar,
  INVALID: Ye,
  DIRTY: g_,
  OK: Qr,
  isAborted: yf,
  isDirty: mf,
  isValid: Bu,
  isAsync: Hu,
  get util() {
    return Ot;
  },
  get objectUtil() {
    return gf;
  },
  ZodParsedType: Oe,
  getParsedType: ji,
  ZodType: pt,
  ZodString: Nn,
  ZodNumber: Bi,
  ZodBigInt: Hi,
  ZodBoolean: Wa,
  ZodDate: Cs,
  ZodSymbol: Wu,
  ZodUndefined: Ga,
  ZodNull: Za,
  ZodAny: Io,
  ZodUnknown: _s,
  ZodNever: Di,
  ZodVoid: Gu,
  ZodArray: jn,
  ZodObject: Kt,
  ZodUnion: Ya,
  ZodDiscriminatedUnion: Al,
  ZodIntersection: Qa,
  ZodTuple: ti,
  ZodRecord: Ja,
  ZodMap: Zu,
  ZodSet: Ds,
  ZodFunction: po,
  ZodLazy: Xa,
  ZodLiteral: ec,
  ZodEnum: Wi,
  ZodNativeEnum: tc,
  ZodPromise: xo,
  ZodEffects: Un,
  ZodTransformer: Un,
  ZodOptional: Ii,
  ZodNullable: Ts,
  ZodDefault: rc,
  ZodCatch: Yu,
  ZodNaN: Qu,
  BRAND: wj,
  ZodBranded: m_,
  ZodPipeline: Mc,
  custom: v_,
  Schema: pt,
  ZodSchema: pt,
  late: _j,
  get ZodFirstPartyTypeKind() {
    return Ve;
  },
  coerce: rk,
  any: Tj,
  array: Aj,
  bigint: Oj,
  boolean: __,
  date: Ij,
  discriminatedUnion: kj,
  effect: kv,
  enum: Hj,
  function: Vj,
  instanceof: Ej,
  intersection: Uj,
  lazy: Kj,
  literal: Bj,
  map: qj,
  nan: Sj,
  nativeEnum: Wj,
  never: Rj,
  null: Dj,
  nullable: Yj,
  number: w_,
  object: Lj,
  oboolean: tk,
  onumber: ek,
  optional: Zj,
  ostring: Xj,
  pipeline: Jj,
  preprocess: Qj,
  promise: Gj,
  record: Fj,
  set: zj,
  strictObject: Mj,
  string: b_,
  symbol: xj,
  transformer: kv,
  tuple: $j,
  undefined: Cj,
  union: jj,
  unknown: Pj,
  void: Nj,
  NEVER: nk,
  ZodIssueCode: se,
  quotelessJson: oj,
  ZodError: Mn
});
const jp = /^aleo1[a-z0-9]{58}$/i, ik = /^AViewKey1[a-z0-9]{44}$/i, sk = /^APrivateKey1[a-z0-9]{47}$/i, ok = /^at1[a-z0-9]{58}$/i, ak = /^\d+field$/, ck = /^\d+u32$/, uk = /^\d+u64$/, e$ = Fn.string().regex(jp), t$ = Fn.string().regex(ik), r$ = Fn.string().regex(sk), n$ = Fn.string().regex(ok), i$ = Fn.string().regex(ak), s$ = Fn.string().regex(ck), o$ = Fn.string().regex(uk);
var Uv;
(function(t) {
  t.Record = "record", t.OutputRecord = "outputRecord", t.Public = "public", t.Private = "private", t.Constant = "constant", t.Future = "future", t.ExternalRecord = "external_record";
})(Uv || (Uv = {}));
var bf;
(function(t) {
  t.Deploy = "Deploy", t.Execute = "Execute", t.Send = "Send", t.Receive = "Receive", t.Join = "Join", t.Split = "Split", t.Shield = "Shield", t.Unshield = "Unshield";
})(bf || (bf = {}));
var wf;
(function(t) {
  t.Creating = "Creating", t.Pending = "Pending", t.Settled = "Settled", t.Failed = "Failed";
})(wf || (wf = {}));
var _f;
(function(t) {
  t.Private = "Private", t.Public = "Public";
})(_f || (_f = {}));
var Ef;
(function(t) {
  t.AleoTestnet = "AleoTestnet", t.AleoMainnet = "AleoMainnet";
})(Ef || (Ef = {}));
var $v;
(function(t) {
  t[t.ALEO = 0] = "ALEO";
})($v || ($v = {}));
const a$ = Fn.nativeEnum(bf), c$ = Fn.nativeEnum(wf), u$ = Fn.nativeEnum(Ef), l$ = Fn.nativeEnum(_f);
var Sf = { exports: {} }, Xh, Fv;
function lk() {
  if (Fv)
    return Xh;
  Fv = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, s = n * 365.25;
  Xh = function(h, f) {
    f = f || {};
    var g = typeof h;
    if (g === "string" && h.length > 0)
      return a(h);
    if (g === "number" && isFinite(h))
      return f.long ? l(h) : o(h);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(h)
    );
  };
  function a(h) {
    if (h = String(h), !(h.length > 100)) {
      var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        h
      );
      if (f) {
        var g = parseFloat(f[1]), m = (f[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return g * s;
          case "weeks":
          case "week":
          case "w":
            return g * i;
          case "days":
          case "day":
          case "d":
            return g * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return g * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return g * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return g * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return g;
          default:
            return;
        }
      }
    }
  }
  function o(h) {
    var f = Math.abs(h);
    return f >= n ? Math.round(h / n) + "d" : f >= r ? Math.round(h / r) + "h" : f >= e ? Math.round(h / e) + "m" : f >= t ? Math.round(h / t) + "s" : h + "ms";
  }
  function l(h) {
    var f = Math.abs(h);
    return f >= n ? u(h, f, n, "day") : f >= r ? u(h, f, r, "hour") : f >= e ? u(h, f, e, "minute") : f >= t ? u(h, f, t, "second") : h + " ms";
  }
  function u(h, f, g, m) {
    var w = f >= g * 1.5;
    return Math.round(h / g) + " " + m + (w ? "s" : "");
  }
  return Xh;
}
function hk(t) {
  r.debug = r, r.default = r, r.coerce = l, r.disable = s, r.enable = i, r.enabled = a, r.humanize = lk(), r.destroy = u, Object.keys(t).forEach((h) => {
    r[h] = t[h];
  }), r.names = [], r.skips = [], r.formatters = {};
  function e(h) {
    let f = 0;
    for (let g = 0; g < h.length; g++)
      f = (f << 5) - f + h.charCodeAt(g), f |= 0;
    return r.colors[Math.abs(f) % r.colors.length];
  }
  r.selectColor = e;
  function r(h) {
    let f, g = null, m, w;
    function S(...x) {
      if (!S.enabled)
        return;
      const M = S, _ = Number(/* @__PURE__ */ new Date()), I = _ - (f || _);
      M.diff = I, M.prev = f, M.curr = _, f = _, x[0] = r.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let b = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (y, c) => {
        if (y === "%%")
          return "%";
        b++;
        const p = r.formatters[c];
        if (typeof p == "function") {
          const D = x[b];
          y = p.call(M, D), x.splice(b, 1), b--;
        }
        return y;
      }), r.formatArgs.call(M, x), (M.log || r.log).apply(M, x);
    }
    return S.namespace = h, S.useColors = r.useColors(), S.color = r.selectColor(h), S.extend = n, S.destroy = r.destroy, Object.defineProperty(S, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => g !== null ? g : (m !== r.namespaces && (m = r.namespaces, w = r.enabled(h)), w),
      set: (x) => {
        g = x;
      }
    }), typeof r.init == "function" && r.init(S), S;
  }
  function n(h, f) {
    const g = r(this.namespace + (typeof f > "u" ? ":" : f) + h);
    return g.log = this.log, g;
  }
  function i(h) {
    r.save(h), r.namespaces = h, r.names = [], r.skips = [];
    let f;
    const g = (typeof h == "string" ? h : "").split(/[\s,]+/), m = g.length;
    for (f = 0; f < m; f++)
      g[f] && (h = g[f].replace(/\*/g, ".*?"), h[0] === "-" ? r.skips.push(new RegExp("^" + h.slice(1) + "$")) : r.names.push(new RegExp("^" + h + "$")));
  }
  function s() {
    const h = [
      ...r.names.map(o),
      ...r.skips.map(o).map((f) => "-" + f)
    ].join(",");
    return r.enable(""), h;
  }
  function a(h) {
    if (h[h.length - 1] === "*")
      return !0;
    let f, g;
    for (f = 0, g = r.skips.length; f < g; f++)
      if (r.skips[f].test(h))
        return !1;
    for (f = 0, g = r.names.length; f < g; f++)
      if (r.names[f].test(h))
        return !0;
    return !1;
  }
  function o(h) {
    return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(h) {
    return h instanceof Error ? h.stack || h.message : h;
  }
  function u() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var dk = hk;
(function(t, e) {
  e.formatArgs = n, e.save = i, e.load = s, e.useColors = r, e.storage = a(), e.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const u = "color: " + this.color;
    l.splice(1, 0, u, "color: inherit");
    let h = 0, f = 0;
    l[0].replace(/%[a-zA-Z%]/g, (g) => {
      g !== "%%" && (h++, g === "%c" && (f = h));
    }), l.splice(f, 0, u);
  }
  e.log = console.debug || console.log || (() => {
  });
  function i(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = dk(e);
  const { formatters: o } = t.exports;
  o.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (u) {
      return "[UnexpectedJSONParseError]: " + u.message;
    }
  };
})(Sf, Sf.exports);
var fk = Sf.exports;
const pk = /* @__PURE__ */ dc(fk), E_ = pk("wallet:sdk");
E_.enabled = !0;
const h$ = (t, e) => {
  const r = _n(), { request: n, data: i, error: s, loading: a } = Ic({
    topic: (r == null ? void 0 : r.topic) ?? "",
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "requestSignature",
      params: {
        message: t,
        address: jp.test(e ?? "") ? e : void 0
      }
    }
  }), o = s ? s.message : i && i.error;
  return { requestSignature: () => {
    r && !a && (E_("useRequestSignature requesting...", [t, e]), n());
  }, response: i, loading: a, error: o };
};
var Of = { exports: {} }, da = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qv;
function gk() {
  return qv || (qv = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Zi, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), w = Symbol.iterator, S = "@@iterator";
    function x(j) {
      if (j === null || typeof j != "object")
        return null;
      var Q = w && j[w] || j[S];
      return typeof Q == "function" ? Q : null;
    }
    var M = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(j) {
      {
        for (var Q = arguments.length, ge = new Array(Q > 1 ? Q - 1 : 0), $e = 1; $e < Q; $e++)
          ge[$e - 1] = arguments[$e];
        I("error", j, ge);
      }
    }
    function I(j, Q, ge) {
      {
        var $e = M.ReactDebugCurrentFrame, mt = $e.getStackAddendum();
        mt !== "" && (Q += "%s", ge = ge.concat([mt]));
        var Ke = ge.map(function(gt) {
          return String(gt);
        });
        Ke.unshift("Warning: " + Q), Function.prototype.apply.call(console[j], console, Ke);
      }
    }
    var b = !1, E = !1, y = !1, c = !1, p = !1, D;
    D = Symbol.for("react.module.reference");
    function R(j) {
      return !!(typeof j == "string" || typeof j == "function" || j === n || j === s || p || j === i || j === u || j === h || c || j === m || b || E || y || typeof j == "object" && j !== null && (j.$$typeof === g || j.$$typeof === f || j.$$typeof === a || j.$$typeof === o || j.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      j.$$typeof === D || j.getModuleId !== void 0));
    }
    function k(j, Q, ge) {
      var $e = j.displayName;
      if ($e)
        return $e;
      var mt = Q.displayName || Q.name || "";
      return mt !== "" ? ge + "(" + mt + ")" : ge;
    }
    function B(j) {
      return j.displayName || "Context";
    }
    function W(j) {
      if (j == null)
        return null;
      if (typeof j.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof j == "function")
        return j.displayName || j.name || null;
      if (typeof j == "string")
        return j;
      switch (j) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case o:
            var Q = j;
            return B(Q) + ".Consumer";
          case a:
            var ge = j;
            return B(ge._context) + ".Provider";
          case l:
            return k(j, j.render, "ForwardRef");
          case f:
            var $e = j.displayName || null;
            return $e !== null ? $e : W(j.type) || "Memo";
          case g: {
            var mt = j, Ke = mt._payload, gt = mt._init;
            try {
              return W(gt(Ke));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var C = Object.assign, N = 0, G, z, $, q, U, V, re;
    function K() {
    }
    K.__reactDisabledLog = !0;
    function X() {
      {
        if (N === 0) {
          G = console.log, z = console.info, $ = console.warn, q = console.error, U = console.group, V = console.groupCollapsed, re = console.groupEnd;
          var j = {
            configurable: !0,
            enumerable: !0,
            value: K,
            writable: !0
          };
          Object.defineProperties(console, {
            info: j,
            log: j,
            warn: j,
            error: j,
            group: j,
            groupCollapsed: j,
            groupEnd: j
          });
        }
        N++;
      }
    }
    function Y() {
      {
        if (N--, N === 0) {
          var j = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: C({}, j, {
              value: G
            }),
            info: C({}, j, {
              value: z
            }),
            warn: C({}, j, {
              value: $
            }),
            error: C({}, j, {
              value: q
            }),
            group: C({}, j, {
              value: U
            }),
            groupCollapsed: C({}, j, {
              value: V
            }),
            groupEnd: C({}, j, {
              value: re
            })
          });
        }
        N < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ee = M.ReactCurrentDispatcher, L;
    function A(j, Q, ge) {
      {
        if (L === void 0)
          try {
            throw Error();
          } catch (mt) {
            var $e = mt.stack.trim().match(/\n( *(at )?)/);
            L = $e && $e[1] || "";
          }
        return `
` + L + j;
      }
    }
    var T = !1, d;
    {
      var O = typeof WeakMap == "function" ? WeakMap : Map;
      d = new O();
    }
    function H(j, Q) {
      if (!j || T)
        return "";
      {
        var ge = d.get(j);
        if (ge !== void 0)
          return ge;
      }
      var $e;
      T = !0;
      var mt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ke;
      Ke = ee.current, ee.current = null, X();
      try {
        if (Q) {
          var gt = function() {
            throw Error();
          };
          if (Object.defineProperty(gt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(gt, []);
            } catch (cn) {
              $e = cn;
            }
            Reflect.construct(j, [], gt);
          } else {
            try {
              gt.call();
            } catch (cn) {
              $e = cn;
            }
            j.call(gt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (cn) {
            $e = cn;
          }
          j();
        }
      } catch (cn) {
        if (cn && $e && typeof cn.stack == "string") {
          for (var ut = cn.stack.split(`
`), Jt = $e.stack.split(`
`), Lt = ut.length - 1, kt = Jt.length - 1; Lt >= 1 && kt >= 0 && ut[Lt] !== Jt[kt]; )
            kt--;
          for (; Lt >= 1 && kt >= 0; Lt--, kt--)
            if (ut[Lt] !== Jt[kt]) {
              if (Lt !== 1 || kt !== 1)
                do
                  if (Lt--, kt--, kt < 0 || ut[Lt] !== Jt[kt]) {
                    var Ct = `
` + ut[Lt].replace(" at new ", " at ");
                    return j.displayName && Ct.includes("<anonymous>") && (Ct = Ct.replace("<anonymous>", j.displayName)), typeof j == "function" && d.set(j, Ct), Ct;
                  }
                while (Lt >= 1 && kt >= 0);
              break;
            }
        }
      } finally {
        T = !1, ee.current = Ke, Y(), Error.prepareStackTrace = mt;
      }
      var qn = j ? j.displayName || j.name : "", Fs = qn ? A(qn) : "";
      return typeof j == "function" && d.set(j, Fs), Fs;
    }
    function Z(j, Q, ge) {
      return H(j, !1);
    }
    function me(j) {
      var Q = j.prototype;
      return !!(Q && Q.isReactComponent);
    }
    function we(j, Q, ge) {
      if (j == null)
        return "";
      if (typeof j == "function")
        return H(j, me(j));
      if (typeof j == "string")
        return A(j);
      switch (j) {
        case u:
          return A("Suspense");
        case h:
          return A("SuspenseList");
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case l:
            return Z(j.render);
          case f:
            return we(j.type, Q, ge);
          case g: {
            var $e = j, mt = $e._payload, Ke = $e._init;
            try {
              return we(Ke(mt), Q, ge);
            } catch {
            }
          }
        }
      return "";
    }
    var ye = Object.prototype.hasOwnProperty, De = {}, He = M.ReactDebugCurrentFrame;
    function Ue(j) {
      if (j) {
        var Q = j._owner, ge = we(j.type, j._source, Q ? Q.type : null);
        He.setExtraStackFrame(ge);
      } else
        He.setExtraStackFrame(null);
    }
    function _e(j, Q, ge, $e, mt) {
      {
        var Ke = Function.call.bind(ye);
        for (var gt in j)
          if (Ke(j, gt)) {
            var ut = void 0;
            try {
              if (typeof j[gt] != "function") {
                var Jt = Error(($e || "React class") + ": " + ge + " type `" + gt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof j[gt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Jt.name = "Invariant Violation", Jt;
              }
              ut = j[gt](Q, gt, $e, ge, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Lt) {
              ut = Lt;
            }
            ut && !(ut instanceof Error) && (Ue(mt), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $e || "React class", ge, gt, typeof ut), Ue(null)), ut instanceof Error && !(ut.message in De) && (De[ut.message] = !0, Ue(mt), _("Failed %s type: %s", ge, ut.message), Ue(null));
          }
      }
    }
    var be = Array.isArray;
    function de(j) {
      return be(j);
    }
    function fe(j) {
      {
        var Q = typeof Symbol == "function" && Symbol.toStringTag, ge = Q && j[Symbol.toStringTag] || j.constructor.name || "Object";
        return ge;
      }
    }
    function ue(j) {
      try {
        return ae(j), !1;
      } catch {
        return !0;
      }
    }
    function ae(j) {
      return "" + j;
    }
    function oe(j) {
      if (ue(j))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", fe(j)), ae(j);
    }
    var te = M.ReactCurrentOwner, pe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ve, ne, Ee;
    Ee = {};
    function Ie(j) {
      if (ye.call(j, "ref")) {
        var Q = Object.getOwnPropertyDescriptor(j, "ref").get;
        if (Q && Q.isReactWarning)
          return !1;
      }
      return j.ref !== void 0;
    }
    function Pe(j) {
      if (ye.call(j, "key")) {
        var Q = Object.getOwnPropertyDescriptor(j, "key").get;
        if (Q && Q.isReactWarning)
          return !1;
      }
      return j.key !== void 0;
    }
    function Re(j, Q) {
      if (typeof j.ref == "string" && te.current && Q && te.current.stateNode !== Q) {
        var ge = W(te.current.type);
        Ee[ge] || (_('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(te.current.type), j.ref), Ee[ge] = !0);
      }
    }
    function Te(j, Q) {
      {
        var ge = function() {
          ve || (ve = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        ge.isReactWarning = !0, Object.defineProperty(j, "key", {
          get: ge,
          configurable: !0
        });
      }
    }
    function At(j, Q) {
      {
        var ge = function() {
          ne || (ne = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        ge.isReactWarning = !0, Object.defineProperty(j, "ref", {
          get: ge,
          configurable: !0
        });
      }
    }
    var Ft = function(j, Q, ge, $e, mt, Ke, gt) {
      var ut = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: j,
        key: Q,
        ref: ge,
        props: gt,
        // Record the component responsible for creating this element.
        _owner: Ke
      };
      return ut._store = {}, Object.defineProperty(ut._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ut, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $e
      }), Object.defineProperty(ut, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: mt
      }), Object.freeze && (Object.freeze(ut.props), Object.freeze(ut)), ut;
    };
    function Qt(j, Q, ge, $e, mt) {
      {
        var Ke, gt = {}, ut = null, Jt = null;
        ge !== void 0 && (oe(ge), ut = "" + ge), Pe(Q) && (oe(Q.key), ut = "" + Q.key), Ie(Q) && (Jt = Q.ref, Re(Q, mt));
        for (Ke in Q)
          ye.call(Q, Ke) && !pe.hasOwnProperty(Ke) && (gt[Ke] = Q[Ke]);
        if (j && j.defaultProps) {
          var Lt = j.defaultProps;
          for (Ke in Lt)
            gt[Ke] === void 0 && (gt[Ke] = Lt[Ke]);
        }
        if (ut || Jt) {
          var kt = typeof j == "function" ? j.displayName || j.name || "Unknown" : j;
          ut && Te(gt, kt), Jt && At(gt, kt);
        }
        return Ft(j, ut, Jt, mt, $e, te.current, gt);
      }
    }
    var It = M.ReactCurrentOwner, er = M.ReactDebugCurrentFrame;
    function tr(j) {
      if (j) {
        var Q = j._owner, ge = we(j.type, j._source, Q ? Q.type : null);
        er.setExtraStackFrame(ge);
      } else
        er.setExtraStackFrame(null);
    }
    var an;
    an = !1;
    function We(j) {
      return typeof j == "object" && j !== null && j.$$typeof === e;
    }
    function Fe() {
      {
        if (It.current) {
          var j = W(It.current.type);
          if (j)
            return `

Check the render method of \`` + j + "`.";
        }
        return "";
      }
    }
    function Qe(j) {
      {
        if (j !== void 0) {
          var Q = j.fileName.replace(/^.*[\\\/]/, ""), ge = j.lineNumber;
          return `

Check your code at ` + Q + ":" + ge + ".";
        }
        return "";
      }
    }
    var Ze = {};
    function Je(j) {
      {
        var Q = Fe();
        if (!Q) {
          var ge = typeof j == "string" ? j : j.displayName || j.name;
          ge && (Q = `

Check the top-level render call using <` + ge + ">.");
        }
        return Q;
      }
    }
    function qe(j, Q) {
      {
        if (!j._store || j._store.validated || j.key != null)
          return;
        j._store.validated = !0;
        var ge = Je(Q);
        if (Ze[ge])
          return;
        Ze[ge] = !0;
        var $e = "";
        j && j._owner && j._owner !== It.current && ($e = " It was passed a child from " + W(j._owner.type) + "."), tr(j), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ge, $e), tr(null);
      }
    }
    function at(j, Q) {
      {
        if (typeof j != "object")
          return;
        if (de(j))
          for (var ge = 0; ge < j.length; ge++) {
            var $e = j[ge];
            We($e) && qe($e, Q);
          }
        else if (We(j))
          j._store && (j._store.validated = !0);
        else if (j) {
          var mt = x(j);
          if (typeof mt == "function" && mt !== j.entries)
            for (var Ke = mt.call(j), gt; !(gt = Ke.next()).done; )
              We(gt.value) && qe(gt.value, Q);
        }
      }
    }
    function lt(j) {
      {
        var Q = j.type;
        if (Q == null || typeof Q == "string")
          return;
        var ge;
        if (typeof Q == "function")
          ge = Q.propTypes;
        else if (typeof Q == "object" && (Q.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Q.$$typeof === f))
          ge = Q.propTypes;
        else
          return;
        if (ge) {
          var $e = W(Q);
          _e(ge, j.props, "prop", $e, j);
        } else if (Q.PropTypes !== void 0 && !an) {
          an = !0;
          var mt = W(Q);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", mt || "Unknown");
        }
        typeof Q.getDefaultProps == "function" && !Q.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ht(j) {
      {
        for (var Q = Object.keys(j.props), ge = 0; ge < Q.length; ge++) {
          var $e = Q[ge];
          if ($e !== "children" && $e !== "key") {
            tr(j), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", $e), tr(null);
            break;
          }
        }
        j.ref !== null && (tr(j), _("Invalid attribute `ref` supplied to `React.Fragment`."), tr(null));
      }
    }
    function ct(j, Q, ge, $e, mt, Ke) {
      {
        var gt = R(j);
        if (!gt) {
          var ut = "";
          (j === void 0 || typeof j == "object" && j !== null && Object.keys(j).length === 0) && (ut += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Jt = Qe(mt);
          Jt ? ut += Jt : ut += Fe();
          var Lt;
          j === null ? Lt = "null" : de(j) ? Lt = "array" : j !== void 0 && j.$$typeof === e ? (Lt = "<" + (W(j.type) || "Unknown") + " />", ut = " Did you accidentally export a JSX literal instead of a component?") : Lt = typeof j, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Lt, ut);
        }
        var kt = Qt(j, Q, ge, mt, Ke);
        if (kt == null)
          return kt;
        if (gt) {
          var Ct = Q.children;
          if (Ct !== void 0)
            if ($e)
              if (de(Ct)) {
                for (var qn = 0; qn < Ct.length; qn++)
                  at(Ct[qn], j);
                Object.freeze && Object.freeze(Ct);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              at(Ct, j);
        }
        return j === n ? ht(kt) : lt(kt), kt;
      }
    }
    function dt(j, Q, ge) {
      return ct(j, Q, ge, !0);
    }
    function it(j, Q, ge) {
      return ct(j, Q, ge, !1);
    }
    var Xe = it, je = dt;
    da.Fragment = n, da.jsx = Xe, da.jsxs = je;
  }()), da;
}
var fa = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zv;
function yk() {
  if (zv)
    return fa;
  zv = 1;
  var t = Zi, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, l, u) {
    var h, f = {}, g = null, m = null;
    u !== void 0 && (g = "" + u), l.key !== void 0 && (g = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (h in l)
      n.call(l, h) && !s.hasOwnProperty(h) && (f[h] = l[h]);
    if (o && o.defaultProps)
      for (h in l = o.defaultProps, l)
        f[h] === void 0 && (f[h] = l[h]);
    return { $$typeof: e, type: o, key: g, ref: m, props: f, _owner: i.current };
  }
  return fa.Fragment = r, fa.jsx = a, fa.jsxs = a, fa;
}
process.env.NODE_ENV === "production" ? Of.exports = yk() : Of.exports = gk();
var Vv = Of.exports, tt = {
  context: void 0,
  registry: void 0
};
function _a(t) {
  tt.context = t;
}
var mk = (t, e) => t === e, Ju = Symbol("solid-proxy"), S_ = Symbol("solid-track"), Xu = {
  equals: mk
}, O_ = P_, Ti = 1, el = 2, I_ = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
}, ed = {}, Et = null, td = null, xt = null, Rr = null, xi = null, Ll = 0, [vk, d$] = /* @__PURE__ */ Kr(!1);
function Es(t, e) {
  const r = xt, n = Et, i = t.length === 0, s = e === void 0 ? n : e, a = i ? I_ : {
    owned: null,
    cleanups: null,
    context: s ? s.context : null,
    owner: s
  }, o = i ? t : () => t(() => lr(() => jl(a)));
  Et = a, xt = null;
  try {
    return ri(o, !0);
  } finally {
    xt = r, Et = n;
  }
}
function Kr(t, e) {
  e = e ? Object.assign({}, Xu, e) : Xu;
  const r = {
    value: t,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, n = (i) => (typeof i == "function" && (i = i(r.value)), T_(r, i));
  return [D_.bind(r), n];
}
function Kv(t, e, r) {
  const n = Ml(t, e, !0, Ti);
  qo(n);
}
function Ss(t, e, r) {
  const n = Ml(t, e, !1, Ti);
  qo(n);
}
function x_(t, e, r) {
  O_ = xk;
  const n = Ml(t, e, !1, Ti);
  (!r || !r.render) && (n.user = !0), xi ? xi.push(n) : qo(n);
}
function on(t, e, r) {
  r = r ? Object.assign({}, Xu, r) : Xu;
  const n = Ml(t, e, !0, 0);
  return n.observers = null, n.observerSlots = null, n.comparator = r.equals || void 0, qo(n), D_.bind(n);
}
function Bv(t) {
  return t && typeof t == "object" && "then" in t;
}
function bk(t, e, r) {
  let n, i, s;
  arguments.length === 2 && typeof e == "object" || arguments.length === 1 ? (n = !0, i = t, s = e || {}) : (n = t, i = e, s = r || {});
  let a = null, o = ed, l = null, u = !1, h = "initialValue" in s, f = typeof n == "function" && on(n);
  const g = /* @__PURE__ */ new Set(), [m, w] = (s.storage || Kr)(s.initialValue), [S, x] = Kr(void 0), [M, _] = Kr(void 0, {
    equals: !1
  }), [I, b] = Kr(h ? "ready" : "unresolved");
  if (tt.context) {
    l = `${tt.context.id}${tt.context.count++}`;
    let D;
    s.ssrLoadFrom === "initial" ? o = s.initialValue : tt.load && (D = tt.load(l)) && (o = Bv(D) && "value" in D ? D.value : D);
  }
  function E(D, R, k, B) {
    return a === D && (a = null, B !== void 0 && (h = !0), (D === o || R === o) && s.onHydrated && queueMicrotask(
      () => s.onHydrated(B, {
        value: R
      })
    ), o = ed, y(R, k)), R;
  }
  function y(D, R) {
    ri(() => {
      R === void 0 && w(() => D), b(R !== void 0 ? "errored" : h ? "ready" : "unresolved"), x(R);
      for (const k of g.keys())
        k.decrement();
      g.clear();
    }, !1);
  }
  function c() {
    const D = Sk, R = m(), k = S();
    if (k !== void 0 && !a)
      throw k;
    return xt && !xt.user && D && Kv(() => {
      M(), a && (D.resolved || g.has(D) || (D.increment(), g.add(D)));
    }), R;
  }
  function p(D = !0) {
    if (D !== !1 && u)
      return;
    u = !1;
    const R = f ? f() : n;
    if (R == null || R === !1) {
      E(a, lr(m));
      return;
    }
    const k = o !== ed ? o : lr(
      () => i(R, {
        value: m(),
        refetching: D
      })
    );
    return Bv(k) ? (a = k, u = !0, queueMicrotask(() => u = !1), ri(() => {
      b(h ? "refreshing" : "pending"), _();
    }, !1), k.then(
      (B) => E(k, B, void 0, R),
      (B) => E(k, void 0, N_(B), R)
    )) : (E(a, k, void 0, R), k);
  }
  return Object.defineProperties(c, {
    state: {
      get: () => I()
    },
    error: {
      get: () => S()
    },
    loading: {
      get() {
        const D = I();
        return D === "pending" || D === "refreshing";
      }
    },
    latest: {
      get() {
        if (!h)
          return c();
        const D = S();
        if (D && !a)
          throw D;
        return m();
      }
    }
  }), f ? Kv(() => p(!1)) : p(!1), [
    c,
    {
      refetch: p,
      mutate: w
    }
  ];
}
function f$(t) {
  return ri(t, !1);
}
function lr(t) {
  if (xt === null)
    return t();
  const e = xt;
  xt = null;
  try {
    return t();
  } finally {
    xt = e;
  }
}
function p$(t, e, r) {
  const n = Array.isArray(t);
  let i, s = r && r.defer;
  return (a) => {
    let o;
    if (n) {
      o = Array(t.length);
      for (let u = 0; u < t.length; u++)
        o[u] = t[u]();
    } else
      o = t();
    if (s) {
      s = !1;
      return;
    }
    const l = lr(() => e(o, i, a));
    return i = o, l;
  };
}
function wk(t) {
  x_(() => lr(t));
}
function nc(t) {
  return Et === null || (Et.cleanups === null ? Et.cleanups = [t] : Et.cleanups.push(t)), t;
}
function g$() {
  return xt;
}
function Hv() {
  return Et;
}
function _k(t, e) {
  const r = Et, n = xt;
  Et = t, xt = null;
  try {
    return ri(e, !0);
  } catch (i) {
    kp(i);
  } finally {
    Et = r, xt = n;
  }
}
function Ek(t) {
  const e = xt, r = Et;
  return Promise.resolve().then(() => {
    xt = e, Et = r;
    let n;
    return ri(t, !1), xt = Et = null, n ? n.done : void 0;
  });
}
function y$() {
  return [vk, Ek];
}
function m$(t, e) {
  const r = Symbol("context");
  return {
    id: r,
    Provider: Ck(r),
    defaultValue: t
  };
}
function v$(t) {
  return Et && Et.context && Et.context[t.id] !== void 0 ? Et.context[t.id] : t.defaultValue;
}
function C_(t) {
  const e = on(t), r = on(() => If(e()));
  return r.toArray = () => {
    const n = r();
    return Array.isArray(n) ? n : n != null ? [n] : [];
  }, r;
}
var Sk;
function D_() {
  if (this.sources && this.state)
    if (this.state === Ti)
      qo(this);
    else {
      const t = Rr;
      Rr = null, ri(() => rl(this), !1), Rr = t;
    }
  if (xt) {
    const t = this.observers ? this.observers.length : 0;
    xt.sources ? (xt.sources.push(this), xt.sourceSlots.push(t)) : (xt.sources = [this], xt.sourceSlots = [t]), this.observers ? (this.observers.push(xt), this.observerSlots.push(xt.sources.length - 1)) : (this.observers = [xt], this.observerSlots = [xt.sources.length - 1]);
  }
  return this.value;
}
function T_(t, e, r) {
  let n = t.value;
  return (!t.comparator || !t.comparator(n, e)) && (t.value = e, t.observers && t.observers.length && ri(() => {
    for (let i = 0; i < t.observers.length; i += 1) {
      const s = t.observers[i], a = td && td.running;
      a && td.disposed.has(s), (a ? !s.tState : !s.state) && (s.pure ? Rr.push(s) : xi.push(s), s.observers && R_(s)), a || (s.state = Ti);
    }
    if (Rr.length > 1e6)
      throw Rr = [], new Error();
  }, !1)), e;
}
function qo(t) {
  if (!t.fn)
    return;
  jl(t);
  const e = Et, r = xt, n = Ll;
  xt = Et = t, Ok(
    t,
    t.value,
    n
  ), xt = r, Et = e;
}
function Ok(t, e, r) {
  let n;
  try {
    n = t.fn(e);
  } catch (i) {
    return t.pure && (t.state = Ti, t.owned && t.owned.forEach(jl), t.owned = null), t.updatedAt = r + 1, kp(i);
  }
  (!t.updatedAt || t.updatedAt <= r) && (t.updatedAt != null && "observers" in t ? T_(t, n) : t.value = n, t.updatedAt = r);
}
function Ml(t, e, r, n = Ti, i) {
  const s = {
    fn: t,
    state: n,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: Et,
    context: Et ? Et.context : null,
    pure: r
  };
  return Et === null || Et !== I_ && (Et.owned ? Et.owned.push(s) : Et.owned = [s]), s;
}
function tl(t) {
  if (t.state === 0)
    return;
  if (t.state === el)
    return rl(t);
  if (t.suspense && lr(t.suspense.inFallback))
    return t.suspense.effects.push(t);
  const e = [t];
  for (; (t = t.owner) && (!t.updatedAt || t.updatedAt < Ll); )
    t.state && e.push(t);
  for (let r = e.length - 1; r >= 0; r--)
    if (t = e[r], t.state === Ti)
      qo(t);
    else if (t.state === el) {
      const n = Rr;
      Rr = null, ri(() => rl(t, e[0]), !1), Rr = n;
    }
}
function ri(t, e) {
  if (Rr)
    return t();
  let r = !1;
  e || (Rr = []), xi ? r = !0 : xi = [], Ll++;
  try {
    const n = t();
    return Ik(r), n;
  } catch (n) {
    r || (xi = null), Rr = null, kp(n);
  }
}
function Ik(t) {
  if (Rr && (P_(Rr), Rr = null), t)
    return;
  const e = xi;
  xi = null, e.length && ri(() => O_(e), !1);
}
function P_(t) {
  for (let e = 0; e < t.length; e++)
    tl(t[e]);
}
function xk(t) {
  let e, r = 0;
  for (e = 0; e < t.length; e++) {
    const n = t[e];
    n.user ? t[r++] = n : tl(n);
  }
  if (tt.context) {
    if (tt.count) {
      tt.effects || (tt.effects = []), tt.effects.push(...t.slice(0, r));
      return;
    } else
      tt.effects && (t = [...tt.effects, ...t], r += tt.effects.length, delete tt.effects);
    _a();
  }
  for (e = 0; e < r; e++)
    tl(t[e]);
}
function rl(t, e) {
  t.state = 0;
  for (let r = 0; r < t.sources.length; r += 1) {
    const n = t.sources[r];
    if (n.sources) {
      const i = n.state;
      i === Ti ? n !== e && (!n.updatedAt || n.updatedAt < Ll) && tl(n) : i === el && rl(n, e);
    }
  }
}
function R_(t) {
  for (let e = 0; e < t.observers.length; e += 1) {
    const r = t.observers[e];
    r.state || (r.state = el, r.pure ? Rr.push(r) : xi.push(r), r.observers && R_(r));
  }
}
function jl(t) {
  let e;
  if (t.sources)
    for (; t.sources.length; ) {
      const r = t.sources.pop(), n = t.sourceSlots.pop(), i = r.observers;
      if (i && i.length) {
        const s = i.pop(), a = r.observerSlots.pop();
        n < i.length && (s.sourceSlots[a] = n, i[n] = s, r.observerSlots[n] = a);
      }
    }
  if (t.owned) {
    for (e = t.owned.length - 1; e >= 0; e--)
      jl(t.owned[e]);
    t.owned = null;
  }
  if (t.cleanups) {
    for (e = t.cleanups.length - 1; e >= 0; e--)
      t.cleanups[e]();
    t.cleanups = null;
  }
  t.state = 0;
}
function N_(t) {
  return t instanceof Error ? t : new Error(typeof t == "string" ? t : "Unknown error", {
    cause: t
  });
}
function kp(t, e = Et) {
  throw N_(t);
}
function If(t) {
  if (typeof t == "function" && !t.length)
    return If(t());
  if (Array.isArray(t)) {
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const n = If(t[r]);
      Array.isArray(n) ? e.push.apply(e, n) : e.push(n);
    }
    return e;
  }
  return t;
}
function Ck(t, e) {
  return function(n) {
    let i;
    return Ss(
      () => i = lr(() => (Et.context = {
        ...Et.context,
        [t]: n.value
      }, C_(() => n.children))),
      void 0
    ), i;
  };
}
var xf = Symbol("fallback");
function nl(t) {
  for (let e = 0; e < t.length; e++)
    t[e]();
}
function Dk(t, e, r = {}) {
  let n = [], i = [], s = [], a = 0, o = e.length > 1 ? [] : null;
  return nc(() => nl(s)), () => {
    let l = t() || [], u, h;
    return l[S_], lr(() => {
      let g = l.length, m, w, S, x, M, _, I, b, E;
      if (g === 0)
        a !== 0 && (nl(s), s = [], n = [], i = [], a = 0, o && (o = [])), r.fallback && (n = [xf], i[0] = Es((y) => (s[0] = y, r.fallback())), a = 1);
      else if (a === 0) {
        for (i = new Array(g), h = 0; h < g; h++)
          n[h] = l[h], i[h] = Es(f);
        a = g;
      } else {
        for (S = new Array(g), x = new Array(g), o && (M = new Array(g)), _ = 0, I = Math.min(a, g); _ < I && n[_] === l[_]; _++)
          ;
        for (I = a - 1, b = g - 1; I >= _ && b >= _ && n[I] === l[b]; I--, b--)
          S[b] = i[I], x[b] = s[I], o && (M[b] = o[I]);
        for (m = /* @__PURE__ */ new Map(), w = new Array(b + 1), h = b; h >= _; h--)
          E = l[h], u = m.get(E), w[h] = u === void 0 ? -1 : u, m.set(E, h);
        for (u = _; u <= I; u++)
          E = n[u], h = m.get(E), h !== void 0 && h !== -1 ? (S[h] = i[u], x[h] = s[u], o && (M[h] = o[u]), h = w[h], m.set(E, h)) : s[u]();
        for (h = _; h < g; h++)
          h in S ? (i[h] = S[h], s[h] = x[h], o && (o[h] = M[h], o[h](h))) : i[h] = Es(f);
        i = i.slice(0, a = g), n = l.slice(0);
      }
      return i;
    });
    function f(g) {
      if (s[h] = g, o) {
        const [m, w] = Kr(h);
        return o[h] = w, e(l[h], m);
      }
      return e(l[h]);
    }
  };
}
function Tk(t, e, r = {}) {
  let n = [], i = [], s = [], a = [], o = 0, l;
  return nc(() => nl(s)), () => {
    const u = t() || [];
    return u[S_], lr(() => {
      if (u.length === 0)
        return o !== 0 && (nl(s), s = [], n = [], i = [], o = 0, a = []), r.fallback && (n = [xf], i[0] = Es((f) => (s[0] = f, r.fallback())), o = 1), i;
      for (n[0] === xf && (s[0](), s = [], n = [], i = [], o = 0), l = 0; l < u.length; l++)
        l < n.length && n[l] !== u[l] ? a[l](() => u[l]) : l >= n.length && (i[l] = Es(h));
      for (; l < n.length; l++)
        s[l]();
      return o = a.length = s.length = u.length, n = u.slice(0), i = i.slice(0, o);
    });
    function h(f) {
      s[l] = f;
      const [g, m] = Kr(u[l]);
      return a[l] = m, e(g, l);
    }
  };
}
function Pk(t, e) {
  return lr(() => t(e || {}));
}
function Qc() {
  return !0;
}
var Cf = {
  get(t, e, r) {
    return e === Ju ? r : t.get(e);
  },
  has(t, e) {
    return e === Ju ? !0 : t.has(e);
  },
  set: Qc,
  deleteProperty: Qc,
  getOwnPropertyDescriptor(t, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return t.get(e);
      },
      set: Qc,
      deleteProperty: Qc
    };
  },
  ownKeys(t) {
    return t.keys();
  }
};
function rd(t) {
  return (t = typeof t == "function" ? t() : t) ? t : {};
}
function Rk() {
  for (let t = 0, e = this.length; t < e; ++t) {
    const r = this[t]();
    if (r !== void 0)
      return r;
  }
}
function Nk(...t) {
  let e = !1;
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    e = e || !!a && Ju in a, t[s] = typeof a == "function" ? (e = !0, on(a)) : a;
  }
  if (e)
    return new Proxy(
      {
        get(s) {
          for (let a = t.length - 1; a >= 0; a--) {
            const o = rd(t[a])[s];
            if (o !== void 0)
              return o;
          }
        },
        has(s) {
          for (let a = t.length - 1; a >= 0; a--)
            if (s in rd(t[a]))
              return !0;
          return !1;
        },
        keys() {
          const s = [];
          for (let a = 0; a < t.length; a++)
            s.push(...Object.keys(rd(t[a])));
          return [...new Set(s)];
        }
      },
      Cf
    );
  const r = {}, n = {}, i = /* @__PURE__ */ new Set();
  for (let s = t.length - 1; s >= 0; s--) {
    const a = t[s];
    if (!a)
      continue;
    const o = Object.getOwnPropertyNames(a);
    for (let l = 0, u = o.length; l < u; l++) {
      const h = o[l];
      if (h === "__proto__" || h === "constructor")
        continue;
      const f = Object.getOwnPropertyDescriptor(a, h);
      if (!i.has(h))
        f.get ? (i.add(h), Object.defineProperty(r, h, {
          enumerable: !0,
          configurable: !0,
          get: Rk.bind(n[h] = [f.get.bind(a)])
        })) : (f.value !== void 0 && i.add(h), r[h] = f.value);
      else {
        const g = n[h];
        g ? f.get ? g.push(f.get.bind(a)) : f.value !== void 0 && g.push(() => f.value) : r[h] === void 0 && (r[h] = f.value);
      }
    }
  }
  return r;
}
function Ak(t, ...e) {
  if (Ju in t) {
    const i = new Set(e.length > 1 ? e.flat() : e[0]), s = e.map((a) => new Proxy(
      {
        get(o) {
          return a.includes(o) ? t[o] : void 0;
        },
        has(o) {
          return a.includes(o) && o in t;
        },
        keys() {
          return a.filter((o) => o in t);
        }
      },
      Cf
    ));
    return s.push(
      new Proxy(
        {
          get(a) {
            return i.has(a) ? void 0 : t[a];
          },
          has(a) {
            return i.has(a) ? !1 : a in t;
          },
          keys() {
            return Object.keys(t).filter((a) => !i.has(a));
          }
        },
        Cf
      )
    ), s;
  }
  const r = {}, n = e.map(() => ({}));
  for (const i of Object.getOwnPropertyNames(t)) {
    const s = Object.getOwnPropertyDescriptor(t, i), a = !s.get && !s.set && s.enumerable && s.writable && s.configurable;
    let o = !1, l = 0;
    for (const u of e)
      u.includes(i) && (o = !0, a ? n[l][i] = s.value : Object.defineProperty(n[l], i, s)), ++l;
    o || (a ? r[i] = s.value : Object.defineProperty(r, i, s));
  }
  return [...n, r];
}
function Lk(t) {
  let e, r;
  const n = (i) => {
    const s = tt.context;
    if (s) {
      const [o, l] = Kr();
      tt.count || (tt.count = 0), tt.count++, (r || (r = t())).then((u) => {
        _a(s), tt.count--, l(() => u.default), _a();
      }), e = o;
    } else if (!e) {
      const [o] = bk(() => (r || (r = t())).then((l) => l.default));
      e = o;
    }
    let a;
    return on(
      () => (a = e()) && lr(() => {
        if (!s)
          return a(i);
        const o = tt.context;
        _a(s);
        const l = a(i);
        return _a(o), l;
      })
    );
  };
  return n.preload = () => r || ((r = t()).then((i) => e = () => i.default), r), n;
}
var Mk = 0;
function b$() {
  const t = tt.context;
  return t ? `${t.id}${t.count++}` : `cl-${Mk++}`;
}
var A_ = (t) => `Stale read from <${t}>.`;
function w$(t) {
  const e = "fallback" in t && {
    fallback: () => t.fallback
  };
  return on(Dk(() => t.each, t.children, e || void 0));
}
function _$(t) {
  const e = "fallback" in t && {
    fallback: () => t.fallback
  };
  return on(Tk(() => t.each, t.children, e || void 0));
}
function E$(t) {
  const e = t.keyed, r = on(() => t.when, void 0, {
    equals: (n, i) => e ? n === i : !n == !i
  });
  return on(
    () => {
      const n = r();
      if (n) {
        const i = t.children;
        return typeof i == "function" && i.length > 0 ? lr(
          () => i(
            e ? n : () => {
              if (!lr(r))
                throw A_("Show");
              return t.when;
            }
          )
        ) : i;
      }
      return t.fallback;
    },
    void 0,
    void 0
  );
}
function S$(t) {
  let e = !1;
  const r = (s, a) => s[0] === a[0] && (e ? s[1] === a[1] : !s[1] == !a[1]) && s[2] === a[2], n = C_(() => t.children), i = on(
    () => {
      let s = n();
      Array.isArray(s) || (s = [s]);
      for (let a = 0; a < s.length; a++) {
        const o = s[a].when;
        if (o)
          return e = !!s[a].keyed, [a, o, s[a]];
      }
      return [-1];
    },
    void 0,
    {
      equals: r
    }
  );
  return on(
    () => {
      const [s, a, o] = i();
      if (s < 0)
        return t.fallback;
      const l = o.children;
      return typeof l == "function" && l.length > 0 ? lr(
        () => l(
          e ? a : () => {
            if (lr(i)[0] !== s)
              throw A_("Match");
            return o.when;
          }
        )
      ) : l;
    },
    void 0,
    void 0
  );
}
function O$(t) {
  return t;
}
var jk = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
], kk = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  ...jk
]), Uk = /* @__PURE__ */ new Set([
  "innerHTML",
  "textContent",
  "innerText",
  "children"
]), $k = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
}), Fk = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function qk(t, e) {
  const r = Fk[t];
  return typeof r == "object" ? r[e] ? r.$ : void 0 : r;
}
var zk = /* @__PURE__ */ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]), Vk = /* @__PURE__ */ new Set([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
]), Kk = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};
function Bk(t, e, r) {
  let n = r.length, i = e.length, s = n, a = 0, o = 0, l = e[i - 1].nextSibling, u = null;
  for (; a < i || o < s; ) {
    if (e[a] === r[o]) {
      a++, o++;
      continue;
    }
    for (; e[i - 1] === r[s - 1]; )
      i--, s--;
    if (i === a) {
      const h = s < n ? o ? r[o - 1].nextSibling : r[s - o] : l;
      for (; o < s; )
        t.insertBefore(r[o++], h);
    } else if (s === o)
      for (; a < i; )
        (!u || !u.has(e[a])) && e[a].remove(), a++;
    else if (e[a] === r[s - 1] && r[o] === e[i - 1]) {
      const h = e[--i].nextSibling;
      t.insertBefore(r[o++], e[a++].nextSibling), t.insertBefore(r[--s], h), e[i] = r[s];
    } else {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        let f = o;
        for (; f < s; )
          u.set(r[f], f++);
      }
      const h = u.get(e[a]);
      if (h != null)
        if (o < h && h < s) {
          let f = a, g = 1, m;
          for (; ++f < i && f < s && !((m = u.get(e[f])) == null || m !== h + g); )
            g++;
          if (g > h - o) {
            const w = e[a];
            for (; o < h; )
              t.insertBefore(r[o++], w);
          } else
            t.replaceChild(r[o++], e[a++]);
        } else
          a++;
      else
        e[a++].remove();
    }
  }
}
var Wv = "_$DX_DELEGATE";
function Hk(t, e, r, n = {}) {
  let i;
  return Es((s) => {
    i = s, e === document ? t() : Tf(e, t(), e.firstChild ? null : void 0, r);
  }, n.owner), () => {
    i(), e.textContent = "";
  };
}
function I$(t, e, r) {
  let n;
  const i = () => {
    const a = document.createElement("template");
    return a.innerHTML = t, r ? a.content.firstChild.firstChild : a.content.firstChild;
  }, s = e ? () => lr(() => document.importNode(n || (n = i()), !0)) : () => (n || (n = i())).cloneNode(!0);
  return s.cloneNode = s, s;
}
function Wk(t, e = window.document) {
  const r = e[Wv] || (e[Wv] = /* @__PURE__ */ new Set());
  for (let n = 0, i = t.length; n < i; n++) {
    const s = t[n];
    r.has(s) || (r.add(s), e.addEventListener(s, nU));
  }
}
function Df(t, e, r) {
  tt.context || (r == null ? t.removeAttribute(e) : t.setAttribute(e, r));
}
function Gk(t, e, r, n) {
  tt.context || (n == null ? t.removeAttributeNS(e, r) : t.setAttributeNS(e, r, n));
}
function Zk(t, e) {
  tt.context || (e == null ? t.removeAttribute("class") : t.className = e);
}
function Yk(t, e, r, n) {
  if (n)
    Array.isArray(r) ? (t[`$$${e}`] = r[0], t[`$$${e}Data`] = r[1]) : t[`$$${e}`] = r;
  else if (Array.isArray(r)) {
    const i = r[0];
    t.addEventListener(e, r[0] = (s) => i.call(t, r[1], s));
  } else
    t.addEventListener(e, r);
}
function Qk(t, e, r = {}) {
  const n = Object.keys(e || {}), i = Object.keys(r);
  let s, a;
  for (s = 0, a = i.length; s < a; s++) {
    const o = i[s];
    !o || o === "undefined" || e[o] || (Gv(t, o, !1), delete r[o]);
  }
  for (s = 0, a = n.length; s < a; s++) {
    const o = n[s], l = !!e[o];
    !o || o === "undefined" || r[o] === l || !l || (Gv(t, o, !0), r[o] = l);
  }
  return r;
}
function Jk(t, e, r) {
  if (!e)
    return r ? Df(t, "style") : e;
  const n = t.style;
  if (typeof e == "string")
    return n.cssText = e;
  typeof r == "string" && (n.cssText = r = void 0), r || (r = {}), e || (e = {});
  let i, s;
  for (s in r)
    e[s] == null && n.removeProperty(s), delete r[s];
  for (s in e)
    i = e[s], i !== r[s] && (n.setProperty(s, i), r[s] = i);
  return r;
}
function Xk(t, e = {}, r, n) {
  const i = {};
  return n || Ss(
    () => i.children = Co(t, e.children, i.children)
  ), Ss(() => e.ref && e.ref(t)), Ss(() => eU(t, e, r, !0, i, !0)), i;
}
function x$(t, e, r) {
  return lr(() => t(e, r));
}
function Tf(t, e, r, n) {
  if (r !== void 0 && !n && (n = []), typeof e != "function")
    return Co(t, e, n, r);
  Ss((i) => Co(t, e(), i, r), n);
}
function eU(t, e, r, n, i = {}, s = !1) {
  e || (e = {});
  for (const a in i)
    if (!(a in e)) {
      if (a === "children")
        continue;
      i[a] = Zv(t, a, null, i[a], r, s);
    }
  for (const a in e) {
    if (a === "children") {
      n || Co(t, e.children);
      continue;
    }
    const o = e[a];
    i[a] = Zv(t, a, o, i[a], r, s);
  }
}
function tU(t) {
  let e, r;
  return !tt.context || !(e = tt.registry.get(r = iU())) ? t() : (tt.completed && tt.completed.add(e), tt.registry.delete(r), e);
}
function rU(t) {
  return t.toLowerCase().replace(/-([a-z])/g, (e, r) => r.toUpperCase());
}
function Gv(t, e, r) {
  const n = e.trim().split(/\s+/);
  for (let i = 0, s = n.length; i < s; i++)
    t.classList.toggle(n[i], r);
}
function Zv(t, e, r, n, i, s) {
  let a, o, l, u, h;
  if (e === "style")
    return Jk(t, r, n);
  if (e === "classList")
    return Qk(t, r, n);
  if (r === n)
    return n;
  if (e === "ref")
    s || r(t);
  else if (e.slice(0, 3) === "on:") {
    const f = e.slice(3);
    n && t.removeEventListener(f, n), r && t.addEventListener(f, r);
  } else if (e.slice(0, 10) === "oncapture:") {
    const f = e.slice(10);
    n && t.removeEventListener(f, n, !0), r && t.addEventListener(f, r, !0);
  } else if (e.slice(0, 2) === "on") {
    const f = e.slice(2).toLowerCase(), g = zk.has(f);
    if (!g && n) {
      const m = Array.isArray(n) ? n[0] : n;
      t.removeEventListener(f, m);
    }
    (g || r) && (Yk(t, f, r, g), g && Wk([f]));
  } else if (e.slice(0, 5) === "attr:")
    Df(t, e.slice(5), r);
  else if ((h = e.slice(0, 5) === "prop:") || (l = Uk.has(e)) || !i && ((u = qk(e, t.tagName)) || (o = kk.has(e))) || (a = t.nodeName.includes("-"))) {
    if (h)
      e = e.slice(5), o = !0;
    else if (tt.context)
      return r;
    e === "class" || e === "className" ? Zk(t, r) : a && !o && !l ? t[rU(e)] = r : t[u || e] = r;
  } else {
    const f = i && e.indexOf(":") > -1 && Kk[e.split(":")[0]];
    f ? Gk(t, f, e, r) : Df(t, $k[e] || e, r);
  }
  return r;
}
function nU(t) {
  const e = `$$${t.type}`;
  let r = t.composedPath && t.composedPath()[0] || t.target;
  for (t.target !== r && Object.defineProperty(t, "target", {
    configurable: !0,
    value: r
  }), Object.defineProperty(t, "currentTarget", {
    configurable: !0,
    get() {
      return r || document;
    }
  }), tt.registry && !tt.done && (tt.done = _$HY.done = !0); r; ) {
    const n = r[e];
    if (n && !r.disabled) {
      const i = r[`${e}Data`];
      if (i !== void 0 ? n.call(r, i, t) : n.call(r, t), t.cancelBubble)
        return;
    }
    r = r._$host || r.parentNode || r.host;
  }
}
function Co(t, e, r, n, i) {
  if (tt.context) {
    !r && (r = [...t.childNodes]);
    let o = [];
    for (let l = 0; l < r.length; l++) {
      const u = r[l];
      u.nodeType === 8 && u.data.slice(0, 2) === "!$" ? u.remove() : o.push(u);
    }
    r = o;
  }
  for (; typeof r == "function"; )
    r = r();
  if (e === r)
    return r;
  const s = typeof e, a = n !== void 0;
  if (t = a && r[0] && r[0].parentNode || t, s === "string" || s === "number") {
    if (tt.context)
      return r;
    if (s === "number" && (e = e.toString()), a) {
      let o = r[0];
      o && o.nodeType === 3 ? o.data = e : o = document.createTextNode(e), r = Zs(t, r, n, o);
    } else
      r !== "" && typeof r == "string" ? r = t.firstChild.data = e : r = t.textContent = e;
  } else if (e == null || s === "boolean") {
    if (tt.context)
      return r;
    r = Zs(t, r, n);
  } else {
    if (s === "function")
      return Ss(() => {
        let o = e();
        for (; typeof o == "function"; )
          o = o();
        r = Co(t, o, r, n);
      }), () => r;
    if (Array.isArray(e)) {
      const o = [], l = r && Array.isArray(r);
      if (Pf(o, e, r, i))
        return Ss(() => r = Co(t, o, r, n, !0)), () => r;
      if (tt.context) {
        if (!o.length)
          return r;
        if (n === void 0)
          return [...t.childNodes];
        let u = o[0], h = [u];
        for (; (u = u.nextSibling) !== n; )
          h.push(u);
        return r = h;
      }
      if (o.length === 0) {
        if (r = Zs(t, r, n), a)
          return r;
      } else
        l ? r.length === 0 ? Yv(t, o, n) : Bk(t, r, o) : (r && Zs(t), Yv(t, o));
      r = o;
    } else if (e.nodeType) {
      if (tt.context && e.parentNode)
        return r = a ? [e] : e;
      if (Array.isArray(r)) {
        if (a)
          return r = Zs(t, r, n, e);
        Zs(t, r, null, e);
      } else
        r == null || r === "" || !t.firstChild ? t.appendChild(e) : t.replaceChild(e, t.firstChild);
      r = e;
    }
  }
  return r;
}
function Pf(t, e, r, n) {
  let i = !1;
  for (let s = 0, a = e.length; s < a; s++) {
    let o = e[s], l = r && r[s], u;
    if (!(o == null || o === !0 || o === !1))
      if ((u = typeof o) == "object" && o.nodeType)
        t.push(o);
      else if (Array.isArray(o))
        i = Pf(t, o, l) || i;
      else if (u === "function")
        if (n) {
          for (; typeof o == "function"; )
            o = o();
          i = Pf(
            t,
            Array.isArray(o) ? o : [o],
            Array.isArray(l) ? l : [l]
          ) || i;
        } else
          t.push(o), i = !0;
      else {
        const h = String(o);
        l && l.nodeType === 3 && l.data === h ? t.push(l) : t.push(document.createTextNode(h));
      }
  }
  return i;
}
function Yv(t, e, r = null) {
  for (let n = 0, i = e.length; n < i; n++)
    t.insertBefore(e[n], r);
}
function Zs(t, e, r, n) {
  if (r === void 0)
    return t.textContent = "";
  const i = n || document.createTextNode("");
  if (e.length) {
    let s = !1;
    for (let a = e.length - 1; a >= 0; a--) {
      const o = e[a];
      if (i !== o) {
        const l = o.parentNode === t;
        !s && !a ? l ? t.replaceChild(i, o) : t.insertBefore(i, r) : l && o.remove();
      } else
        s = !0;
    }
  } else
    t.insertBefore(i, r);
  return [i];
}
function iU() {
  const t = tt.context;
  return `${t.id}${t.count++}`;
}
var sU = "http://www.w3.org/2000/svg";
function L_(t, e = !1) {
  return e ? document.createElementNS(sU, t) : document.createElement(t);
}
function C$(t) {
  const { useShadow: e } = t, r = document.createTextNode(""), n = () => t.mount || document.body, i = Hv();
  let s, a = !!tt.context;
  return x_(
    () => {
      a && (Hv().user = a = !1), s || (s = _k(i, () => on(() => t.children)));
      const o = n();
      if (o instanceof HTMLHeadElement) {
        const [l, u] = Kr(!1), h = () => u(!0);
        Es((f) => Tf(o, () => l() ? f() : s(), null)), nc(h);
      } else {
        const l = L_(t.isSVG ? "g" : "div", t.isSVG), u = e && l.attachShadow ? l.attachShadow({
          mode: "open"
        }) : l;
        Object.defineProperty(l, "_$host", {
          get() {
            return r.parentNode;
          },
          configurable: !0
        }), Tf(u, s), o.appendChild(l), t.ref && t.ref(l), nc(() => o.removeChild(l));
      }
    },
    void 0,
    {
      render: !a
    }
  ), r;
}
function D$(t) {
  const [e, r] = Ak(t, ["component"]), n = on(() => e.component);
  return on(() => {
    const i = n();
    switch (typeof i) {
      case "function":
        return lr(() => i(r));
      case "string":
        const s = Vk.has(i), a = tt.context ? tU() : L_(i, s);
        return Xk(a, r, s), a;
    }
  });
}
var oU = (
  /** @class */
  function() {
    function t() {
      this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
    }
    return t.prototype.set = function(e, r) {
      this.keyToValue.set(e, r), this.valueToKey.set(r, e);
    }, t.prototype.getByKey = function(e) {
      return this.keyToValue.get(e);
    }, t.prototype.getByValue = function(e) {
      return this.valueToKey.get(e);
    }, t.prototype.clear = function() {
      this.keyToValue.clear(), this.valueToKey.clear();
    }, t;
  }()
), M_ = (
  /** @class */
  function() {
    function t(e) {
      this.generateIdentifier = e, this.kv = new oU();
    }
    return t.prototype.register = function(e, r) {
      this.kv.getByValue(e) || (r || (r = this.generateIdentifier(e)), this.kv.set(r, e));
    }, t.prototype.clear = function() {
      this.kv.clear();
    }, t.prototype.getIdentifier = function(e) {
      return this.kv.getByValue(e);
    }, t.prototype.getValue = function(e) {
      return this.kv.getByKey(e);
    }, t;
  }()
), aU = /* @__PURE__ */ function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var s in i)
        Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), cU = (
  /** @class */
  function(t) {
    aU(e, t);
    function e() {
      var r = t.call(this, function(n) {
        return n.name;
      }) || this;
      return r.classToAllowedProps = /* @__PURE__ */ new Map(), r;
    }
    return e.prototype.register = function(r, n) {
      typeof n == "object" ? (n.allowProps && this.classToAllowedProps.set(r, n.allowProps), t.prototype.register.call(this, r, n.identifier)) : t.prototype.register.call(this, r, n);
    }, e.prototype.getAllowedProps = function(r) {
      return this.classToAllowedProps.get(r);
    }, e;
  }(M_)
), uU = function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
};
function lU(t) {
  if ("values" in Object)
    return Object.values(t);
  var e = [];
  for (var r in t)
    t.hasOwnProperty(r) && e.push(t[r]);
  return e;
}
function hU(t, e) {
  var r = lU(t);
  if ("find" in r)
    return r.find(e);
  for (var n = r, i = 0; i < n.length; i++) {
    var s = n[i];
    if (e(s))
      return s;
  }
}
function Do(t, e) {
  Object.entries(t).forEach(function(r) {
    var n = uU(r, 2), i = n[0], s = n[1];
    return e(s, i);
  });
}
function fu(t, e) {
  return t.indexOf(e) !== -1;
}
function Qv(t, e) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    if (e(n))
      return n;
  }
}
var dU = (
  /** @class */
  function() {
    function t() {
      this.transfomers = {};
    }
    return t.prototype.register = function(e) {
      this.transfomers[e.name] = e;
    }, t.prototype.findApplicable = function(e) {
      return hU(this.transfomers, function(r) {
        return r.isApplicable(e);
      });
    }, t.prototype.findByName = function(e) {
      return this.transfomers[e];
    }, t;
  }()
), fU = function(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}, j_ = function(t) {
  return typeof t > "u";
}, pU = function(t) {
  return t === null;
}, ic = function(t) {
  return typeof t != "object" || t === null || t === Object.prototype ? !1 : Object.getPrototypeOf(t) === null ? !0 : Object.getPrototypeOf(t) === Object.prototype;
}, Rf = function(t) {
  return ic(t) && Object.keys(t).length === 0;
}, Gi = function(t) {
  return Array.isArray(t);
}, gU = function(t) {
  return typeof t == "string";
}, yU = function(t) {
  return typeof t == "number" && !isNaN(t);
}, mU = function(t) {
  return typeof t == "boolean";
}, vU = function(t) {
  return t instanceof RegExp;
}, sc = function(t) {
  return t instanceof Map;
}, oc = function(t) {
  return t instanceof Set;
}, k_ = function(t) {
  return fU(t) === "Symbol";
}, bU = function(t) {
  return t instanceof Date && !isNaN(t.valueOf());
}, wU = function(t) {
  return t instanceof Error;
}, Jv = function(t) {
  return typeof t == "number" && isNaN(t);
}, Xv = function(t) {
  return mU(t) || pU(t) || j_(t) || yU(t) || gU(t) || k_(t);
}, _U = function(t) {
  return typeof t == "bigint";
}, EU = function(t) {
  return t === 1 / 0 || t === -1 / 0;
}, SU = function(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}, OU = function(t) {
  return t instanceof URL;
}, U_ = function(t) {
  return t.replace(/\./g, "\\.");
}, nd = function(t) {
  return t.map(String).map(U_).join(".");
}, Ia = function(t) {
  for (var e = [], r = "", n = 0; n < t.length; n++) {
    var i = t.charAt(n), s = i === "\\" && t.charAt(n + 1) === ".";
    if (s) {
      r += ".", n++;
      continue;
    }
    var a = i === ".";
    if (a) {
      e.push(r), r = "";
      continue;
    }
    r += i;
  }
  var o = r;
  return e.push(o), e;
}, Nf = function() {
  return Nf = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, Nf.apply(this, arguments);
}, Af = function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}, Lf = function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
function Yn(t, e, r, n) {
  return {
    isApplicable: t,
    annotation: e,
    transform: r,
    untransform: n
  };
}
var $_ = [
  Yn(j_, "undefined", function() {
    return null;
  }, function() {
  }),
  Yn(_U, "bigint", function(t) {
    return t.toString();
  }, function(t) {
    return typeof BigInt < "u" ? BigInt(t) : t;
  }),
  Yn(bU, "Date", function(t) {
    return t.toISOString();
  }, function(t) {
    return new Date(t);
  }),
  Yn(wU, "Error", function(t, e) {
    var r = {
      name: t.name,
      message: t.message
    };
    return e.allowedErrorProps.forEach(function(n) {
      r[n] = t[n];
    }), r;
  }, function(t, e) {
    var r = new Error(t.message);
    return r.name = t.name, r.stack = t.stack, e.allowedErrorProps.forEach(function(n) {
      r[n] = t[n];
    }), r;
  }),
  Yn(vU, "regexp", function(t) {
    return "" + t;
  }, function(t) {
    var e = t.slice(1, t.lastIndexOf("/")), r = t.slice(t.lastIndexOf("/") + 1);
    return new RegExp(e, r);
  }),
  Yn(
    oc,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(t) {
      return Lf([], Af(t.values()));
    },
    function(t) {
      return new Set(t);
    }
  ),
  Yn(sc, "map", function(t) {
    return Lf([], Af(t.entries()));
  }, function(t) {
    return new Map(t);
  }),
  Yn(function(t) {
    return Jv(t) || EU(t);
  }, "number", function(t) {
    return Jv(t) ? "NaN" : t > 0 ? "Infinity" : "-Infinity";
  }, Number),
  Yn(function(t) {
    return t === 0 && 1 / t === -1 / 0;
  }, "number", function() {
    return "-0";
  }, Number),
  Yn(OU, "URL", function(t) {
    return t.toString();
  }, function(t) {
    return new URL(t);
  })
];
function kl(t, e, r, n) {
  return {
    isApplicable: t,
    annotation: e,
    transform: r,
    untransform: n
  };
}
var F_ = kl(function(t, e) {
  if (k_(t)) {
    var r = !!e.symbolRegistry.getIdentifier(t);
    return r;
  }
  return !1;
}, function(t, e) {
  var r = e.symbolRegistry.getIdentifier(t);
  return ["symbol", r];
}, function(t) {
  return t.description;
}, function(t, e, r) {
  var n = r.symbolRegistry.getValue(e[1]);
  if (!n)
    throw new Error("Trying to deserialize unknown symbol");
  return n;
}), IU = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(t, e) {
  return t[e.name] = e, t;
}, {}), q_ = kl(SU, function(t) {
  return ["typed-array", t.constructor.name];
}, function(t) {
  return Lf([], Af(t));
}, function(t, e) {
  var r = IU[e[1]];
  if (!r)
    throw new Error("Trying to deserialize unknown typed array");
  return new r(t);
});
function z_(t, e) {
  if (t != null && t.constructor) {
    var r = !!e.classRegistry.getIdentifier(t.constructor);
    return r;
  }
  return !1;
}
var V_ = kl(z_, function(t, e) {
  var r = e.classRegistry.getIdentifier(t.constructor);
  return ["class", r];
}, function(t, e) {
  var r = e.classRegistry.getAllowedProps(t.constructor);
  if (!r)
    return Nf({}, t);
  var n = {};
  return r.forEach(function(i) {
    n[i] = t[i];
  }), n;
}, function(t, e, r) {
  var n = r.classRegistry.getValue(e[1]);
  if (!n)
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  return Object.assign(Object.create(n.prototype), t);
}), K_ = kl(function(t, e) {
  return !!e.customTransformerRegistry.findApplicable(t);
}, function(t, e) {
  var r = e.customTransformerRegistry.findApplicable(t);
  return ["custom", r.name];
}, function(t, e) {
  var r = e.customTransformerRegistry.findApplicable(t);
  return r.serialize(t);
}, function(t, e, r) {
  var n = r.customTransformerRegistry.findByName(e[1]);
  if (!n)
    throw new Error("Trying to deserialize unknown custom value");
  return n.deserialize(t);
}), xU = [V_, F_, K_, q_], e0 = function(t, e) {
  var r = Qv(xU, function(i) {
    return i.isApplicable(t, e);
  });
  if (r)
    return {
      value: r.transform(t, e),
      type: r.annotation(t, e)
    };
  var n = Qv($_, function(i) {
    return i.isApplicable(t, e);
  });
  if (n)
    return {
      value: n.transform(t, e),
      type: n.annotation
    };
}, B_ = {};
$_.forEach(function(t) {
  B_[t.annotation] = t;
});
var CU = function(t, e, r) {
  if (Gi(e))
    switch (e[0]) {
      case "symbol":
        return F_.untransform(t, e, r);
      case "class":
        return V_.untransform(t, e, r);
      case "custom":
        return K_.untransform(t, e, r);
      case "typed-array":
        return q_.untransform(t, e, r);
      default:
        throw new Error("Unknown transformation: " + e);
    }
  else {
    var n = B_[e];
    if (!n)
      throw new Error("Unknown transformation: " + e);
    return n.untransform(t, r);
  }
}, so = function(t, e) {
  for (var r = t.keys(); e > 0; )
    r.next(), e--;
  return r.next().value;
};
function H_(t) {
  if (fu(t, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (fu(t, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (fu(t, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
var DU = function(t, e) {
  H_(e);
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    if (oc(t))
      t = so(t, +n);
    else if (sc(t)) {
      var i = +n, s = +e[++r] == 0 ? "key" : "value", a = so(t, i);
      switch (s) {
        case "key":
          t = a;
          break;
        case "value":
          t = t.get(a);
          break;
      }
    } else
      t = t[n];
  }
  return t;
}, Mf = function(t, e, r) {
  if (H_(e), e.length === 0)
    return r(t);
  for (var n = t, i = 0; i < e.length - 1; i++) {
    var s = e[i];
    if (Gi(n)) {
      var a = +s;
      n = n[a];
    } else if (ic(n))
      n = n[s];
    else if (oc(n)) {
      var o = +s;
      n = so(n, o);
    } else if (sc(n)) {
      var l = i === e.length - 2;
      if (l)
        break;
      var o = +s, u = +e[++i] == 0 ? "key" : "value", h = so(n, o);
      switch (u) {
        case "key":
          n = h;
          break;
        case "value":
          n = n.get(h);
          break;
      }
    }
  }
  var f = e[e.length - 1];
  if (Gi(n) ? n[+f] = r(n[+f]) : ic(n) && (n[f] = r(n[f])), oc(n)) {
    var g = so(n, +f), m = r(g);
    g !== m && (n.delete(g), n.add(m));
  }
  if (sc(n)) {
    var o = +e[e.length - 2], w = so(n, o), u = +f == 0 ? "key" : "value";
    switch (u) {
      case "key": {
        var S = r(w);
        n.set(S, n.get(w)), S !== w && n.delete(w);
        break;
      }
      case "value": {
        n.set(w, r(n.get(w)));
        break;
      }
    }
  }
  return t;
}, Si = function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}, Ui = function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
};
function jf(t, e, r) {
  if (r === void 0 && (r = []), !!t) {
    if (!Gi(t)) {
      Do(t, function(a, o) {
        return jf(a, e, Ui(Ui([], Si(r)), Si(Ia(o))));
      });
      return;
    }
    var n = Si(t, 2), i = n[0], s = n[1];
    s && Do(s, function(a, o) {
      jf(a, e, Ui(Ui([], Si(r)), Si(Ia(o))));
    }), e(i, r);
  }
}
function TU(t, e, r) {
  return jf(e, function(n, i) {
    t = Mf(t, i, function(s) {
      return CU(s, n, r);
    });
  }), t;
}
function PU(t, e) {
  function r(a, o) {
    var l = DU(t, Ia(o));
    a.map(Ia).forEach(function(u) {
      t = Mf(t, u, function() {
        return l;
      });
    });
  }
  if (Gi(e)) {
    var n = Si(e, 2), i = n[0], s = n[1];
    i.forEach(function(a) {
      t = Mf(t, Ia(a), function() {
        return t;
      });
    }), s && Do(s, r);
  } else
    Do(e, r);
  return t;
}
var RU = function(t, e) {
  return ic(t) || Gi(t) || sc(t) || oc(t) || z_(t, e);
};
function NU(t, e, r) {
  var n = r.get(t);
  n ? n.push(e) : r.set(t, [e]);
}
function AU(t) {
  var e = {}, r = void 0;
  return t.forEach(function(n) {
    if (!(n.length <= 1)) {
      var i = Si(n.map(function(o) {
        return o.map(String);
      }).sort(function(o, l) {
        return o.length - l.length;
      })), s = i[0], a = i.slice(1);
      s.length === 0 ? r = a.map(nd) : e[nd(s)] = a.map(nd);
    }
  }), r ? Rf(e) ? [r] : [r, e] : Rf(e) ? void 0 : e;
}
var W_ = function(t, e, r, n, i) {
  var s;
  if (n === void 0 && (n = []), i === void 0 && (i = []), Xv(t) || NU(t, n, e), !RU(t, r)) {
    var a = e0(t, r);
    return a ? {
      transformedValue: a.value,
      annotations: [a.type]
    } : {
      transformedValue: t
    };
  }
  if (fu(i, t))
    return {
      transformedValue: null
    };
  var o = e0(t, r), l = (s = o == null ? void 0 : o.value) !== null && s !== void 0 ? s : t;
  Xv(t) || (i = Ui(Ui([], Si(i)), [t]));
  var u = Gi(l) ? [] : {}, h = {};
  return Do(l, function(f, g) {
    var m = W_(f, e, r, Ui(Ui([], Si(n)), [g]), i);
    u[g] = m.transformedValue, Gi(m.annotations) ? h[g] = m.annotations : ic(m.annotations) && Do(m.annotations, function(w, S) {
      h[U_(g) + "." + S] = w;
    });
  }), Rf(h) ? {
    transformedValue: u,
    annotations: o ? [o.type] : void 0
  } : {
    transformedValue: u,
    annotations: o ? [o.type, h] : h
  };
};
function G_(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function LU(t) {
  if (G_(t) !== "Object")
    return !1;
  const e = Object.getPrototypeOf(t);
  return !!e && e.constructor === Object && e === Object.prototype;
}
function t0(t) {
  return G_(t) === "Array";
}
function MU(t, e, r, n, i) {
  const s = {}.propertyIsEnumerable.call(n, e) ? "enumerable" : "nonenumerable";
  s === "enumerable" && (t[e] = r), i && s === "nonenumerable" && Object.defineProperty(t, e, {
    value: r,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
}
function kf(t, e = {}) {
  if (t0(t))
    return t.map((i) => kf(i, e));
  if (!LU(t))
    return t;
  const r = Object.getOwnPropertyNames(t), n = Object.getOwnPropertySymbols(t);
  return [...r, ...n].reduce((i, s) => {
    if (t0(e.props) && !e.props.includes(s))
      return i;
    const a = t[s], o = kf(a, e);
    return MU(i, s, o, t, e.nonenumerable), i;
  }, {});
}
var gs = function() {
  return gs = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, gs.apply(this, arguments);
}, jU = function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var n = r.call(t), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}, kU = function(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++)
    t[i] = e[r];
  return t;
}, Z_ = (
  /** @class */
  function() {
    function t() {
      this.classRegistry = new cU(), this.symbolRegistry = new M_(function(e) {
        var r;
        return (r = e.description) !== null && r !== void 0 ? r : "";
      }), this.customTransformerRegistry = new dU(), this.allowedErrorProps = [];
    }
    return t.prototype.serialize = function(e) {
      var r = /* @__PURE__ */ new Map(), n = W_(e, r, this), i = {
        json: n.transformedValue
      };
      n.annotations && (i.meta = gs(gs({}, i.meta), { values: n.annotations }));
      var s = AU(r);
      return s && (i.meta = gs(gs({}, i.meta), { referentialEqualities: s })), i;
    }, t.prototype.deserialize = function(e) {
      var r = e.json, n = e.meta, i = kf(r);
      return n != null && n.values && (i = TU(i, n.values, this)), n != null && n.referentialEqualities && (i = PU(i, n.referentialEqualities)), i;
    }, t.prototype.stringify = function(e) {
      return JSON.stringify(this.serialize(e));
    }, t.prototype.parse = function(e) {
      return this.deserialize(JSON.parse(e));
    }, t.prototype.registerClass = function(e, r) {
      this.classRegistry.register(e, r);
    }, t.prototype.registerSymbol = function(e, r) {
      this.symbolRegistry.register(e, r);
    }, t.prototype.registerCustom = function(e, r) {
      this.customTransformerRegistry.register(gs({ name: r }, e));
    }, t.prototype.allowErrorProps = function() {
      for (var e, r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      (e = this.allowedErrorProps).push.apply(e, kU([], jU(r)));
    }, t.defaultInstance = new t(), t.serialize = t.defaultInstance.serialize.bind(t.defaultInstance), t.deserialize = t.defaultInstance.deserialize.bind(t.defaultInstance), t.stringify = t.defaultInstance.stringify.bind(t.defaultInstance), t.parse = t.defaultInstance.parse.bind(t.defaultInstance), t.registerClass = t.defaultInstance.registerClass.bind(t.defaultInstance), t.registerSymbol = t.defaultInstance.registerSymbol.bind(t.defaultInstance), t.registerCustom = t.defaultInstance.registerCustom.bind(t.defaultInstance), t.allowErrorProps = t.defaultInstance.allowErrorProps.bind(t.defaultInstance), t;
  }()
), UU = Z_.serialize, T$ = Z_.stringify;
function P$(t) {
  return t.state.fetchStatus === "fetching" ? "fetching" : t.getObserversCount() ? t.state.fetchStatus === "paused" ? "paused" : t.isStale() ? "stale" : "fresh" : "inactive";
}
function R$(t, e) {
  return `${t}${e.charAt(0).toUpperCase() + e.slice(1)}`;
}
function N$({
  queryState: t,
  observerCount: e,
  isStale: r
}) {
  return t.fetchStatus === "fetching" ? "blue" : e ? t.fetchStatus === "paused" ? "purple" : r ? "yellow" : "green" : "gray";
}
function A$({
  status: t,
  isPaused: e
}) {
  return e ? "purple" : t === "error" ? "red" : t === "pending" ? "yellow" : t === "success" ? "green" : "gray";
}
function L$(t) {
  return t === "fresh" ? "green" : t === "stale" ? "yellow" : t === "paused" ? "purple" : t === "inactive" ? "gray" : "blue";
}
var M$ = (t, e = !1) => {
  const {
    json: r
  } = UU(t);
  return JSON.stringify(r, null, e ? 2 : void 0);
}, Jc = (t) => t.state.fetchStatus !== "idle" ? 0 : t.getObserversCount() ? t.isStale() ? 2 : 1 : 3, $U = (t, e) => t.queryHash.localeCompare(e.queryHash), Y_ = (t, e) => t.state.dataUpdatedAt < e.state.dataUpdatedAt ? 1 : -1, FU = (t, e) => Jc(t) === Jc(e) ? Y_(t, e) : Jc(t) > Jc(e) ? 1 : -1, j$ = {
  status: FU,
  "query hash": $U,
  "last updated": Y_
}, Xc = (t) => t.state.isPaused ? 0 : t.state.status === "error" ? 2 : t.state.status === "pending" ? 1 : 3, Q_ = (t, e) => t.state.submittedAt < e.state.submittedAt ? 1 : -1, qU = (t, e) => Xc(t) === Xc(e) ? Q_(t, e) : Xc(t) > Xc(e) ? 1 : -1, k$ = {
  status: qU,
  "last updated": Q_
}, U$ = (t) => t * parseFloat(getComputedStyle(document.documentElement).fontSize), $$ = () => {
  const [t, e] = Kr("dark");
  return wk(() => {
    const r = window.matchMedia("(prefers-color-scheme: dark)");
    e(r.matches ? "dark" : "light");
    const n = (i) => {
      e(i.matches ? "dark" : "light");
    };
    r.addEventListener("change", n), nc(() => r.removeEventListener("change", n));
  }), t;
}, eu = (t, e, r) => {
  if (e.length === 0)
    return r;
  if (t instanceof Map) {
    const n = new Map(t);
    if (e.length === 1)
      return n.set(e[0], r), n;
    const [i, ...s] = e;
    return n.set(i, eu(n.get(i), s, r)), n;
  }
  if (t instanceof Set) {
    const n = eu(Array.from(t), e, r);
    return new Set(n);
  }
  if (Array.isArray(t)) {
    const n = [...t];
    if (e.length === 1)
      return n[e[0]] = r, n;
    const [i, ...s] = e;
    return n[i] = eu(n[i], s, r), n;
  }
  if (t instanceof Object) {
    const n = {
      ...t
    };
    if (e.length === 1)
      return n[e[0]] = r, n;
    const [i, ...s] = e;
    return n[i] = eu(n[i], s, r), n;
  }
  return t;
}, tu = (t, e) => {
  if (t instanceof Map) {
    const r = new Map(t);
    if (e.length === 1)
      return r.delete(e[0]), r;
    const [n, ...i] = e;
    return r.set(n, tu(r.get(n), i)), r;
  }
  if (t instanceof Set) {
    const r = tu(Array.from(t), e);
    return new Set(r);
  }
  if (Array.isArray(t)) {
    const r = [...t];
    if (e.length === 1)
      return r.filter((s, a) => a.toString() !== e[0]);
    const [n, ...i] = e;
    return r[n] = tu(r[n], i), r;
  }
  if (t instanceof Object) {
    const r = {
      ...t
    };
    if (e.length === 1)
      return delete r[e[0]], r;
    const [n, ...i] = e;
    return r[n] = tu(r[n], i), r;
  }
  return t;
}, zU = (t) => {
  if (!t || document.querySelector("#_goober"))
    return;
  const r = document.createElement("style"), n = document.createTextNode("");
  r.appendChild(n), r.id = "_goober", r.setAttribute("nonce", t), document.head.appendChild(r);
}, go, ac, cc, uc, bs, lc, yo, mo, vo, bo, wo, hc, r0, VU = (r0 = class {
  constructor(t) {
    ln(this, go, void 0);
    ln(this, ac, void 0);
    ln(this, cc, void 0);
    ln(this, uc, void 0);
    ln(this, bs, !1);
    ln(this, lc, void 0);
    ln(this, yo, void 0);
    ln(this, mo, void 0);
    ln(this, vo, void 0);
    ln(this, bo, void 0);
    ln(this, wo, void 0);
    ln(this, hc, void 0);
    const {
      client: e,
      queryFlavor: r,
      version: n,
      onlineManager: i,
      buttonPosition: s,
      position: a,
      initialIsOpen: o,
      errorTypes: l,
      styleNonce: u
    } = t;
    Jr(this, go, Kr(e)), Jr(this, cc, r), Jr(this, uc, n), Jr(this, ac, i), Jr(this, lc, u), Jr(this, yo, Kr(s)), Jr(this, mo, Kr(a)), Jr(this, vo, Kr(o)), Jr(this, bo, Kr(l));
  }
  setButtonPosition(t) {
    Zt(this, yo)[1](t);
  }
  setPosition(t) {
    Zt(this, mo)[1](t);
  }
  setInitialIsOpen(t) {
    Zt(this, vo)[1](t);
  }
  setErrorTypes(t) {
    Zt(this, bo)[1](t);
  }
  setClient(t) {
    Zt(this, go)[1](t);
  }
  mount(t) {
    if (Zt(this, bs))
      throw new Error("Devtools is already mounted");
    const e = Hk(() => {
      const [r] = Zt(this, yo), [n] = Zt(this, mo), [i] = Zt(this, vo), [s] = Zt(this, bo), [a] = Zt(this, go);
      let o;
      Zt(this, wo) ? o = Zt(this, wo) : (o = Lk(() => import("./N66J3ZXT-KtdcTR3m.js")), Jr(this, wo, o)), zU(Zt(this, lc));
      const l = this;
      return Pk(o, Nk({
        get queryFlavor() {
          return Zt(l, cc);
        },
        get version() {
          return Zt(l, uc);
        },
        get onlineManager() {
          return Zt(l, ac);
        }
      }, {
        get client() {
          return a();
        },
        get buttonPosition() {
          return r();
        },
        get position() {
          return n();
        },
        get initialIsOpen() {
          return i();
        },
        get errorTypes() {
          return s();
        }
      }));
    }, t);
    Jr(this, bs, !0), Jr(this, hc, e);
  }
  unmount() {
    var t;
    if (!Zt(this, bs))
      throw new Error("Devtools is not mounted");
    (t = Zt(this, hc)) == null || t.call(this), Jr(this, bs, !1);
  }
}, go = new WeakMap(), ac = new WeakMap(), cc = new WeakMap(), uc = new WeakMap(), bs = new WeakMap(), lc = new WeakMap(), yo = new WeakMap(), mo = new WeakMap(), vo = new WeakMap(), bo = new WeakMap(), wo = new WeakMap(), hc = new WeakMap(), r0);
function KU(t) {
  const e = jb(), r = t.client || e, n = X_(null), { buttonPosition: i, position: s, initialIsOpen: a, errorTypes: o, styleNonce: l } = t, [u] = Ea(
    new VU({
      client: r,
      queryFlavor: "React Query",
      version: "5",
      onlineManager: Ra,
      buttonPosition: i,
      position: s,
      initialIsOpen: a,
      errorTypes: o,
      styleNonce: l
    })
  );
  return pr(() => {
    u.setClient(r);
  }, [r, u]), pr(() => {
    i && u.setButtonPosition(i);
  }, [i, u]), pr(() => {
    s && u.setPosition(s);
  }, [s, u]), pr(() => {
    u.setInitialIsOpen(a || !1);
  }, [a, u]), pr(() => {
    u.setErrorTypes(o || []);
  }, [o, u]), pr(() => (n.current && u.mount(n.current), () => {
    u.unmount();
  }), [u]), /* @__PURE__ */ Zi.createElement("div", { className: "tsqd-parent-container", ref: n });
}
var BU = process.env.NODE_ENV !== "development" ? function() {
  return null;
} : KU;
const J_ = new nC(), F$ = ({ dAppName: t, dAppDescription: e, dAppUrl: r, dAppIconURL: n, children: i, debugQuery: s = !1 }) => (pr(() => {
  ZM({
    dAppName: t,
    dAppDescription: e,
    dAppUrl: r,
    dAppIconURL: n
  }), fc.defaultMaxListeners = 100;
}, []), /* @__PURE__ */ Vv.jsxs(uC, { client: J_, children: [
  s && /* @__PURE__ */ Vv.jsx(BU, { initialIsOpen: !1 }),
  i
] })), q$ = async () => {
  const t = await Bt(), e = await t.getSession();
  if (!e || !t)
    return { error: "no session or connection" };
  try {
    return await t.request({
      topic: e.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "getSelectedAccount"
      }
    });
  } catch (r) {
    const n = r.message;
    return console.error("getAccount error", n), { error: n };
  }
}, z$ = async ({ address: t }) => {
  const e = await Bt(), r = await e.getSession();
  if (!r || !e)
    return { error: "no session or connection" };
  try {
    return await e.request({
      topic: r.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "getBalance",
        params: {
          assetId: void 0,
          address: t
        }
      }
    });
  } catch (n) {
    const i = n.message;
    return console.error("getBalance error", i), { error: i };
  }
}, V$ = async () => {
  const t = await Bt();
  if (!t)
    throw new Error("call setConnection() first!");
  const e = await t.getSession();
  if (e)
    return console.log("Already connected!", e), e;
  try {
    const r = await t.connect({
      requiredNamespaces: {
        aleo: {
          methods: Eb,
          chains: op,
          events: Sb
        }
      }
    });
    return Su.emit("session_change"), window.localStorage.removeItem("WALLETCONNECT_DEEPLINK_CHOICE"), r;
  } catch (r) {
    console.error("connect error", r.message);
  }
}, K$ = async (t) => {
  const e = await Bt(), r = await (e == null ? void 0 : e.getSession());
  if (!r || !e)
    return { error: "no session or connection" };
  const n = t == null ? void 0 : t.inputs.map((i) => typeof i == "string" ? i : i.plaintext);
  try {
    return await e.request({
      topic: r.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "requestCreateEvent",
        params: {
          ...t,
          inputs: n
        }
      }
    });
  } catch (i) {
    const s = i.message;
    return console.error("createEvent error", s), { error: s };
  }
}, B$ = async () => {
  const t = await Bt(), e = await (t == null ? void 0 : t.getSession());
  if (!e || !t)
    return { error: "no session or connection" };
  try {
    return await t.request({
      topic: e.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "createSharedState",
        params: {}
      }
    });
  } catch (r) {
    const n = r.message;
    return console.error("createSharedState error", n), { error: n };
  }
}, H$ = async (t) => {
  const e = await Bt(), r = await (e == null ? void 0 : e.getSession());
  if (!r || !e)
    return { error: "no session or connection" };
  try {
    return await e.request({
      topic: r.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "decrypt",
        params: {
          ciphertexts: t
        }
      }
    });
  } catch (n) {
    return console.error("decrypt error", n.message), { error: n.message };
  }
}, W$ = async () => {
  const t = await Bt(), e = await (t == null ? void 0 : t.getSession());
  if (!e || !t)
    return { error: "no session or connection" };
  try {
    try {
      await t.disconnect({
        reason: zt("USER_DISCONNECTED"),
        topic: e.topic
      }), Su.emit("session_change");
    } catch (r) {
      console.warn(r);
    }
    return {};
  } catch (r) {
    const n = r.message;
    return console.error("error disconnecting", n), { error: n };
  }
}, G$ = async ({
  id: t,
  address: e
}) => {
  const r = await Bt(), n = await (r == null ? void 0 : r.getSession());
  if (!n || !r)
    return { event: void 0, error: "no session or connection" };
  const i = async () => await r.request({
    topic: n.topic,
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "getEvent",
      params: {
        id: t,
        address: e
      }
    }
  });
  try {
    return await i();
  } catch (s) {
    const a = s.message;
    return console.error("getEvents error", a), { error: a };
  }
}, Z$ = async (t) => {
  const e = await Bt(), r = await (e == null ? void 0 : e.getSession());
  if (!r || !e)
    return { events: void 0, error: "no session or connection" };
  (t == null ? void 0 : t.programId) === "" && (t.programId = void 0);
  const n = async (i = 0) => await e.request({
    topic: r.topic,
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "getEvents",
      params: {
        filter: t,
        page: i
      }
    }
  });
  try {
    return await n();
  } catch (i) {
    const s = i.message;
    return console.error("getEvents error", s), { error: s };
  }
}, Y$ = async (t) => {
  const e = await Bt(), r = await (e == null ? void 0 : e.getSession());
  if (!r || !e)
    return { error: "no session or connection" };
  try {
    return await e.request({
      topic: r.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "importSharedState",
        params: {
          seed: t
        }
      }
    });
  } catch (n) {
    const i = n.message;
    return console.error("importSharedState error", i), { error: i };
  }
}, Q$ = async ({
  address: t,
  filter: e,
  page: r = 0
}) => {
  const n = await Bt(), i = await (n == null ? void 0 : n.getSession());
  if (!i || !n)
    return { error: "no session or connection" };
  const s = async (a = 0) => await n.request({
    topic: i.topic,
    chainId: "aleo:1",
    request: {
      jsonrpc: "2.0",
      method: "getRecords",
      params: {
        address: t,
        filter: e,
        page: a
      }
    }
  });
  try {
    return await s();
  } catch (a) {
    const o = a.message;
    return console.error("getRecords error", o), { error: o };
  }
}, J$ = async ({
  message: t,
  address: e
}) => {
  const r = await Bt(), n = await (r == null ? void 0 : r.getSession());
  if (!n || !r)
    return { error: "no session or connection" };
  try {
    return await r.request({
      topic: n.topic,
      chainId: "aleo:1",
      request: {
        jsonrpc: "2.0",
        method: "requestSignature",
        params: {
          message: t,
          address: jp.test(e ?? "") ? e : void 0
        }
      }
    });
  } catch (i) {
    const s = i.message;
    return console.error("signature error", s), { error: s };
  }
}, X$ = 20;
export {
  Ju as $,
  N$ as A,
  A$ as B,
  Xk as C,
  V9 as D,
  Nk as E,
  L$ as F,
  M$ as G,
  w$ as H,
  f$ as I,
  RC as J,
  nc as K,
  S_ as L,
  g$ as M,
  b$ as N,
  $b as O,
  m$ as P,
  v$ as Q,
  a1 as R,
  E$ as S,
  n0 as T,
  _$ as U,
  eu as V,
  Yy as W,
  I$ as X,
  x$ as Y,
  U$ as Z,
  R$ as _,
  Pn as a,
  B$ as a$,
  P$ as a0,
  lr as a1,
  Es as a2,
  Ak as a3,
  C$ as a4,
  Yk as a5,
  T$ as a6,
  O$ as a7,
  S$ as a8,
  tu as a9,
  wf as aA,
  bf as aB,
  Ef as aC,
  _f as aD,
  jp as aE,
  ak as aF,
  sk as aG,
  ok as aH,
  ck as aI,
  uk as aJ,
  ik as aK,
  e$ as aL,
  c$ as aM,
  a$ as aN,
  i$ as aO,
  u$ as aP,
  r$ as aQ,
  n$ as aR,
  s$ as aS,
  o$ as aT,
  t$ as aU,
  l$ as aV,
  X$ as aW,
  q$ as aX,
  z$ as aY,
  V$ as aZ,
  K$ as a_,
  y$ as aa,
  D$ as ab,
  C_ as ac,
  Kv as ad,
  Ld as ae,
  F9 as af,
  q9 as ag,
  K9 as ah,
  B9 as ai,
  H9 as aj,
  W9 as ak,
  G9 as al,
  Z9 as am,
  Y9 as an,
  Q9 as ao,
  J9 as ap,
  X9 as aq,
  h$ as ar,
  Ob as as,
  Ec as at,
  Ox as au,
  Ib as av,
  _n as aw,
  J_ as ax,
  F$ as ay,
  $v as az,
  gh as b,
  H$ as b0,
  W$ as b1,
  G$ as b2,
  Z$ as b3,
  Y$ as b4,
  Q$ as b5,
  J$ as b6,
  Uv as b7,
  zE as b8,
  t9 as b9,
  QE as ba,
  XE as bb,
  v9 as bc,
  ZE as bd,
  VE as be,
  l9 as bf,
  KE as bg,
  d9 as bh,
  BE as bi,
  HE as bj,
  JE as bk,
  y9 as bl,
  WE as bm,
  GE as bn,
  c9 as bo,
  YE as bp,
  Eb as bq,
  op as br,
  Sb as bs,
  Ex as bt,
  Sx as bu,
  U9 as bv,
  E_ as bw,
  Su as bx,
  $9 as by,
  Bt as bz,
  Cr as c,
  Wk as d,
  j$ as e,
  Kr as f,
  $$ as g,
  Eo as h,
  on as i,
  Pk as j,
  x_ as k,
  wk as l,
  k$ as m,
  Gp as n,
  ZU as o,
  Tn as p,
  Tf as q,
  Ss as r,
  $h as s,
  GU as t,
  Zk as u,
  p$ as v,
  Dr as w,
  z9 as x,
  _o as y,
  Df as z
};
